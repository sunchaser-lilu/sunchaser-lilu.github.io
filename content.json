{"pages":[{"title":"","text":"","link":"/link/index.html"},{"title":"关于","text":"Java开发工程师邮箱：admin@lilu.org.cn","link":"/about/index.html"},{"title":"谷歌广告iframe","text":"谷歌广告iframe (adsbygoogle=window.adsbygoogle || []).push({})","link":"/adsense/index.html"},{"title":"","text":"🎈🎈微笑墙🎈🎈 彭小苒 唐艺昕 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/hexo-theme-sunchaser/avatar.png 网站名称：打工这件小事 网站地址：https://lilu.org.cn 网站简介：月亮的信封里，会不会有星星的来信 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"来而不往非礼也","link":"/message/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"GitHub年度报告","text":"GitHub年度总结 #github-annual-summary[src=\"\"],#github-annual-summary:not([src]){ opacity:0; width: auto; height: auto; max-width: 100%; max-height: 100%; } 查收你的2020开源报告 查看报告 回到首页 (adsbygoogle=window.adsbygoogle || []).push({}) ©2020 - 2021 By SunChaser (adsbygoogle=window.adsbygoogle || []).push({}) layui.use('layer', function(){ var layer = layui.layer; }); function get_github() { var github_id = $(\"#github-id\").val(); var img = $(\"#github-annual-summary\"); if (github_id === null || github_id === undefined || github_id === '') { img.css(\"width\",\"0\"); img.css(\"height\",\"0\"); img.attr('src',''); layer.msg('请输入GitHub用户名'); return; } var loadIndex = layer.load(1, { shade: [0.1,'#000'] }); $.ajax({ type: \"GET\", timeout: 30000, url: \"//47.92.27.29:520/github?github_id=\" + github_id, dataType: \"JSON\", success: function(result) { const str = '//47.92.27.29:520' + result.img_path.substring(1); layer.close(loadIndex); img.css(\"width\",\"100%\"); img.css(\"height\",\"100%\"); img.attr('src',str); }, complete : function(XMLHttpRequest,status){ //请求完成后最终执行参数 if(status=='timeout'){//超时,status还有success,error等值的情况 ajaxTimeoutTest.abort(); layer.msg('系统繁忙，请稍后再试！'); } } }); }","link":"/github/annual/summary/index.html"}],"posts":[{"title":"JavaBucket","text":"Java技能树 JavaSEJDK源码解析系列 JDK源码解析之Serializable JDK源码解析之RandomAccess JDK源码解析之Cloneable JDK源码解析之List JDK源码解析之Collection JDK源码解析之AbstractCollection JDK源码解析之AbstractList JDK源码解析之Queue JDK源码解析之Deque JDK源码解析之LinkedList JDK源码解析之AbstractSequentialList JDK源码解析之ArrayList 面试必问HashMap 基础 深入理解深浅拷贝 方法重载Overload 基本数据类型char为什么不会被隐式转换成byte或short类型？ 关于Java，你不得不学的java.lang.String类 JVM 何为引用 Java虚拟机是如何运行字节码的 对象是“生”是“死” 回收前的自救 垃圾收集器 垃圾收集算法 数据结构-算法数据结构 数据结构之链表-基础知识 数据结构之链表-使用非递归法实现单链表的反转 数据结构之链表-奇数个元素的链表的中间节点 LeetCode题解 （简单）两数之和 （简单）整数反转 （简单）有效的字母异位词 链表标签：面试题：链表相交 LeetCode链表标签简单题 返回倒数第k个节点 删除中间节点 合并两个有序链表 回文链表 删除链表中的节点 删除链表的节点 链表的中间节点 移除链表元素 两个链表的第一个公共节点 反转链表 二进制链表转整数 链表相交 相交链表 回文链表 反转链表 删除链表M个节点后的N个节点 删除排序链表中的重复元素 环形链表 移除重复节点 从尾到头打印链表 勇闯算法 勇闯算法-递归法拿下反转链表的三杀 勇闯算法-在行列都排好序的矩阵中找指定的数 JavaEE Apache Maven必知必会 数据库Redis String字符串 List列表 Hash哈希 Set集合 ZSet集合 Redis集群配置 通用Redis命令 Redis扩展知识 其它Redis服务器命令 MySQL 事务的特性和隔离级别 MySQL为什么选择可重复读作为默认的隔离级别？ 中间件 Apache ShardingSphere 分库分表中间件之ShardingSphere-入门案例 xxl-job 修炼xxl-job之搭建本地调度平台 修炼xxl-job之示例执行器XxlJobConfig配置类源码解析 修炼xxl-job之调度中心启动流程解析 修炼xxl-job之调度中心—初始化国际化组件 修炼xxl-job之调度中心—初始化注册中心“心跳续约”服务 修炼xxl-job之调度中心—初始化失败任务管理中心 分布式待完善… 微服务待完善… 项目管理-持续集成Linux Linux命令 Docker Docker常用命令 创建MySQL5.7的Docker容器 常用软件安装系列 重装Windows10系统 Windows 10下Node.js安装与配置 Windows 10下Maven安装及配置 Windows 10下JDK安装及环境变量配置 Windows 10下IntelliJ IDEA 2019.3.2安装和常用配置 Windows 10下Git安装及SSH公私钥配置 Git待完善… Jenkins待完善… 优秀书籍 Java 8实战 《Java 8实战》读书笔记系列——第一部分：基础知识 《Java 8实战》读书笔记系列——第二部分：函数式数据处理 《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（一）：接口重构和新特性 《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（二）：优雅的解决NPE问题 《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（三）：从一个生产环境的事故到异步编程思想 《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（四）：使用新的日期时间API 待完善… 《剑指Offer》 实现线程安全的单例模式 数组中重复的数（题目一） 数组中重复的数（题目二） 二维数组中的查找 替换空格 面试题5（相关题目） 从尾到头打印链表 重建二叉树 二叉树的下一个节点 两个栈实现一个队列 两个队列实现一个栈 斐波那楔数列 青蛙跳台阶问题 青蛙跳台阶问题扩展（变态跳台阶） 矩形覆盖 几万个员工年龄排序 旋转数组的最小数字 矩阵中的路径 机器人的运动范围 剪绳子 二进制中1的个数 数值的整数次方 打印从1到最大的n位数 在O(1)时间内删除链表节点 删除链表中重复的节点 正则表达式匹配 表示数值的字符串 链表中倒数第k个节点 链表中环的入口节点 反转链表 合并两个排序的链表 待完善… 《程序员代码面试指南-IT名企算法和数据结构题目最优解》 待完善…","link":"/2019/12/13/java-bucket/"},{"title":"LeetCode题解-链表标签：回文链表","text":"题目：请判断一个单向链表是否为回文链表。 Leetcode在线OJ系统：传送门 示例1： graph LR A[1]-->B[2] 1输出：false 示例2: graph LR A[1]-->B[2] B[2]-->C[2] C[2]-->D[1] 1输出：true 思路： 首先需要知道什么是“回文”：回文指的是无论正向还是反向读，得到的结果一致。由于单向链表的特点，如果我们直接读原链表，则只能正向读取，无法进行判断。所以我们需要进行一定的转化。 转换方式一：将整个单向链表映射到一个数组中，然后使用两个指针分别从数组两端开始遍历，当遇到数值不相等的节点时，可断定为非回文链表，如果遍历到两个节点相遇时都未发现数值不相等的节点，则为回文链表。 单链表节点类定义可查看文章：数据结构之链表-基础知识 Java语言实现如下： 12345678910111213public static boolean isPalindrome(SinglyLinkedListNode head) { List&lt;SinglyLinkedListNode&gt; list = new ArrayList&lt;&gt;(); while (head != null) { list.add(head); head = head.next; } for (int i = 0,size = list.size();i &lt; size / 2;i++) { if (!list.get(i).val.equals(list.get(size - i - 1).val)) { return false; } } return true;} 这种方式的空间复杂度为O(n)，时间复杂度为O(n + n/2) = O(n)。 转换方式二：不使用额外空间，我们在原链表上做文章，如果一个单向链表为回文链表，我们可以先将前半段链表进行反转，然后再使用两个指针p1和p2，p1从头部开始，p2从中间开始，遍历链表，当遇到数值不相等的节点，可断定为非回文链表；如果p2遍历到尾部都还未遇到数值不相等的节点，则为回文链表。 如何将前半段链表进行反转？可利用一快一慢两个指针先找到中间节点，然后将从头节点开始到中间节点的这一部分进行反转。 Java语言实现如下： 12345678910111213141516171819202122232425262728293031323334353637public static boolean isPalindromeUseReverse(SinglyLinkedListNode head) { if (head == null || head.next == null) { return true; } // 快慢指针 SinglyLinkedListNode fast = head; SinglyLinkedListNode slow = head; // 快指针走到末尾时，慢指针指向中间节点 while (fast != null &amp;&amp; fast.next != null) { fast = fast.next.next; slow = slow.next; } // 反转从头节点到中间节点之间的部分 SinglyLinkedListNode p1 = head; SinglyLinkedListNode p2 = slow; SinglyLinkedListNode pre = slow; SinglyLinkedListNode next; while (p1 != p2) { next = p1.next; p1.next = pre; pre = p1; p1 = next; } // 如果原链接节点个数为奇数，则中间节点p2（slow）需要右移一位才能进行回文比较 // 例如：1-&gt;2-&gt;3-&gt;2-&gt;1；反转前半部分后为：2-&gt;1-&gt;3-&gt;2-&gt;1 // p2指向中间节点3，需要右移一位指向2，才能进行回文比较 if (fast != null) p2 = p2.next; // 此时pre指向新链表的头节点 while (p2 != null) { if (!pre.val.equals(p2.val) { return false; } pre = pre.next; p2 = p2.next; } return true;} 此方式的时间复杂度为：O(n + n/2 + n/2) = O(n)，空间复杂度为O(1)。 缺点是改变了原链表的结构，但可在判断出是否为回文链表后再次反转前半部分节点，从而恢复原链表的结构。 方式二的优化版本：使用快慢指针寻找中间节点的过程中慢指针已经遍历了前半部分链表，可就在这一次的遍历中进行反转。 优化后的代码实现如下： 123456789101112131415161718192021222324public static boolean isPalindromeUseReverseOptimization(SinglyLinkedListNode head) { if (head == null || head.next == null) { return true; } SinglyLinkedListNode fast = head; SinglyLinkedListNode slow = head; SinglyLinkedListNode pre = null; SinglyLinkedListNode next; // 慢指针移动的同时进行反转 while (fast != null &amp; fast.next != null) { fast = fast.next.next; next = slow.next; slow.next = pre; pre = slow; slow = next; } if (fast != null) slow = slow.next; while (slow != null) { if (!pre.val.equals(slow.val)) return false; pre = pre.next; slow = slow.next; } return true;} 优化后的时间复杂度为：O(n/2 + n/2) = O(n)，空间复杂度为O(1)。但仍然破坏了原链表的结构，同样地，可再次反转链表前半部分进行恢复。","link":"/2021/01/03/algorithm/leetcode/tag/linkedlist/palindrome-linked-list/"},{"title":"云设计模式之缓存备用模式（Cache-Aside Pattern）","text":"基本概念作用：将数据按需从数据库加载到缓存中。 此模式可以提高性能，并能保持缓存和数据库中数据的一致性。 问题背景应用程序使用缓存来优化对数据库中存储信息的重复访问。但是，期望缓存和数据库中的数据完全一致是不切实际的。 应用程序应该实现一种有助于确保缓存中的数据尽量保持最新，同时当缓存中的数据过期时可以检测和处理的策略。 解决方案很多商业缓存系统提供read-through和write-through/write-behind操作。在这些系统中，应用程序通过引用缓存来检索数据。如果数据不在缓存中，则从数据库中透明地查询数据并将其添加至缓存中；对缓存中保存的数据的任何修改也会自动写回到数据库中。 对于不提供此功能的缓存，由使用缓存来维护数据的应用程序负责。 应用程序可以通过实现缓存备用模式来模拟read-through缓存的功能。该模式可根据需要将数据高效地加载到缓存中。下图总结了此过程中的步骤。 通俗的讲，分为以下步骤： 先查询缓存，判断缓存是否存在。 如果缓存不存在，则从数据库中查询。 然后将数据中查出来的数据设置到缓存中。 如果应用程序需要修改数据库中的数据，可使用以下write-through策略： 修改数据库。 让缓存失效。 当下一次请求到来时，由于使用了缓存备用模式，将从数据库中查询出最新的数据并将其设置回缓存中。 问题与思考在决定如何实现此模式时，应考虑以下几点： 缓存数据的生命周期：很多缓存实现了过期策略，如果在指定的时间内未访问缓存数据，缓存会自动失效并进行删除。为了使缓存备用模式高效，请确保过期策略与使用该缓存的应用程序的访问模式相匹配。不要将过期时间设置的太短，否则可能导致应用程序不断从数据库中查询数据并将其添加至缓存中；同样不要设置的太长，以免缓存的数据不是最新的。请记住，对于相对静态的数据或经常读取的数据，使用缓存最有效。 淘汰数据：即内存淘汰策略。与数据库相比，大多数高速缓存只有有限的内存空间大小，在必要的时候会进行内存淘汰。大多数缓存都使用LRU（最近最少使用）算法来实现，但这可以进行自定义，可配置缓存的全局过期属性以及每个缓存key的过期属性，以帮助缓存具有成本效益。将内存淘汰策略应用于所有缓存key并不总是合适的，例如，如果从数据中查询并添加至缓存中的代价非常昂贵，那么将其保留在缓存中可能是有益的。 启动缓存：即缓存预热。许多解决方案会在应用程序启动过程中预先加载可能需要的数据至缓存中。如果这部分缓存过期或被淘汰，缓存备用模式仍然有效。 一致性：实现缓存备用模式并不能保证数据库和缓存之间的数据一致性。数据库中的数据可能在任意时刻被外部修改，并且在下次该数据被加载到缓存中之前，此修改可能不会反映在缓存中。在跨数据存储复制数据的系统中，如果非常频繁的发生同步，则此问题可能会变得特别严重。 本地缓存：缓存可以存在于应用程序实例的本地内存中，如果应用程序重复访问相同的数据，缓存备用模式会非常有用。但是本地缓存是每个应用程序实例私有的，在分布式系统中，本地缓存之间的数据可能很快变得不一致，我们需要非常频繁的刷新本地缓存并且设置较短的过期时间。在这种情况下，应该考虑使用分布式缓存。 什么场景使用该模式？适用场景： 缓存系统不提供read-through和write-through操作。 资源需求无法进行预测。此模式可使应用程序按需加载数据至缓存，它不会预先假设应用程序需要哪些数据。 不适合使用的场景： 当缓存的数据为静态的时候，如果缓存空间足够存储数据，请在启动时进行缓存预热，并让其永不过期。 在Web应用程序中缓存会话状态信息。此场景下应避免引入基于客户端-服务端相似性的依赖关系。 使用示例在日常开发中，我们一般会使用Redis作为多个应用程序实例之间共享的分布式缓存。以下代码中的selectCacheOrDb方法展示了基于Redis的缓存备用模式的模板方法实现。该方法使用read-through从缓存中读取数据。 首先从缓存中读取数据； 如果缓存数据不存在，则从数据库进行查询； 如果数据库中的数据存在，则将其设置到缓存中，设置一个过期时间，然后返回； 如果缓存数据存在，则直接返回缓存中的数据； 整个过程如果出现异常，返回默认值进行降级。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.sunchaser.sparrow.designpatterns.cloud;import com.alibaba.fastjson.JSONObject;import com.alibaba.fastjson.TypeReference;import com.sunchaser.sparrow.designpatterns.common.model.request.CacheAsideRequest;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;import java.util.Objects;import java.util.concurrent.TimeUnit;/** * @author sunchaser admin@lilu.org.cn * @since JDK8 2021/1/3 */@Component@Slf4j@RequiredArgsConstructor(onConstructor = @__(@Autowired))public class CacheAsidePattern { private final RedisTemplate&lt;String,String&gt; redisTemplate; public &lt;T&gt; T selectCacheOrDb(CacheAsideRequest&lt;T&gt; cacheAsideRequest) { try { String cacheKey = cacheAsideRequest.getCacheKey(); // random 防止雪崩 int expiredTime = cacheAsideRequest.getExpiredTime() + ThreadLocalRandom.current().nextInt(60); TimeUnit timeUnit = cacheAsideRequest.getTimeUnit(); String cacheValueString = redisTemplate.opsForValue().get(cacheKey); if (StringUtils.isEmpty(cacheValueString)) { T dbValue = cacheAsideRequest.getDbSelector().get(); log.info(&quot;cache miss, query db and the db value is: {}&quot;,dbValue); if (Objects.nonNull(dbValue)) { redisTemplate.opsForValue().set( cacheKey, JSONObject.toJSONString(dbValue), expiredTime, timeUnit ); } return dbValue; } else { T t = JSONObject.parseObject(cacheValueString, new TypeReference&lt;T&gt;() {}); log.info(&quot;hit cache, the cache value is: {}&quot;,cacheValueString); return t; } } catch (Exception e) { log.info(&quot;query cache or db error!&quot;); return cacheAsideRequest.getDefaultValue(); } }} 其中方法入参CacheAsideRequest的具体字段如下： 12345678910111213141516171819202122232425262728293031323334353637383940package com.sunchaser.sparrow.designpatterns.common.model.request;import lombok.Data;import java.util.concurrent.TimeUnit;import java.util.function.Supplier;/** * 缓存备用模式请求入参 * @author sunchaser admin@lilu.org.cn * @since JDK8 2021/1/3 */@Datapublic class CacheAsideRequest&lt;T&gt; { /** * 缓存key */ private String cacheKey; /** * 缓存过期时间 */ private Integer expiredTime; /** * 过期时间的单位 */ private TimeUnit timeUnit; /** * DB查询器 */ private Supplier&lt;T&gt; dbSelector; /** * 发生异常进行降级的默认值 */ private T defaultValue;} 我们使用HashMap模拟一个数据库，当需要查询时，以下代码中的testSelectCacheOrDb方法展示了我们的使用方式，testUpdate方法模拟了数据库的更新。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.sunchaser.sparrow.designpatterns.cloud;import com.google.common.collect.Maps;import com.sunchaser.sparrow.designpatterns.common.model.request.CacheAsideRequest;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.test.context.junit4.SpringRunner;import java.util.Map;import java.util.concurrent.TimeUnit;/** * @author sunchaser admin@lilu.org.cn * @since JDK8 2021/1/3 */@SpringBootTest@RunWith(SpringRunner.class)public class CacheAsidePatternTest { @Autowired private CacheAsidePattern cacheAsidePattern; @Autowired private RedisTemplate&lt;String,String&gt; redisTemplate; private static final Map&lt;String,String&gt; db = Maps.newHashMap(); @Before public void setUp() throws Exception { db.put(&quot;defaultUser&quot;,&quot;defaultValue&quot;); db.put(&quot;user1&quot;,&quot;value1&quot;); db.put(&quot;user2&quot;,&quot;value2&quot;); db.put(&quot;user3&quot;,&quot;value3&quot;); db.put(&quot;user4&quot;,&quot;value4&quot;); } @Test public void testSelectCacheOrDb() { CacheAsideRequest&lt;String&gt; cacheAsideRequest = new CacheAsideRequest&lt;&gt;(); cacheAsideRequest.setCacheKey(&quot;test-key&quot;); cacheAsideRequest.setExpiredTime(100); cacheAsideRequest.setTimeUnit(TimeUnit.SECONDS); cacheAsideRequest.setDbSelector(() -&gt; db.get(&quot;user1&quot;)); cacheAsideRequest.setDefaultValue(db.get(&quot;defaultUser&quot;)); String s = cacheAsidePattern.selectCacheOrDb(cacheAsideRequest); System.out.println(s); } @Test public void testUpdate() { db.put(&quot;user1&quot;,&quot;updateValue1&quot;); redisTemplate.delete(&quot;test-key&quot;); }} 请注意，我们在更新数据时，应该先更新数据库，再让缓存失效。这样带来的数据延迟只有一个redis操作的时间。 如果先让缓存失效，后更新数据库。在这两步操作的窗口期间，有很小的可能客户端会先读取到数据库中旧的数据并将其重新设置到缓存中，然后对数据库的更新才正式提交。这会导致缓存中的数据不是最新。 扩展部分有时候我们希望对从数据库中查询出的数据进行一定的校验后才决定是否存入缓存。例如查询出的数据包含的字段全部不为零值才进行缓存，或者查询出的数据包含的字段只要有一个为零值就进行缓存。另外一方面，我们从数据库中查询出来的数据可能是一个数据表实体对象，也可能是一个包含数据表实体对象的ArrayList集合，所以我们需要进行分类讨论。对外我们提供一个可选的策略，对内我们兼容单个实体类和集合两种情况。根据数据库查询返回的数据类型执行不同的解析方式，我们利用反射来解析单个对象或集合中的每一个对象的字段是否为零值。 零值：例如Integer的零值为0；Long的零值为0L；Double的零值为0.00等等，还可根据具体的业务场景进行自定义。 下面给出我们的策略枚举类CacheStrategyEnum实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150package com.sunchaser.sparrow.designpatterns.common.enums;import com.google.common.collect.Lists;import com.google.common.collect.Maps;import lombok.Getter;import java.lang.reflect.Field;import java.util.List;import java.util.Map;/** * 缓存策略枚举及策略对应的实现 * @author sunchaser admin@lilu.org.cn * @since JDK8 2021/1/3 */@Getterpublic enum CacheStrategyEnum { ALL_NO_ZERO(&quot;ALL_NO_ZERO&quot;,&quot;全部字段不为零则进行缓存&quot;) { @Override public boolean analysisList(List&lt;?&gt; list) throws IllegalAccessException { for (Object el : list) { // 获取包含父类super的所有字段 Field[] allFields = getAllFields(el); for (Field field : allFields) { field.setAccessible(true); // 只要有一个字段为零，返回false if (analysisZero(field.get(el))) return false; } } return true; } @Override public boolean analysisCustomObject(Object object) throws IllegalAccessException { Field[] allFields = getAllFields(object); for (Field field : allFields) { field.setAccessible(true); // 只要有一个字段为零，返回false if (analysisZero(field.get(object))) return false; } return true; } }, ANY_NO_ZERO(&quot;ANY_NO_ZERO&quot;,&quot;任意一个字段不为零则进行缓存&quot;) { @Override public boolean analysisList(List&lt;?&gt; list) throws IllegalAccessException { for (Object el : list) { // 获取包含父类super的所有字段 Field[] allFields = getAllFields(el); for (Field field : allFields) { field.setAccessible(true); // 任意一个字段不为零，返回true if (!analysisZero(field.get(el))) return true; } } return false; } @Override public boolean analysisCustomObject(Object object) throws IllegalAccessException { Field[] allFields = getAllFields(object); for (Field field : allFields) { field.setAccessible(true); // 任意一个字段不为零，返回true if (!analysisZero(field.get(object))) return true; } return false; } }; /** * 缓存策略 */ private final String strategy; /** * 描述 */ private final String desc; /** * flyweight */ private static final Map&lt;String,CacheStrategyEnum&gt; enumMap = Maps.newHashMap(); static { for (CacheStrategyEnum cacheStrategyEnum : CacheStrategyEnum.values()) enumMap.put(cacheStrategyEnum.strategy,cacheStrategyEnum); } public CacheStrategyEnum getEnumByStrategy(String strategy) { return enumMap.get(strategy); } CacheStrategyEnum(String strategy, String desc) { this.strategy = strategy; this.desc = desc; } /** * 抽象方法：解析List中的自定义对象 * @param list list对象 * @return false：不进行缓存；true：进行缓存 * @throws IllegalAccessException 上层进行异常处理 */ public abstract boolean analysisList(List&lt;?&gt; list) throws IllegalAccessException ; /** * 抽象方法：解析自定义对象 * @param object 待解析的自定义对象 * @return false：不进行缓存；true：进行缓存 * @throws IllegalAccessException 上层进行异常处理 */ public abstract boolean analysisCustomObject(Object object) throws IllegalAccessException ; /** * 解析字段是否为零值 * @param o 待解析字段 * @return true：为零值；false：不为零。 */ private static boolean analysisZero(Object o) { if (o instanceof Long) { return (Long) o == 0L; } else if (o instanceof Integer) { return (Integer) o == 0; } else if (o instanceof Double) { return (Double) o == 0.00; } else { // do other biz zero } return false; } /** * 获取包含super父类的所有字段 * @param object 需要获取字段的对象 * @return 对象的所有字段 */ private static Field[] getAllFields(Object object) { Class&lt;?&gt; clazz = object.getClass(); List&lt;Field&gt; fieldList = Lists.newArrayList(); while (clazz != null) { fieldList.addAll(Lists.newArrayList(clazz.getDeclaredFields())); clazz = clazz.getSuperclass(); } Field[] fields = new Field[fieldList.size()]; fieldList.toArray(fields); return fields; }} 此时我们需要在模板方法的入参CacheAsideRequest中添加该枚举字段。同时模板方法selectCacheOrDb的实现也要做对应修改，具体可看以下代码。 123456789101112131415161718192021222324252627282930313233343536public &lt;T&gt; T selectCacheOrDb(CacheAsideRequest&lt;T&gt; cacheAsideRequest) { try { String cacheKey = cacheAsideRequest.getCacheKey(); // random 防止雪崩 int expiredTime = cacheAsideRequest.getExpiredTime() + ThreadLocalRandom.current().nextInt(60); TimeUnit timeUnit = cacheAsideRequest.getTimeUnit(); CacheStrategyEnum cacheStrategyEnum = cacheAsideRequest.getCacheStrategyEnum(); String cacheValueString = redisTemplate.opsForValue().get(cacheKey); if (StringUtils.isEmpty(cacheValueString)) { T dbValue = cacheAsideRequest.getDbSelector().get(); log.info(&quot;cache miss, query db and the db value is: {}&quot;,dbValue); if (Objects.nonNull(dbValue)) { // flag的含义：false：不进行缓存；true：进行缓存。 boolean flag; // 解析List中的每一个对象的零值 if (dbValue instanceof List) flag = cacheStrategyEnum.analysisList((List&lt;?&gt;) dbValue); // 解析单个对象的零值 else flag = cacheStrategyEnum.analysisCustomObject(dbValue); if (flag) redisTemplate.opsForValue().set( cacheKey, JSONObject.toJSONString(dbValue), expiredTime, timeUnit ); } return dbValue; } else { T t = JSONObject.parseObject(cacheValueString, new TypeReference&lt;T&gt;() {}); log.info(&quot;hit cache, the cache value is: {}&quot;,cacheValueString); return t; } } catch (Exception e) { log.info(&quot;query cache or db error!&quot;); return cacheAsideRequest.getDefaultValue(); }} 总结本文介绍了云设计模式之缓存备用模式的基本概念和原理，然后使用了一个较为通用的模板方法实现了缓存备用模式，最后我们还对模板方法中一些可能出现的业务细节进行了扩展，这对现有的业务系统是一个很好的实现参考。 参考https://docs.microsoft.com/en-us/previous-versions/msp-n-p/dn589799(v=pandp.10)","link":"/2021/01/03/design-patterns/cloud/cache-aside-pattern/"},{"title":"Nginx安装与卸载","text":"Nginx安装的两种方式方式一：yum源安装我们使用Nginx官方的yum源。可去 http://nginx.org/en/linux_packages.html 查看主线版和稳定版的yum源，一般我们会使用稳定版本。 首先需要添加nginx官方的yum源文件： 1touch /etc/yum.repos.d/nginx.repo 然后vim编辑该repo文件添加以下内容： 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1 保存后使用以下命令进行安装： 1yum install -y nginx 安装完成后使用以下命令启动： 1/bin/systemctl start nginx.service 方式二：源码编译安装安装gcc库nginx使用c语言编写，源码编译方式需要安装gcc编译器。一般阿里云等云服务器商都会自带gcc，如果用的是虚拟机，可以先检查是否已安装。 使用命令gcc -v可查看版本信息，如果提示命令找不到，则需要执行yum -y install gcc安装gcc。 pcre、pcre-devel安装1yum install -y pcre pcre-devel pcre是一个perl库，包括perl兼容的正则表达式库，nginx的http模块使用pcre来解析正则表达式，所以需要进行安装。 zlib安装1yum install -y zlib zlib-devel zlib库提供了多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip压缩，所以需要安装。 openssl安装1yum install -y openssl openssl-devel 可用来加密https协议。 下载Nginx源码包1wget http://nginx.org/download/nginx-1.18.0.tar.gz 可以去http://nginx.org/download/页面查看更多版本信息，选择稳定版本下载即可。 解压并编译安装解压至当前目录即可： 1tar zxvf nginx-1.18.0.tar.gz 解压完成后进入nginx目录：cd nginx-1.18.0 设置nginx的安装路径： 1./configure --prefix=/opt/nginx --prefix表示将nginx安装至/opt/nginx目录下。 最后一步，进行编译和安装： 1make &amp; make install 启动nginx服务： 1/opt/nginx/sbin/nginx ./nginx 访问nginx首页直接访问云服务器的公网ip即可。 如果是阿里云服务器，需要去阿里云控制台添加80端口至该主机的安全组入网方向。 卸载已安装的Nginx首先需要停止Nginx服务：/bin/systemctl stop nginx.service 如果是使用yum源安装的，可使用命令find / -name nginx*查看nginx相关文件，先手动删除一些源文件： 12rm -rf /usr/sbin/nginxrm -rf /etc/nginx 再使用yum remove nginx清理。 如果是源码包编译安装的，先停止服务，然后删除整个安装目录即可。","link":"/2021/01/01/ops/nginx/install-nginx/"},{"title":"LeetCode题解-链表标签：合并两个有序链表","text":"题目：将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入： graph LR A[1]-->B[2] B[2]-->C[4] graph LR A[1]-->B[3] B[3]-->C[4] 输出： graph LR A[1]-->B[1] B[1]-->C[2] C[2]-->D[3] D[3]-->E[4] E[4]-->F[4] 思路： 已知条件：两个链表的头节点l1和l2。 对于两个升序链表，它们的长度不一定相等，当我们把较短的链表合并完成后，直接连接较长链表的剩余部分即可。 我们并不知道哪一个的头节点值更小，所以需要分类讨论。 递归法： 我们可以用如下的公式定义我们的递归merge操作： 判断l1和l2哪一个链表的头节点值较小，将较小的那个节点的下一个节点与另一个链表进行递归merge。 递归的出口：如果递归到l1[0]或l2[0]为null时，直接返回另外一个链表。另外一个链表可能也为null（如果原链表长度相等），或者非null（原链表长度不等）。 单链表节点类定义可查看文章：数据结构之链表-基础知识 Java语言实现如下： 123456789101112public static SinglyLinkedListNode mergeTwoSortedLinkedListRecursionImpl(SinglyLinkedListNode l1, SinglyLinkedListNode l2) { if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &lt; l2.val) { l1.next = mergeTwoSortedLinkedListRecursionImpl(l1.next, l2); return l1; } else { l2.next = mergeTwoSortedLinkedListRecursionImpl(l1,l2.next); return l2; }} 迭代法： 正所谓所有的递归都可以转化成迭代。 由于待合并的两个链表都有序，合并后的头节点要么是l1要么是l2。如果我们不希望修改原来的链表，就需要构造出一个新链表，顺序连接两个原链表的各个节点。 首先，我们创建一个哨兵节点hair，然后维护一个cur指针，每次使用cur指针去连接各个节点。我们依次比较l1和l2节点的值，如果l1的值小于l2，则用cur连接l1，然后l1右移；否则，用cur连接l2，然后l2右移。直到l1或者l2为null，将另一个节点的剩余节点连接至cur，然后再返回hair.next，即为合并后链表的新头节点。 哨兵节点hair：指针域next指向的节点即为合并后的链表的头节点。 Java语言实现如下： 1234567891011121314151617181920public static SinglyLinkedListNode mergeTwoSortedLinkedList(SinglyLinkedListNode l1, SinglyLinkedListNode l2) { if (l1 == null) return l2; if (l2 == null) return l1; SinglyLinkedListNode hair = new SinglyLinkedListNode(); SinglyLinkedListNode cur = hair; while (l1 != null &amp;&amp; l2 != null) { if (l1.val &lt; l2.val) { cur.next = l1; l1 = l1.next; } else { cur.next = l2; l2 = l2.next; } cur = cur.next; } if (l1 == null) cur.next = l2; if (l2 == null) cur.next = l1; return hair.next;}","link":"/2020/12/29/algorithm/leetcode/tag/linkedlist/merge-two-sorted-lists/"},{"title":"LeetCode题解-链表标签：删除中间节点","text":"题目：实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。 示例： graph LR A[a]-->B[b] B[b]-->C[c] C[c]-->D[d] D[d]-->E[e] 12输入：节点c结果：不返回任何数据，将节点c从原链表中删除。 思路：这题的思路有点意思。首先我们只能访问到节点c，按照常规思路，如果我们要删除节点c，就要将c的上一个节点b指向c的下一个节点d，但我们只能访问节点c和d，由于单向链表的特性，节点b我们是无法访问的。那我们该如何“神不知鬼不觉”的删除节点c呢？ “偷天换日”：我们的目标是让b指向d，但我们无法直接操作b，而b又一直指向c，所以我们只需要把c替换为d，然后再把d删除即可。 删不掉我自己(c)，我就变成你(d)，再删掉你(d)，就等于删掉我自己(c)。 Java语言实现如下： 单链表节点类定义可查看文章：数据结构之链表-基础知识 123456public void deleteNode(SinglyLinkedListNode node) { SinglyLinkedListNode next = node.next; node.val = next.val; node.next = next.next; next = null;}","link":"/2020/12/27/algorithm/leetcode/tag/linkedlist/delete-middle-node-lcci/"},{"title":"LeetCode题解-链表标签：返回倒数第k个节点","text":"题目：实现一种算法，找出单向链表中倒数第k个节点。返回该节点的值。 Leetcode在线OJ系统：传送门 示例： graph LR A[1]-->B[2] B[2]-->C[3] C[3]-->D[4] D[4]-->E[5] 12输入：k = 2输出：4 说明：给定的 k 保证是有效的。 思路：双指针法。定义两个指针first和second，first指针先走k - 1步，然后second指针和first指针同时走，每次走一步，当first指针到达链表末尾时，second指针指向的节点即为倒数第k个节点。 Java语言实现如下： 单链表节点类定义可查看文章：数据结构之链表-基础知识 12345678910111213141516171819public static int kthToLast(SinglyLinkedListNode head, int k) { if (head == null || k &lt;= 0) { return 0; } SinglyLinkedListNode first = head; SinglyLinkedListNode second = head; while (k-- &gt; 1) { // 长度不足k if (first.next == null) { return 0; } first = first.next; } while (first.next != null) { first = first.next; second = second.next; } return second.val}","link":"/2020/12/23/algorithm/leetcode/tag/linkedlist/kth-node-from-end-of-list-lcci/"},{"title":"数据结构之链表-判断链表是否有环","text":"题目：判断给定的链表中是否有环。如果有环则返回true，否则返回false。你能给出空间复杂度O(1)的解法么？ Leetcode在线OJ系统：传送门 示例1： graph LR A[3]-->B[2] B[2]-->C[0] C[0]-->D[-4] D[-4]-->B[2] 12输出：true解释：链表中有一个环，由 -4 指向 2 示例2: graph LR A[1]-->B[2] B[2]-->A[1] 12输出：`true`解释：链表中有一个环，由 2 指向 1 示例3： graph LR A[1] 12输出：`false`解释：链表中没有环 思路：将链表想象成校园里的操场，两位同学从同一起点开始比赛跑步，出发后，如果两位同学的跑步速度不一致，那么跑过若干圈后，他们一定会在跑道的某处相遇，且跑的快的同学恰好比跑的慢的同学多跑一圈。这是物理运动学上的经典追击问题。 对于链表来说，我们可以定义一快一慢两个指针，让它们同时从头节点同时出发，快指针每次走两步，慢指针每次走一步，如果它们最终能在某处“相遇”，说明链表有环，如果快指针走到链表末尾都没有追上走的慢的指针，说明链表无环。 以上的思路俗称：“快慢指针法”；学名：Floyd判圈算法。 Floyd判圈算法（Floyd Cycle Detection Algorithm），又称龟兔赛跑算法(Tortoise and Hare Algorithm),是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，以及判断环的起点与长度的算法。 Java语言实现如下： 单链表节点类定义可查看文章：数据结构之链表-基础知识 123456789101112131415public static boolean hasCycle(SinglyLinkedListNode head) { if (head == null || head.next == null) { return false; } SinglyLinkedListNode fast = head; SinglyLinkedListNode slow = head; while (fast != null &amp;&amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) { return true; } } return false;}","link":"/2020/12/22/algorithm/base/datastructure/link-has-cycle/"},{"title":"动手实现Lombok","text":"Javac编译器提到编译器，可能很多后端研发工程师只是在脑海中有一个模糊的概念，我也是这样，因为业务开发中几乎使用不到。我们都工作在编译器的上层。 对于Java语言来说，它的整个编译期是不确定的过程，我们写的.java类文件需要被编译成.class字节码文件然后加载至虚拟机中，.class字节码文件需要被编译成机器码进行执行，当然也有直接将.java类文件编译成机器码的编译器。 Javac编译器是一个将.java文件编译成.class字节码的编译器，它可以在不改变底层虚拟机的情况下对程序编码进行编译期的优化，即：语法糖。 从sun公司提供的Javac编译器代码（源码在JDK的tool.jar包中）实现来看，编译的过程可分为以下三个阶段： Parse and Enter：解析与填充符号表，编译器会将Java文件解析成Abstract Syntax Tree（AST）抽象语法树，这个过程会校验语法的正确性等。 Annotation Processing：插入式注解处理器的注解处理，这个过程可以对语法树进行相关操作。 Analyse and Generate：分析语法树与字节码生成。 在JDK5后，Java语言引入了注解，这些注解与普通的Java类一样，是在运行期间发挥作用的。JDK6实现了JSR-269规范，提供出一组插入式注解处理器的标准API在编译期间对注解进行处理，我们可以把它看作是一组编译器的插件，或者称为钩子，我们可以使用这些API对第一阶段产生的语法树进行修改，一旦语法树被修改，编译器将会回到第一阶段重新解析与填充符号表，直到所有的插入式注解处理器都没有再对语法树进行修改为止，每一次回到第一阶段称为一次Round。 Javac编译器的源码是com.sun.tools.javac.main.JavaCompiler类，编译的方法是com.sun.tools.javac.main.JavaCompiler#compile，其中插入注解处理器的初始化过程是在this.initProcessAnnotations(var3);方法中完成的；执行过程是在com.sun.tools.javac.main.JavaCompiler#processAnnotations方法中完成的，该方法中判断是否还有新的注解处理器需要执行，如果有的话，通过com.sun.tools.javac.processing.JavacProcessingEnvironment#doProcessing方法得到一个新的JavaCompiler类对象继续后续的处理。 Lombok的原理Lombok正是利用Javac编译器的第二阶段进行实现的，使用的也正是JDK6提供的JSR-269实现。在编译期操作语法树，实现字节码的动态生成。 造轮子我们要实现的是一个简易的Lombok，一个注解在编译期同时生成getter和setter方法。 自定义注解首先要定义一个注解@GetterAndSetter： 1234567891011import java.lang.annotation.*;/** * @author sunchaser admin@lilu.org.cn * @since JDK8 2020/12/15 */@Target(ElementType.TYPE)@Retention(RetentionPolicy.SOURCE)@Documentedpublic @interface GetterAndSetter {} 自定义注解处理器然后定义一个处理@GetterAndSetter注解的处理器GetterAndSetterProcessor，所有的处理器都建议去继承javax.annotation.processing.AbstractProcessor抽象类，它提供了一些基本实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import com.google.auto.service.AutoService;import com.sun.source.util.Trees;import com.sun.tools.javac.processing.JavacProcessingEnvironment;import com.sun.tools.javac.tree.JCTree;import com.sun.tools.javac.tree.TreeMaker;import com.sun.tools.javac.util.Context;import com.sun.tools.javac.util.Names;import org.sunchaser.lombok.impl.annotation.GetterAndSetter;import javax.annotation.processing.*;import javax.lang.model.SourceVersion;import javax.lang.model.element.Element;import javax.lang.model.element.TypeElement;import javax.tools.Diagnostic;import java.util.Set;/** * 自定义@GetterAndSetter注解的插入处理器 * @author sunchaser admin@lilu.org.cn * @since JDK8 2020/12/15 */@SupportedAnnotationTypes({&quot;org.sunchaser.lombok.impl.annotation.GetterAndSetter&quot;})@SupportedSourceVersion(SourceVersion.RELEASE_8)@AutoService(Processor.class)public class GetterAndSetterProcessor extends AbstractProcessor { /** * 可将Element转换成JCTree，组成AST语法树。使用Trees.instance(processingEnv);进行初始化。 */ private Trees trees; /** * 构造JCTree的工具类。使用TreeMaker.instance(((JavacProcessingEnvironment) processingEnv).getContext());初始化。 */ private TreeMaker treeMaker; /** * 名字处理工具类。使用Names.instance(context);进行初始化。 */ private Names names; /** * 编译期的日志打印工具类。使用processingEnv.getMessager();进行初始化 */ private Messager messager; /** * init 初始化 * @param processingEnv 环境：提供一些Javac的执行工具 */ @Override public synchronized void init(ProcessingEnvironment processingEnv) { super.init(processingEnv); this.messager = processingEnv.getMessager(); this.trees = Trees.instance(processingEnv); Context context = ((JavacProcessingEnvironment) processingEnv).getContext(); this.treeMaker = TreeMaker.instance(context); this.names = Names.instance(context); } /** * 具体的执行 * @param annotations 注解集合 * @param roundEnv 执行round环境 * @return 执行结果 */ @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) { messager.printMessage(Diagnostic.Kind.NOTE,&quot;roundEnv ---&gt;&quot; + roundEnv); if (!roundEnv.processingOver()) { // 所有@GetterAndSetter注解标注的类 Set&lt;? extends Element&gt; annotated = roundEnv.getElementsAnnotatedWith(GetterAndSetter.class); annotated.forEach(element -&gt; { // 获得当前遍历类的语法树 JCTree tree = (JCTree) trees.getTree(element); // 使用GetterAndSetterTreeTranslator处理 tree.accept(new GetterAndSetterTreeTranslator(treeMaker, names, messager)); }); } // 返回true：Javac编译器会从编译期的第二阶段回到第一阶段 return true; } /** * 获取当前处理器支持的注解类型集合 * * JDK7后可用注解@SupportedAnnotationTypes代替该方法 * * @return 注解类全限定类名字符串的集合 */ @Override public Set&lt;String&gt; getSupportedAnnotationTypes() { return super.getSupportedAnnotationTypes(); } /** * 获取支持的JDK版本 * * JDK7后可用注解@SupportedSourceVersion代替该方法 * * @return JDK版本 */ @Override public SourceVersion getSupportedSourceVersion() { return SourceVersion.latestSupported(); }} 注解处理器的实现细节主要方法我们来看下子类中实现的主要方法： init(ProcessingEnvironment processingEnv)初始化方法，在父抽象类中对入参ProcessingEnvironment对象进行了初始化，我们可以通过这个对象得到很多工具类，例如Trees、TreeMaker和Names等等。 process父类中的抽象方法，子类进行具体的处理实现。输入参数RoundEnvironment代表每一次Round的环境。 getSupportedAnnotationTypes指定当前处理器是用来处理哪个注解的，返回值是需要处理的注解的全限定类名字符串的集合。在JDK7后，父抽象类基于@SupportedAnnotationTypes注解进行了实现，子类中可不重写该方法，直接使用注解：@SupportedAnnotationTypes({&quot;org.sunchaser.lombok.impl.annotation.GetterAndSetter&quot;})即可。 getSupportedSourceVersion指定支持的JDK版本，这里通常返回SourceVersion.latestSupported()最新版本。在JDK7后，父抽象类基于@SupportedSourceVersion注解进行了实现，子类中可不重新进行实现，直接使用注解：@SupportedSourceVersion(SourceVersion.RELEASE_8)即可。 工具类介绍下面介绍一下init方法中初始化的一些工具类： javax.annotation.processing.Messager编译期的日志打印工具类。使用processingEnv.getMessager();进行初始化。 javax.lang.model.element.Element对一个.java文件结构的建模。一个Java类被划分为各个Element，每个部分都有对应的子类实现。 例如： 123456789101112package com.sunchaser; /** PackageElement **/public class Foo { /** TypeElement **/ private String str; /** VariableElement **/ private Foo foo; /** VariableElement **/ public Foo() {} /** ExecuteableElement **/ public void setStr( String str /** TypeElement **/ ) { this.str = str; /** ExecuteableElement **/ }} com.sun.source.util.Trees可将Element转换成JCTree，组成AST语法树。使用Trees.instance(processingEnv);进行初始化。 com.sun.tools.javac.tree.TreeMaker构造JCTree的工具类。使用TreeMaker.instance(((JavacProcessingEnvironment) processingEnv).getContext());进行初始化。 com.sun.tools.javac.util.Names名字处理工具类。使用Names.instance(context);进行初始化。无论是类、方法、变量或者参数的名称都需要此类来创建，常用形式为names.fromString(&quot;setNameXXX&quot;)。 com.sun.tools.javac.util.List1234567891011121314151617181920212223242526272829303132333435363738394041public class List&lt;A&gt; extends AbstractCollection&lt;A&gt; implements java.util.List&lt;A&gt; { public A head; public List&lt;A&gt; tail; /** nil()方法返回的空集合 **/ private static final List&lt;?&gt; EMPTY_LIST = new List&lt;Object&gt;((Object)null, (List)null) { public List&lt;Object&gt; setTail(List&lt;Object&gt; var1) { throw new UnsupportedOperationException(); } public boolean isEmpty() { return true; } }; /** * 返回空集合 */ public static &lt;A&gt; List&lt;A&gt; nil() { return EMPTY_LIST; } /** 以下是一系列重载的of方法，用来创建List **/ public static &lt;A&gt; List&lt;A&gt; of(A var0) { return new List(var0, nil()); } public static &lt;A&gt; List&lt;A&gt; of(A var0, A var1) { return new List(var0, of(var1)); } public static &lt;A&gt; List&lt;A&gt; of(A var0, A var1, A var2) { return new List(var0, of(var1, var2)); } public static &lt;A&gt; List&lt;A&gt; of(A var0, A var1, A var2, A... var3) { return new List(var0, new List(var1, new List(var2, from(var3)))); } ....} 在这套抽象语法树的实现中，所有的List都使用的是com.sun.tools.javac.util.List，而不是java.util.ArrayList。这是一个链式List，尾节点为集合。常用的方法有List.nil()和List.of()。 JCTree介绍JCTree是语法树元素的基类，包含一个重要的字段pos，该字段用来指明当前语法树节点JCTree在语法树中的位置。com.sun.tools.javac.tree.JCTree是一个抽象类，且子类的构造函数都是protected的，所以不能直接使用new关键字创建语法树元素节点，而是使用访问者设计模式进行创建。 下面介绍几个重要的子类： com.sun.tools.javac.tree.JCTree.JCStatement：声明语法树节点，仍然是一个抽象类，下面是常用子类： com.sun.tools.javac.tree.JCTree.JCBlock：语句块语法树节点。 com.sun.tools.javac.tree.JCTree.JCReturn：return语句语法树节点。 com.sun.tools.javac.tree.JCTree.JCClassDecl：类定义语法树节点。 com.sun.tools.javac.tree.JCTree.JCVariableDecl：字段/变量定义语法树节点。 com.sun.tools.javac.tree.JCTree.JCMethodDecl：方法定义语法树节点。 com.sun.tools.javac.tree.JCTree.JCModifiers：访问标志语法树节点。 com.sun.tools.javac.tree.JCTree.JCExpression：表达式语法树节点，仍然是一个抽象类，下面是常用子类： com.sun.tools.javac.tree.JCTree.JCAssign：赋值语句语法树节点。 com.sun.tools.javac.tree.JCTree.JCIdent：标志符语法树节点，可以是变量、类型和关键字等等。 TreeMaker介绍TreeMaker用于创建一系列的语法树节点，上面说到创建JCTree语法树节点不能直接使用new关键字创建，所以才有了TreeMaker工具类，它会在创建时为JCTree对象设置pos字段，必须使用上下文相关的TreeMaker对象来创建语法树节点。 下面介绍几个常用方法： TreeMaker.Modifiers用于创建访问标志的语法树节点JCModifiers，主要方法如下： 123456789101112131415public JCModifiers Modifiers(long flags) { return this.Modifiers(flags, List.nil());}/** * 用于创建访问标志的语法树节点 * @param flags 访问标志 * @param annotations 注解列表 */public JCModifiers Modifiers(long flags, List&lt;JCAnnotation&gt; annotations) { JCModifiers tree = new JCModifiers(flags, annotations); boolean noFlags = (flags &amp; 8796093033983L) == 0L; tree.pos = noFlags &amp;&amp; annotations.isEmpty() ? -1 : this.pos; return tree;} 其中flags可以使用枚举类com.sun.tools.javac.code.Flags，例如treeMaker.Modifiers(Flags.PUBLIC + Flags.STATIC + Flags.FINAL)创建的语法树节点为：public static final。 TreeMaker.ClassDef用于创建类定义的语法树节点JCClassDecl，主要方法如下： 12345678910111213141516171819/** * 用于创建类定义的语法树节点 * @param modifiers 访问标识，可通过treeMaker.Modifiers创建 * @param name 类名 * @param typeParameter 泛型参数列表 * @param extending 父类 * @param implementing 实现的接口集合 * @param defs 类定义的详细语句，包括字段、方法的定义等等 */public JCClassDecl ClassDef(JCModifiers modifiers, Name name, List&lt;JCTypeParameter&gt; typeParameter, JCExpression extending, List&lt;JCExpression&gt; implementing, List&lt;JCTree&gt; defs) { JCClassDecl tree = new JCClassDecl(modifiers, name, typeParameter, extending, implementing, defs, (ClassSymbol)null); tree.pos = this.pos; return tree;} TreeMaker.VarDef用于创建字段/变量定义的语法树节点JCVariableDecl，主要方法如下： 123456789101112131415/** * 用于创建字段/变量定义的语法树节点 * @param modifiers 访问标志，可通过treeMaker.Modifiers创建 * @param name 字段/变量名称 * @param varType 字段/变量类型 * @param init 字段/变量初始化语句 */public JCVariableDecl VarDef(JCModifiers modifiers, Name name, JCExpression varType, JCExpression init) { JCVariableDecl tree = new JCVariableDecl(modifiers, name, varType, init, (VarSymbol)null); tree.pos = this.pos; return tree;} TreeMaker.Ident用于创建标识符的语法树节点JCIdent，主要方法如下： 123456789/** * 用于创建标识符的语法树节点 * @param name 标识符名称 */public JCIdent Ident(Name name) { JCIdent tree = new JCIdent(name, (Symbol)null); tree.pos = this.pos; return tree;} TreeMaker.Return用于创建return语句的语法树节点JCReturn，主要方法如下： 12345678/** * 用于创建`return`语句的语法树节点 */public JCReturn Return(JCExpression ex) { JCReturn tree = new JCReturn(ex); tree.pos = this.pos; return tree;} TreeMaker.Apply用于创建方法调用的语法树节点JCMethodInvocation，主要方法如下： 1234567891011/** * 用于创建方法调用的语法树节点 * @param argsTypes 参数类型列表 * @param fn 方法调用语句 * @param args 方法参数列表 */public JCMethodInvocation Apply(List&lt;JCExpression&gt; argsTypes, JCExpression fn, List&lt;JCExpression&gt; args) { JCMethodInvocation tree = new JCMethodInvocation(argsTypes, fn, args); tree.pos = this.pos; return tree;} TreeMaker.Select用于创建域访问/方法访问的语法树节点JCFieldAccess，主要方法如下： 12345678910/** * 用于创建域访问/方法访问的语法树节点 * @param selected . 运算符左边的表达式 * @param selector . 运算符右边的表达式 */public JCFieldAccess Select(JCExpression selected, Name selector) { JCFieldAccess tree = new JCFieldAccess(selected, selector, (Symbol)null); tree.pos = this.pos; return tree;} TreeMaker.Assign用于创建赋值语句的语法树节点JCAssign，主要方法如下： 12345678910/** * 用于创建赋值语句的语法树节点 * @param leftEx 赋值语句左边的表达式 * @param rightEx 赋值语句右边的表达式 */public JCAssign Assign(JCExpression leftEx, JCExpression rightEx) { JCAssign tree = new JCAssign(leftEx, rightEx); tree.pos = this.pos; return tree;} TreeMaker.Exec用于创建可执行语句的语法树节点JCExpressionStatement，主要方法如下： 12345678/** * 用于创建可执行语句的语法树节点 */public JCExpressionStatement Exec(JCExpression ex) { JCExpressionStatement tree = new JCExpressionStatement(ex); tree.pos = this.pos; return tree;} TreeMaker.Apply和TreeMaker.Assign需要在外面包一层TreeMaker.Exec来获取一个可执行语句JCExpressionStatement。 TreeMaker.Block用于创建组合语句的语法树节点JCExpressionStatement，主要方法如下： 12345678910/** * 用于创建组合语句的语法树节点 * @param flags 访问标志 * @param statements 语句列表 */public JCBlock Block(long flags, List&lt;JCStatement&gt; statements) { JCBlock tree = new JCBlock(flags, statements); tree.pos = this.pos; return tree;} TreeMaker.MethodDef用于创建方法定义的语法树节点JCMethodDecl，主要方法如下： 1234567891011121314151617181920212223242526272829303132333435/** * 用于创建方法定义的语法树节点 * @param modifiers 访问标志，可通过treeMaker.Modifiers创建 * @param name 方法名 * @param returnType 返回类型 * @param typeParameters 泛型参数列表 * @param params 参数列表 * @param throwns 异常声明列表 * @param methodBody 方法体 * @param defaultValue 默认方法 */public JCMethodDecl MethodDef(JCModifiers modifiers, Name name, JCExpression returnType, List&lt;JCTypeParameter&gt; typeParameters, List&lt;JCVariableDecl&gt; params, List&lt;JCExpression&gt; throwns, JCBlock methodBody, JCExpression defaultValue) { return this.MethodDef(modifiers, name, returnType, typeParameters, (JCVariableDecl)null, params, throwns, methodBody, defaultValue);}public JCMethodDecl MethodDef(JCModifiers modifiers, Name name, JCExpression returnType, List&lt;JCTypeParameter&gt; typeParameters, JCVariableDecl variable, List&lt;JCVariableDecl&gt; params, List&lt;JCExpression&gt; throwns, JCBlock methodBody, JCExpression defaultValue) { JCMethodDecl tree = new JCMethodDecl(modifiers, name, returnType, typeParameters, variable, params, throwns, methodBody, defaultValue, (MethodSymbol)null); tree.pos = this.pos; return tree;} process执行下面详细介绍process方法中的具体处理逻辑： 首先要知道process方法如果返回了true，那么Javac编译器会从编译期的第二阶段回到第一阶段：即重新回到解析与填充符号表阶段。 处理逻辑：如果!roundEnv.processingOver()还未process完成，则找到所有@GetterAndSetter注解标注的类，依次遍历获得每个类的语法树，然后交给自定义的org.sunchaser.lombok.impl.process.GetterAndSetterTreeTranslator类进行处理，全部处理完成后返回true以便回到编译的第一阶段。 下面是GetterAndSetterTreeTranslator类中具体操作语法树插入getter和setter方法的逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128import static com.sun.tools.javac.tree.JCTree.*;/** * AST树访问处理器 * @author sunchaserlilu@didiglobal.com * @since JDK8 2020/12/17 */public class GetterAndSetterTreeTranslator extends TreeTranslator { /** * 构造JCTree的工具类 */ private final TreeMaker treeMaker; /** * 名字处理工具类 */ private final Names names; /** * 编译期的日志打印工具类 */ private final Messager messager; public GetterAndSetterTreeTranslator(TreeMaker treeMaker, Names names, Messager messager) { this.treeMaker = treeMaker; this.names = names; this.messager = messager; } /** * 访问到类定义时的处理 * @param jcClassDecl 类定义的抽象语法树节点 */ @Override public void visitClassDef(JCClassDecl jcClassDecl) { super.visitClassDef(jcClassDecl); jcClassDecl.defs.forEach(def -&gt; { if (def.getKind().equals(Kind.VARIABLE)) { messager.printMessage(Diagnostic.Kind.NOTE,def + &quot;----processed&quot;); // 插入getter方法 jcClassDecl.defs = jcClassDecl.defs.prepend(createGetterMethod((JCVariableDecl) def)); // 插入setter方法 jcClassDecl.defs = jcClassDecl.defs.prepend(createSetterMethod((JCVariableDecl) def)); } }); } /** * 创建getter方法的语法树节点 * @param def 变量节点 * @return getter方法的语法树节点 */ private JCTree createGetterMethod(JCVariableDecl def) { return treeMaker.MethodDef( // 访问修饰符 treeMaker.Modifiers(Flags.PUBLIC), // 方法名 names.fromString(&quot;get&quot; + this.toFirstUpperCase(def.getName().toString())), // 方法返回类型 (JCExpression) def.getType(), // 泛型参数 List.nil(), // 方法参数列表 List.nil(), // throw表达式 List.nil(), // 方法体 treeMaker.Block(0L,List.of( treeMaker.Return( treeMaker.Select( treeMaker.Ident(names.fromString(&quot;this&quot;)), names.fromString(def.getName().toString()) ) ) )), null ); } /** * 创建setter方法的语法树节点 * @param def 变量节点 * @return setter方法的语法树节点 */ private JCTree createSetterMethod(JCVariableDecl def) { // 构造方法入参 JCVariableDecl param = treeMaker.VarDef(treeMaker.Modifiers(Flags.PARAMETER), def.getName(), def.vartype, null); // 构造 this.def = def JCFieldAccess thisX = treeMaker.Select(treeMaker.Ident(names.fromString(&quot;this&quot;)), def.getName()); JCAssign assign = treeMaker.Assign(thisX, treeMaker.Ident(def.getName())); // 构造方法体 JCBlock methodBody = treeMaker.Block(0L, List.of(treeMaker.Exec(assign))); // 构造方法返回类型 JCExpression returnType = treeMaker.Type(new Type.JCVoidType()); // 构造setter方法 return treeMaker.MethodDef( // 访问修饰符 treeMaker.Modifiers(Flags.PUBLIC), // 方法名 names.fromString(&quot;set&quot; + this.toFirstUpperCase(def.getName().toString())), // 方法返回类型 returnType, // 泛型参数 List.nil(), // 方法参数列表 List.of(param), // throw表达式 List.nil(), // 方法体 methodBody, // 默认值 null ); } /** * 工具方法：将字符串首位转为大写 * @param str 源字符串 * @return 首位大写的字符串 */ private String toFirstUpperCase(String str) { char[] charArray = str.toCharArray(); charArray[0] -= 32; return String.valueOf(charArray); }} 至此，一个简易Lombok的功能就实现了，但是还无法正常使用，我们需要把我们的插入注解处理器类GetterAndSetterProcessor使用SPI的形式提供给外部使用。 SPI实现实现方式一： 手动在resources目录下创建META-INF/services目录，然后在services目录下创建javax.annotation.processing.Processor文件，文件内容为插入注解处理器类GetterAndSetterProcessor的全限定类名。 实现方式二： 使用google提供的auto-service框架，该框架也是基于插入注解处理器实现的。其maven坐标为： 12345&lt;dependency&gt; &lt;groupId&gt;com.google.auto.service&lt;/groupId&gt; &lt;artifactId&gt;auto-service&lt;/artifactId&gt; &lt;version&gt;1.0-rc7&lt;/version&gt;&lt;/dependency&gt; 然后在我们自定义的插入注解处理器类GetterAndSetterProcessor上打上auto-service框架提供的@AutoService(Processor.class)注解，在编译后即自动生成target/classes/META-INF/services/javax.annotation.processing.Processor文件。 测试我们无法在插入注解处理器类GetterAndSetterProcessor所在的maven模块进行测试，因为该处理器是使用SPI对外提供服务的，所以我们需要新建一个maven子模块，然后引入插入注解处理器GetterAndSetterProcessor类所在的maven模块的坐标，然后才可以使用我们自定义的注解，简单测试一下： 1234567891011121314import org.sunchaser.lombok.impl.annotation.GetterAndSetter;/** * 注意此类跟GetterAndSetterProcessor不在同一个maven模块中 * @author sunchaser admin@lilu.org.cn * @since JDK8 2020/12/18 */@GetterAndSetterpublic class ChainSetterTest { private String name; public static void main(String[] args) { }} 运行main方法即可。 可看到Build Output中有如下输出： 123java: roundEnv ---&gt;[errorRaised=false, rootElements=[com.sunchaser.lomboktest.ChainSetterTest], processingOver=false]java: private String name----processedjava: roundEnv ---&gt;[errorRaised=false, rootElements=[], processingOver=true] 打开target/classes/com/sunchaser/lomboktest/ChainSetterTest.class字节码文件，可看到已生成字段name的getName和setName方法。 123456789101112131415161718192021222324//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//package com.sunchaser.lomboktest;public class ChainSetterTest { private String name; public void setName(String name) { this.name = name; } public String getName() { return this.name; } public ChainSetterTest() { } public static void main(String[] args) { }} 总结至此，我们就基本实现了一个简易的Lombok。 但是我留下了一个疑问，setter方法如何生成链式的，貌似我没有找到对应的API，Lombok是通过另一个注解@Accessors(chain = true)来实现链式setter方法的，为什么它不直接在@Setter注解中设置一个属性用来控制生成的setter方法是否为链式的？看Lombok的源码并未看懂这部分的实现，网上也没有找到对应资料，如果有同行研究过这个问题可留言进行交流，十分感谢！","link":"/2020/12/19/javaee/lombok/impl-simple-lombok/"},{"title":"一个冷门Lombok注解与Spring的结合","text":"序说到Lombok，大部分人可能都停留在@Data注解可以同时生成getter/setter、toString、equals和hashCode等方法；@NoArgsConstructor/@AllArgsConstructor可以生成无参和全参构造器。确实Lombok的设计初衷也是为了生成代码。 有些人因为需要安装插件而拒绝了Lombok，觉得这样会要求团队内所有成员都安装插件。诚然，这是一个还说得过去的理由。但是这并不足以让我们拒绝Lombok。Lombok所做的事情是在改变Java，有些人觉得它改变了Java语法是破坏了Java，那有没有想过，也许Java一直以来的设计就是不好的存在呢？业务系统中出现的无数getter/setter方法，动辄几百行的实体类，阅读体验真的好吗？Lombok是在改变Java，我们只不过是在拥抱变化。Spring Boot已经把Lombok加入预定义依赖中了；Apache ShardingSphere的开发规范中明确要求优先使用Lombok代替构造器、getter/setter方法和log变量；就连Java14也借鉴了Lombok思想提出了record语法。我们为什么还要去拒绝Lombok呢？ 所以，从今天起，开始拥抱Lombok吧！ 一个冷门注解：@RequiredArgsConstructor很多人都知道@RequiredArgsConstructor这个注解，但是却从未使用过。如果你也一样，那就得好好看看我这篇文章了，看完之后也许你就会发现新的大陆！ Spring的依赖注入故事还得从Spring的依赖注入开始说起… 依赖注入的两大变体： 构造函数注入 setter方法注入 但是现在业务开发中却很少使用这两种依赖注入方式，而是使用@Autowired注解进行自动装配。不管是业务层Service还是仓储层MyBatis框架的Mapper或者其它等等，业务代码写起来大概是下面这个样子的： 1234567891011121314151617@Servicepublic class AutowiredService { @Autowired private IAService iaService; @Autowired private IBService ibService; @Autowired private ICService icService; @Autowired private AMapper aMapper; @Autowired private BMapper bMapper; ... // do business} 这样的@Autowired字段少则三五个，多则一二十个。而且在IDEA中，XXXService上面的@Autowired注解会有一条黄色的下划线：Field injection is not recommended ；对于XXXMapper类来说，变量名还会有一条红色的下划线：Could not autowire. No beans of 'XXXMapper' type found.，虽然运行起来不会报错，但这样的警告和报错着实让人看起来很不舒服。 有人说可以用@Resource注解来代替@Autowired，这样就不会出现警告和报错了。诚然，这样做可以解决问题，@Resource默认优先按beanName自动注入，@Autowired默认优先按beanType自动注入。这是解决问题的一种方式。 @Resource注解是JSR-250规范提供的注解，而@Autowired注解是Spring提供的。这点不足以称为暇疵。 Lombok的优雅如何使用Lombok来解决这个问题？ 我们关注一下构造函数注入的写法： 1234567891011121314151617@Servicepublic class ConstructorService { private final IAService iaService; private final IBService ibService; private final ICService icService; private final AMapper aMapper; private final BMapper bMapper; @Autowired public ConstructorService(IAService iaService, IBService ibService, ICService icService, AMapper aMapper, BMapper bMapper) { this.iaService = iaService; this.ibService = ibService; this.icService = icService; this.aMapper = aMapper; this.bMapper = bMapper; }} 它要求成员变量是final类型，同时构造函数上的@Autowired是可选的。 而@RequiredArgsConstructor刚好是为被声明为final的字段生成构造器的注解。 于是我们的写法就变得优（zhuang）雅（bi）起来： 1234567891011@Service@RequiredArgsConstructorpublic class LombokService { private final IAService iaService; private final IBService ibService; private final ICService icService; private final AMapper aMapper; private final BMapper bMapper; // do business} 这样编译后的字节码如下： 12345678910111213141516@Servicepublic class LombokService { private final IAService iaService; private final IBService ibService; private final ICService icService; private final AMapper aMapper; private final BMapper bMapper; public LombokService(IAService iaService, IBService ibService, ICService icService, AMapper aMapper, BMapper bMapper) { this.iaService = iaService; this.ibService = ibService; this.icService = icService; this.aMapper = aMapper; this.bMapper = bMapper; }} 这不就是标准的Spring构造函数注入方式吗？甚至我们还可以把@Autowired注解给加上： 1234567891011@Service@RequiredArgsConstructor(onConstructor = @_(@Autowired))public class LombokService { private final IAService iaService; private final IBService ibService; private final ICService icService; private final AMapper aMapper; private final BMapper bMapper; // do business} 这样编译后的构造函数上就会加上@Autowired注解。 onConstructor = @_(@Autowired)中间的@_还可以继续加下划线_： 1@RequiredArgsConstructor(onConstructor = @______________________________(@Autowired)) 即使你像上面这样写，代码也不会报错，能正常运行。 这样我们就只用写一个注解就可以完成任意多个属性的注入，Lombok就是这么优（zhuang）雅（bi）！所以请尽情地拥抱Lombok吧！","link":"/2020/12/14/javaee/lombok/lombok-combine-spring-di/"},{"title":"Lombok必知必会","text":"简介 ProjectLombok官网 介绍：Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java. Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more. 永远不要再写另一个getter或者equals方法，一个注解就可以让你的类有一个功能全面的生成器，自动化你的日志变量等等。 在业务开发中，我们不可避免的需要去定义数据库表的实体Entity类、中间数据传输对象DTO类、前端视图对象VO类等，这些类有一个共同的特点就是都会有很多很多的业务字段，承载着系统的业务数据。基于面向对象的封装性，类中的字段会被定义成private，然后提供出public的getter和setter方法暴露给外部操作。于是代码中就出现了一大片一大片的使用IDE生成的getter和setter方法。 Lombok要解决的问题就是去消除这些模版式的getter和setter方法。当然还有一些其它的模版式的代码也可以使用Lombok来消除。 基本使用引入依赖引入Maven依赖： 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 如果你是第一次使用Lombok，还需要在IDE上安装Lombok的插件。（插件的安装方式请自行谷歌） 如果是Spring Boot项目，Spring Boot 2.1.x版本的parent中默认已经预定义了Lombok的依赖，直接引入Maven坐标即可。 @Getter和@Setter这两个注解可以单独写在某些字段上，也可以写在类上。编译后会在字节码文件中加入相应字段的getter和setter方法。 单独写在类上的使用示例： 12345678910111213141516public class GetterAndSetterTest { @Getter private String getField; @Setter private String setField; @Getter @Setter(AccessLevel.PROTECTED) private String otherField; @Getter @Setter private final String fs = null;} @Getter注解会生成对应字段的getter方法，@Setter注解会生成对应字段的setter方法，可同时作用于同一个字段，还可以定义生成的方法的访问修饰符，例如@Setter(AccessLevel.PROTECTED)生成的setter方法就是protected级别的。 需要注意的是，如果字段被声明成final类型，@Setter注解不会为其生成对应的setter方法。 编译后的字节码如下： 12345678910111213141516171819202122232425262728public class GetterAndSetterTest { private String getField; private String setField; private String otherField; public GetterAndSetterTest() { } public String getGetField() { return this.getField; } public void setSetField(String setField) { this.setField = setField; } public String getOtherField() { return this.otherField; } protected void setOtherField(String otherField) { this.otherField = otherField; } public String getFs() { return this.fs; }} 如果不想细粒度的控制到每个字段，可以直接在类上添加@Getter和Setter注解，会为所有的字段生成getter和setter方法。 @ToString我们经常会去重写Object#toString()方法以便在控制台输出时打印的是类的基本信息而不是十六进制的地址值。 使用示例： 123456789101112131415161718@ToString(exclude = {&quot;id&quot;})public class ToStringTest { private Long id; private String address; private UserInfo userInfo; @ToString public static class BaseInfo { private String username; private String password; } @ToString(callSuper = true,includeFieldNames = false) public static class UserInfo extends BaseInfo { private Integer age; private Integer gender; }} @ToString注解会生成一个toString()方法，默认输出类名，所有字段的名称和值。可以使用注解的exclude属性来排除某些字段；还可以设置includeFieldNames = false屏蔽所有字段名称的输出；如果字段存在基类，可以设置callSuper = true来输出基类中的字段。 编译后生成的字节码如下： 123456789101112131415161718192021222324252627282930313233343536public class ToStringTest { private Long id; private String address; private ToStringTest.UserInfo userInfo; public ToStringTest() { } public String toString() { return &quot;ToStringTest(address=&quot; + this.address + &quot;, userInfo=&quot; + this.userInfo + &quot;)&quot;; } public static class UserInfo extends ToStringTest.BaseInfo { private Integer age; private Integer gender; public UserInfo() { } public String toString() { return &quot;ToStringTest.UserInfo(super=&quot; + super.toString() + &quot;, &quot; + this.age + &quot;, &quot; + this.gender + &quot;)&quot;; } } public static class BaseInfo { private String username; private String password; public BaseInfo() { } public String toString() { return &quot;ToStringTest.BaseInfo(username=&quot; + this.username + &quot;, password=&quot; + this.password + &quot;)&quot;; } }} @EqualsAndHashCode自定义类对象进行相等比较时一般需要重写equals()方法，同时最好也重写hashCode()方法。 使用示例： 1234567@EqualsAndHashCode(exclude = {&quot;ex&quot;})public class EqualsAndHashCodeTest { private String equal; private String hc; transient String tr; private String ex;} 默认情况下，会使用所有非静态non-static和非瞬态non-transient的字段来生成equals()和hashCode()方法。类似地，可以使用exclude属性来排除某些字段；如果存在基类，也可以使用callSuper = true来囊括基类中的字段。 编译后生成的字节码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class EqualsAndHashCodeTest { private String equal; private String hc; transient String tr; private String ex; public EqualsAndHashCodeTest() { } public boolean equals(Object o) { if (o == this) { return true; } else if (!(o instanceof EqualsAndHashCodeTest)) { return false; } else { EqualsAndHashCodeTest other = (EqualsAndHashCodeTest)o; if (!other.canEqual(this)) { return false; } else { Object this$equal = this.equal; Object other$equal = other.equal; if (this$equal == null) { if (other$equal != null) { return false; } } else if (!this$equal.equals(other$equal)) { return false; } Object this$hc = this.hc; Object other$hc = other.hc; if (this$hc == null) { if (other$hc != null) { return false; } } else if (!this$hc.equals(other$hc)) { return false; } return true; } } } protected boolean canEqual(Object other) { return other instanceof EqualsAndHashCodeTest; } public int hashCode() { int PRIME = true; int result = 1; Object $equal = this.equal; int result = result * 59 + ($equal == null ? 43 : $equal.hashCode()); Object $hc = this.hc; result = result * 59 + ($hc == null ? 43 : $hc.hashCode()); return result; }} 可以看到还加入了一个canEqual方法用来预先判断是否能和当前类对象进行equals比较。 @Data基本上每一个实体类都会使用到上面四个注解：@Getter、@Setter、@ToString和@EqualsAndHashCode，但是如果在每一个类上都重复的写上这四个注解，就又显得累赘了。于是Lombok提供了@Data注解，它等价于这四个注解的组合，会同时生成getter、setter、toString、equals、canEqual和hashCode这六个方法。同时还提供了一个属性staticConstructor，例如：staticConstructor=&quot;of&quot;，这样使用后，会将无参构造函数私有化，同时会提供一个静态成员方法of()用来创建当前类对象，在类外部无法使用new关键字来创建对象。 使用示例： 12345@Data(staticConstructor = &quot;of&quot;)public class DataTest { private String s; private String c;} 编译后生成的字节码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class DataTest { private String s; private String c; private DataTest() { } public static DataTest of() { return new DataTest(); } public String getS() { return this.s; } public String getC() { return this.c; } public void setS(String s) { this.s = s; } public void setC(String c) { this.c = c; } public boolean equals(Object o) { if (o == this) { return true; } else if (!(o instanceof DataTest)) { return false; } else { DataTest other = (DataTest)o; if (!other.canEqual(this)) { return false; } else { Object this$s = this.getS(); Object other$s = other.getS(); if (this$s == null) { if (other$s != null) { return false; } } else if (!this$s.equals(other$s)) { return false; } Object this$c = this.getC(); Object other$c = other.getC(); if (this$c == null) { if (other$c != null) { return false; } } else if (!this$c.equals(other$c)) { return false; } return true; } } } protected boolean canEqual(Object other) { return other instanceof DataTest; } public int hashCode() { int PRIME = true; int result = 1; Object $s = this.getS(); int result = result * 59 + ($s == null ? 43 : $s.hashCode()); Object $c = this.getC(); result = result * 59 + ($c == null ? 43 : $c.hashCode()); return result; } public String toString() { return &quot;DataTest(s=&quot; + this.getS() + &quot;, c=&quot; + this.getC() + &quot;)&quot;; }} @NoArgsConstructor、@AllArgsConstructor和RequiredArgsConstructor @NoArgsConstructor：无参构造器； @AllArgsConstructor：全参构造器； @RequiredArgsConstructor：部分参数构造器，针对被声明为final的字段生成构造器。 Java类的构造器机制是：如果类中未声明任何一个构造器，则编译器会在编译期自动加上一个无参构造器；如果声明了任意一个构造器，则不会自动加上无参构造器。 所以一般会将无参和全参构造器进行搭配使用： 12345@NoArgsConstructor@AllArgsConstructorpublic class ArgsConstructor { private String ac;} 编译后生成的字节码如下： 12345678910public class ArgsConstructor { private String ac; public ArgsConstructor() { } public ArgsConstructor(String ac) { this.ac = ac; }} 而@RequiredArgsConstructor注解跟前两个是互斥的，该注解是针对final字段来生成构造器，可与Spring的DI依赖注入搭配使用。 @Slf4j作为研发我们避免不了日志打印，但我们却要在每一个需要打印日志的类中定义这样一个静态日志常量：private static final Logger log = LoggerFactory.getLogger(XXXService.class);，其中XXXService的名称还都不相同，这太影响像我这样的CV工程师的效率了。Lombok提供了@Slf4j注解来解决这个问题。 使用前提：引入日志框架slf4j的Maven依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;&lt;/dependency&gt; 使用示例： 123@Slf4jpublic class LogTest {} 编译后生成的字节码如下： 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class LogTest { private static final Logger log = LoggerFactory.getLogger(LogTest.class); public LogTest() { }} 只用一个相同的注解@Slf4j就可以为每个类分别生成对应的日志常量log对象。CV工程师的效率又提高了！ 原理分析Lombok的使用很简单，只需添加对应注解，就可以在字节码中生成对应的代码。从源文件到字节码之间只经过了编译阶段，所以Lombok一定是在编译阶段对注解进行解析然后注入对应的字节码。 而编译阶段对注解的解析有两种机制： Annotation Processing Tool：简称apt apt随着JDK5引入注解时产生，在JDK7中被标记为过期，不推荐使用，JDK8已彻底将其删除。 从JDK6开始，可以使用Pluggable Annotation Processing API来替换它，apt被替换的主要原因是： api都在com.sun.mirror非标准包下； 没有集成到javac中，需要额外运行。 Pluggable Annotation Processing API 这其实是JSR 269规范，在JDK6中被引入作为apt的替代方案，它解决了apt的那两个问题，在javac执行过程中会调用实现了该规范的程序，这样我们就可以对javac编译器做一些增强。 JSR是Java Specification Requests的缩写，意思是Java规范提案。 Lombok就是一个实现了JSR 269规范的程序，在javac编译过程中会调用Lombok，从而实现代码的自动加入。 整个编译的过程大致如下： javac对源代码进行分析，生成一颗抽象语法树（AST）； 调用JSR 269的实现：Lombok； Lombok对抽象语法树进行解析，找到Lombok定义的注解所在的语法树，然后进行修改，添加getter和setter等方法定义的树节点； 使用修改后的语法树生成字节码class文件。 优缺点优点： 代码简洁优雅，通过注解的形式自动生成一些模版式的代码。 当类字段发生修改时，不用去修改对应的getter和setter等方法。 缺点： IDE中需要安装插件，否则项目报错。 不支持任意个参数的构造器重载。 总结关于Lombok，网上一部分人支持，一部分人反对。反对的理由还很多：强依赖插件；组内有一人用则所有人用；操作语法树等于改变Java语法等等。暂且认为这些都有道理，但有句话怎么说来着：拥抱变化！Java语言走过这么多年也经过了很多变化，每个大版本也或多或少会出现一些新语法。Lombok的出现也预示着Java需要发生变化，而不是局限于当下的安稳。所以，我认为Lombok是值得去拥抱的！ 从另一个角度说，那些反对Lombok的人可能是没写过业务系统，业务代码中经常出现一个类有二三十个字段，甚至更多，这时如果手动去维护各个类的getter和setter方法，效率可想而知，而且也没什么技术含量。打工人讲究的是如何高效打工！","link":"/2020/12/13/javaee/lombok/lombok-base/"},{"title":"数据结构之链表-基础知识","text":"定义链表：各个元素物理内存空间不连续，通过“指针”将一组零散的内存空间串联起来。指针的链接顺序为链表中元素的逻辑顺序。 基本特点链表由一组节点组成，每个节点包含两个部分：一个是存储元素的数据域，另一个是存储下一个节点地址的指针域。天然支持动态扩容。 链表分类 单链表：第一个节点称为头节点，最后一个节点称为尾节点。头节点用来记录链表的基地址，可以通过头节点遍历整个链表。尾节点的指针域指向null。 循环链表：特殊的单链表，与单链表唯一不同的是：尾节点的指针域指向了头节点。 双向链表：每个节点不仅存储数据域和指向下一个节点的指针域，它还会有一个指针域指向前一个节点。通常称为前驱节点和后继节点。 双向循环链表：综合了循环链表和双向链表。头节点的前驱节点指向尾节点，尾节点的后继节点指向头节点。 JDK的java.util.LinkedList就是一个双向链表。 单链表节点类定义我们来定义一个单链表的节点类SinglyLinkedListNode： 123456789101112131415161718192021222324252627282930package com.sunchaser.sparrow.algorithm.base.linkedlist;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;/** * 单向链表节点类 * @author sunchaser admin@lilu.org.cn * @since JDK8 2020/6/3 */@Data@NoArgsConstructor@AllArgsConstructorpublic class SinglyLinkedListNode { /** * 值域 */ public Integer val; /** * 指针域 */ public SinglyLinkedListNode next; public SinglyLinkedListNode(Integer val) { this.val = val; }} 构造单链表及其打印构造一个单链表，并按顺序打印在控制台。我们提供一个工具类LinkedListUtils来实现。 123456789101112131415161718192021222324252627282930313233343536373839404142package com.sunchaser.sparrow.algorithm.base.util;import com.sunchaser.sparrow.algorithm.base.linkedlist.SinglyLinkedListNode;/** * 链表工具类 * @author sunchaser admin@lilu.org.cn * @since JDK8 2020/12/11 */public class LinkedListUtils { private LinkedListUtils() { } /** * 构造一个单链表 * @return 单链表头节点 */ public static SinglyLinkedListNode generateSinglyLinkedList() { SinglyLinkedListNode node4 = new SinglyLinkedListNode(5,null); SinglyLinkedListNode node3 = new SinglyLinkedListNode(4,node4); SinglyLinkedListNode node2 = new SinglyLinkedListNode(3,node3); SinglyLinkedListNode node1 = new SinglyLinkedListNode(2,node2); return new SinglyLinkedListNode(1,node1); } /** * 按顺序打印单链表 * @param head 要打印的单链表头节点 */ public static void printLink(SinglyLinkedListNode head) { if (head == null) { System.out.print(&quot;&quot;); return; } if (head.next == null) { System.out.println(&quot;-&gt;&quot; + head.val + &quot;-&gt;null&quot;); return; } System.out.print(&quot;-&gt;&quot; + head.val); printLink(head.next); }} 插入和删除操作单链表的插入操作：例如：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null。 现在要将元素0插入到3和4之间。做法很简单，只需要先将0指向4，再将3指向0即可。注意先后顺序，要先将0指向4，后将3指向0。因为如果顺序对调，将3先指向0之后就找不到节点4了。 现在要将0从链表中删除。需要将节点0前面的节点3指向节点0后面的4，然后将节点0的指针域置为空。注意：将节点3指向节点4后，中间的节点0就会找不到了，所以需要用一个中间变量来保存节点0，待指向完成后再将节点0的指针域指向null。 123456789101112131415161718192021222324252627public static void main(String[] args) { // generate singly linked list SinglyLinkedListNode head = LinkedListUtils.generateSinglyLinkedList(); LinkedListUtils.printLink(head); // -&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null // 从3和4之间插入0 SinglyLinkedListNode c = new SinglyLinkedListNode(0); SinglyLinkedListNode cHead = head; while (cHead.next != null) { if (cHead.val == 3) { c.next = cHead.next; cHead.next = c; } cHead = cHead.next; } LinkedListUtils.printLink(head); // -&gt;1-&gt;2-&gt;3-&gt;0-&gt;4-&gt;5-&gt;null // 将0从3和4之间删除 SinglyLinkedListNode dHead = head; while (dHead.next != null) { if (dHead.val == 3) { SinglyLinkedListNode temp = dHead.next; dHead.next = dHead.next.next; temp.next = null; // help gc } dHead = dHead.next; } LinkedListUtils.printLink(head); // -&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null}","link":"/2020/12/12/algorithm/base/datastructure/data-structure-linkedlist-base/"},{"title":"数据结构之链表-奇数个元素的链表的中间节点","text":"题目：给定一个奇数个元素的链表，查找出这个链表中间位置的节点的数值。 示例：单链表：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null，中间位置的节点的数值为3。 思路：由于单链表特性，我们只能先遍历一次才能得到其长度，得到总长度之后我们就知道其中间位置是第几个，再次进行遍历即可得到。这种暴力解法时间复杂度是：O(n) + O(2/n)。 下面介绍一种时间复杂度更低的解法：快慢指针法。 定义一快一慢两个指针：fast和slow，两个指针同时走，快指针每次走两步，慢指针每次走一步，当快指针走到链表末尾的时候，慢指针就恰好在链表中间位置，即我们需要的中间节点。 我们来看快慢指针的Java语言实现： 单链表节点类定义可查看文章：数据结构之链表-基础知识 123456789public static SinglyLinkedListNode middleNode(SinglyLinkedListNode head) { SinglyLinkedListNode fast = head; SinglyLinkedListNode slow = head; while (fast.next != null) { fast = fast.next.next; slow = slow.next; } return slow;}","link":"/2020/12/12/algorithm/base/datastructure/middle-linknode/"},{"title":"数据结构之链表-使用非递归法实现单链表的反转","text":"题目：使用非递归法实现单链表的反转 示例：单链表：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null，反转之后的结果为：5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; null。 之前已经写过一篇文章使用递归法来实现，可查看：勇闯算法-递归法拿下反转链表的三杀 现在我们使用非递归法来进行实现。 思路：由于单链表的特性，我们只能从前往后依次遍历各个链表节点，对于示例中的单链表，如果我们直接将1和2进行反转，将2指向1，我们会发现2后面的节点已经无法访问到了。所以我们需要提前将2后面的3记录下来，然后再将2指向1，类似地，我们提前将3后面的4记录下来，再将3指向2…直至到最后一个节点，整个过程结束。 定义三个指针变量：pre、current、next。 初始状态：pre = null,current = 1,next = null。 反转过程： 12next = current.next;current.next = pre; 指针右移： 12pre = current;current = next; 终止条件：current.next == null。 Java语言完整实现： 单链表节点类定义可查看文章：数据结构之链表-基础知识 1234567891011121314151617181920public static SinglyLinkedListNode reverse(SinglyLinkedListNode head) { if (head == null || head.next == null) { return head; } // 定义三个指针：pre、current、next SinglyLinkedListNode pre = null; SinglyLinkedListNode current = head; SinglyLinkedListNode next = null; while (current.next != null) { // 记录current的next next = current.next; // current反转 current.next = pre; // pre右移 pre = current; // current右移 current = next; } return current;}","link":"/2020/12/12/algorithm/base/datastructure/non-recursive-reverse-link/"},{"title":"Apache Maven必知必会","text":"前言在没有使用Maven之前，我们开发一个JavaWeb项目，如果使用到非JDK提供的类库，需要去网上下载对应的jar包，然后将jar包复制粘贴放到项目的lib目录下才能够使用。这样的做法是很麻烦的，每开发一个JavaWeb项目都需要去将jar包文件放置在lib目录下，且只能以文件的形式进行管理。 我们可以使用Maven的依赖管理功能来减少复制jar包这样重复的工作。 什么是Maven？Maven是一个项目管理工具，可以对项目（不仅限于Java语言）进行构建和依赖管理。简单来说：使用了Maven之后我们就不需要再去下载复制粘贴jar包了。 Maven安装Windows 10下Maven的安装及配置 Maven的约定配置Maven提供约定优于配置的原则，对于一个使用Maven构建和依赖管理的项目，应该遵循以下的目录结构： 目录 目录存放内容 ${basedir} Maven项目根路径，存放pom.xml和所有的子目录 ${basedir}/src/main/java 项目的java类文件 ${basedir}/src/main/resources 项目的资源文件，例如properties配置文件，前端静态资源文件等 ${basedir}/src/test/java 项目的单元测试类文件，一般为Junit的单元测试类 ${basedir}/src/test/resources 提供给测试类使用的资源文件 ${basedir}/src/main/webapp/WEB-INF JavaWeb项目的web应用文件目录，存放web.xml、.jsp和前端静态资源等文件。 ${basedir}/target 打包输出目录 ${basedir}/target/classes 编译输出目录，java类编译后的字节码文件目录 ${basedir}/target/test-classes 测试类编译输出目录 XXXTest.java Maven只会自动运行类名以Test结尾的测试类 ~/.m2/repository Maven的默认本地仓库路径 pom.xml常用标签下面是一个典型Spring Boot项目的pom.xml文件内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;!-- 声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值（继承）。 坐标包括group ID，artifact ID和version。--&gt; &lt;parent&gt; &lt;!-- 父项目的唯一组织名 --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;!-- 父项目的唯一构建标识符 --&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;!-- 父项目的版本号 --&gt; &lt;version&gt;2.4.0&lt;/version&gt; &lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;!-- 当前项目的唯一组织名 --&gt; &lt;groupId&gt;com.sunchaser.demo&lt;/groupId&gt; &lt;!-- 当前项目的唯一构建标识符 --&gt; &lt;artifactId&gt;springboot&lt;/artifactId&gt; &lt;!-- 当前项目的版本号，格式为:主版本.次版本.增量版本-限定版本号 --&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 当前项目的名称 --&gt; &lt;name&gt;springboot&lt;/name&gt; &lt;!-- 当前项目的描述简介 --&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;!-- 以值（value）代替名称（name），可在整个pom.xml中使用，格式：&lt;name&gt;value&lt;name/&gt; --&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;!-- 发现依赖和扩展的远程仓库列表。 --&gt; &lt;repositories&gt; &lt;!-- 包含需要连接到远程仓库的信息 --&gt; &lt;repository&gt; &lt;!-- 如何处理远程仓库里发布版本的下载 --&gt; &lt;releases&gt; &lt;!-- true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled /&gt; &lt;!-- 该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt; &lt;updatePolicy /&gt; &lt;!-- 当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;!--远程仓库名称 --&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!-- 该元素描述了项目相关的所有依赖。这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt; &lt;dependencies&gt; &lt;!-- 由于parent的存在，以下依赖继承了parent中申明的版本号 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;!-- 可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;!-- 依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 构建项目需要的信息 --&gt; &lt;build&gt; &lt;!-- 使用的插件列表 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 以上是将Spring Boot作为parent的pom.xml，这样的好处是parent可以聚合依赖的版本等一些信息，在后面添加依赖时只需要填写groupId和artifactId坐标，版本号默认继承parent中定义的版本号。但很多时候我们的项目是Maven多模块项目，或者由于一些其它原因导致我们无法使用Spring Boot作为parent，这个时候就需要用到dependencyManagement标签来进行依赖预定义了，Spring Boot提供了BOM用来进行预定义依赖的引入，使用方式如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.sunchaser.demo&lt;/groupId&gt; &lt;artifactId&gt;springboot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;!-- 预定义依赖引入 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.4.0&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; Maven的生命周期Maven有三个标准的生命周期： clean：项目清理的处理。 default(build)：项目部署的处理。 site：项目站点文档创建的处理。 Clean生命周期包含以下阶段： pre-clean：执行一些需要在clean之前完成的工作。 clean：移除所有上一次构建生成的文件。 post-clean：执行一些需要在clean之后立即完成的工作。 我们所用的mvn clean命令就是上面的clean阶段。在一个生命周期中，运行某个阶段的时候，在它之前的所有阶段都会被运行。也就是说，如果执行maven clean命令将运行pre-clean和clean这两个生命周期阶段。 Default(build)生命周期包含以下23个阶段： validate校验：校验项目是否正确并且所有必要的信息可以完成项目的构建过程。 initialize初始化：初始化构建阶段，比如设置属性值。 generate-sources生成源代码：生成包含在编译阶段中的任何源代码。 process-sources处理源代码：处理源代码，比如过滤任意值。 generate-resources生成资源文件：生成将会包含在项目包中的资源文件。 process-resources处理资源文件：复制和处理资源到目标目录，为打包阶段做好准备。 compile编译：编译项目的源代码。 process-classes处理类文件：处理编译生成的文件，比如说对Java class文件做字节码改善优化。 generate-test-sources生成测试源代码：生成包含在编译阶段中的任何测试源代码。 process-test-sources处理测试源代码：处理测试源代码，比如说，过滤任意值。 generate-test-resources生成测试资源文件：为测试创建资源文件。 process-test-resources处理测试资源文件：复制和处理测试资源到目标目录。 test-compile编译测试源码：编译测试源代码到测试目标目录。 process-test-class处理测试类文件：处理测试源码编译生成的文件。 test测试：使用合适的单元测试框架运行测试（Junit是其中之一）。 prepare-package准备打包：在实际打包之前，执行任何的必要的操作为打包做准备。 package打包：将编译后的代码打包成可分发格式的文件，比如JAR、WAR或者EAR文件。 pre-integration-test集成测试前：在执行集成测试前进行必要的动作。比如说，搭建需要的环境。 integration-test集成测试：处理和部署项目到可以运行集成测试环境中。 post-integration-test集成测试后：在执行集成测试完成后进行必要的动作。比如说，清理集成测试环境。 verify验证：运行任意的检查来验证项目包有效且达到质量标准。 install安装：安装项目包到本地仓库，这样项目包可以用作其他本地项目的依赖。 deploy部署：将最终的项目包发布到远程仓库中与其他开发者和项目共享。 我们常用的mvn install命令，在执行install之前，按顺序执行了之前的21个阶段。如果用于多模块项目，每一个子项目都会执行mvn install命令。 还可以一次指定两个阶段，例如mvn clean deploy，这可以用来纯净的构建和部署项目到远程仓库中。Maven会先执行clean命令，再执行deploy命令，对多模块项目也适用。 Site生命周期Maven Site插件一般用来创建新的报告文档和部署站点等。这个在我们的开发工作中一般不会用到，了解即可。 包含以下4个阶段： pre-site：执行一些需要在生成站点文档之前完成的工作。 site：生成项目的站点文档。 post-site：执行一些需要在生成站点文档之后完成的工作，并且为部署做准备。 site-deploy：将生成的站点文档部署到特定的服务器上。 Maven仓库Maven仓库简单的理解就是存储JAR包的地方。有以下三种类型： 本地仓库（local） 中央仓库（central） 远程仓库（remote） 本地仓库（local）运行Maven项目时，任何依赖的构建或第三方JAR包都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构建至本地仓库，然后再使用本地仓库的构建。 默认的本地仓库路径为~/.m2/repository，要修改该默认位置，可在Maven的setting.xml文件中指定本地仓库路径： 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt; &lt;localRepository&gt;/Library/maven/repository&lt;/localRepository&gt;&lt;/settings&gt; 中央仓库（central）中央仓库是由Maven社区提供的仓库，需要通过网络进行访问。国内常用的是阿里云中央仓库。可在Maven的setting.xml文件中配置阿里云的中央仓库源： 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt; &lt;localRepository&gt;/Library/maven/repository&lt;/localRepository&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt;&lt;/settings&gt; Maven社区提供了一个网站：https://search.maven.org，可搜索到所有可以获取的构建库和JAR包。 远程仓库（remote）如果Maven在中央仓库也找不到依赖的构建，它会停止构建过程并输出错误信息到控制台。为了避免这种情况，Maven提供了远程仓库的概念，它是开发人员自己定制的仓库，包含了所需要的代码库或者其它工程中用到的JAR文件。 Maven依赖搜索顺序首先从本地仓库（local）中搜索，如果找不到，则去中央仓库（central）中搜索； 如果在中央仓库（central）中找不到，则查看是否设置了远程仓库（remote），如果没有设置，则停止搜索并抛出错误（无法找到依赖）。 如果在远程仓库（remote）中找不到，则停止搜索并抛出错误（无法找到依赖）；如果在远程仓库（remote）中找到了，则下载至本地仓库并引用。 Maven插件Maven的三个标准生命周期中都包含一系列的阶段，每一个阶段的具体实现都是由Maven的插件完成。 例如我们使用的mvn clean命令，clean对应着Clean生命周期中的clean阶段，clean的具体操作是由maven-clean-plugin完成的。 插件类型Maven提供了以下两种类型的插件： Build Plugins：在构建时执行，并在pom.xml的元素中配置。 Reporting Plugins：在网站生成过程中执行，并在pom.xml的元素中配置。 常用插件下面是一些常用的插件： clean：构建之后清理目标文件。删除目标目录。 compiler：编译Java源文件。 surefile：运行Junit单元测试。创建测试报告。 jar：从当前工程中构建jar文件。 war：从当前工程中构建war文件。 javadoc：为工程生成javadoc。 antrun：从构建过程的任意一个阶段中运行一个ant任务的集合。 引入外部依赖有些时候我们需要去对接一些第三方的SDK包，一般第三方会提供SDK的下载地址，但是很可能未发布至中央仓库，就导致无法通过Maven坐标直接引入。这个时候我们需要手动将SDK包下载并复制粘贴到项目中，可在${basedir}/src/main/resources目录下新建一个lib目录，专门用来存放未发布至中央仓库的JAR包。引入方式如下： 123456789101112131415&lt;dependencies&gt; &lt;!-- 在这里添加你的依赖 --&gt; &lt;dependency&gt; &lt;!-- 库名称，可以自定义 --&gt; &lt;groupId&gt;xxx-sdk-1.0&lt;/groupId&gt; &lt;!-- 库名称，可以自定义 --&gt; &lt;artifactId&gt;xxx&lt;/artifactId&gt; &lt;!-- 版本号 --&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;!-- 作用域 --&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;!-- resource目录下的lib文件夹下，文件名为：xxx-sdk.jar --&gt; &lt;systemPath&gt;${basedir}\\src\\main\\resources\\lib\\xxx-sdk.jar&lt;/systemPath&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 快照（SNAPSHOT）在Apache Dubbo微服务项目开发中，服务消费方需要去引入服务提供方对外暴露的API接口jar包。服务提供方很有可能在短期内多次修改对外暴露的接口，如果按照正常的版本号：producer-service.jar:1.0.0，那每修改一次接口都需要升级一个小版本，服务消费方不得不去更新pom.xml来引用最新的jar包。如果修改接口而不升级版本号就发布至仓库中，服务消费方在引用时不会去仓库下载相同版本号的最新jar包。也就是说，服务消费方只会下载一次指定版本号的jar包。为了避免这种繁琐的更新，Maven提供了快照版本。 快照版本是一种特殊的版本，指定了当前的开发进度的副本。不同于常规的版本，Maven每次构建都会在远程仓库中检查新的快照，服务提供方只需发布包含最新代码的快照版本（producer-service.jar:1.0.0-SNAPSHOT）至仓库中，服务消费方每次都会自动去获取包含最新代码的快照（producer-service.jar:1.0.0-SNAPSHOT）。 依赖管理Maven解析jar包的方式是依赖传递。例如我们引入spring-boot-starter-web，当Maven解析该依赖时，不仅仅会引入其内部依赖的spring-web、spring-webmvc和spring-boot-starter-tomcat等，还会引入这些内部依赖所依赖的jar包，例如spring-web依赖的spring-bean等，依赖关系不断向下传递，直至没有依赖，最终形成了一颗依赖树。 依赖冲突的问题举个栗子：假设有依赖A，它内部的依赖传递关系为：A-&gt;B-&gt;C-&gt;D-&gt;E1；有另一个依赖F，它内部的依赖传递关系为：F-&gt;G-&gt;E2。E1和E2为E的不同版本。 如果pom.xml同时引入A和F依赖，按照Maven依赖传递原则，实际引入的依赖将包括：A、B、C、D、E1、F、G和E2，因此E1和E2将会产生包冲突。 解决依赖冲突Maven解析pom.xml时，同一个groupId和artifactId的依赖只会保留一个，这样可以有效避免因引入不同版本的依赖所带来的问题。 Maven默认处理策略： 最短路径优先原则：因为从F到E2的路径比从A到E1的路径短，所以Maven在面对E1和E2时会选择E2。 最先声明优先原则：举个栗子：A-&gt;B-&gt;C1；D-&gt;E-&gt;C2。这两个依赖传递的路径长度是一样的，所以谁在pom.xml先被声明就引入谁。 排除依赖：默认处理策略已经能解决包的依赖问题，但还是会显示依赖冲突，现象就是IDEA中会报红；同时默认处理引入的依赖版本号可能不是我们所需要的，如果我们想引入指定版本号的依赖，可以使用&lt;exclusions /&gt;和&lt;exclusion&gt;标签先排除冲突的依赖，再另外单独在pom.xml中引入指定版本号的依赖。 检测包冲突的Maven命令如下： mvn dependency:help mvn dependency:analyze mvn dependency:tree mvn dependency:tree -Dverbose 最佳实践当开发多模块项目时，在最外层的父pom.xml中使用dependencyManagement标签进行依赖及版本号的预定义，便于统一管理项目依赖及版本号。在子模块引入依赖时，只需指定groupId和artifactId即可引入对应依赖。 参考 菜鸟教程 - Maven教程","link":"/2020/12/11/javaee/maven/maven-must-know-and-know/"},{"title":"LeetCode题解-第7题：整数反转","text":"题目：给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1:输入: 123输出: 321 示例 2:输入: -123输出: -321 示例 3:输入: 120输出: 21 注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-integer著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路： 首先我们考虑一个普通的正整数如何进行反转。 例如 1234。 最直接暴力的：字符串异常法。先将其转化为字符串，然后对字符串遍历，利用栈结构进行反转，反转之后的字符串类型强制转换成整数，抛出异常则溢出。这样可以处理1234这样的正整数。但是遇到负数就行不通了。 我们得考虑如何对负数进行反转，其实也很简单，只需要先判断输入数的正负性，然后记一个标记，同样的方式反转完成后，如果是负数，则拼接上负号-再进行强制类型转换，这样就可以解决了。 来看下这种“暴力字符串异常法”的代码实现： 123456789101112131415161718192021222324252627282930public static int convertStringToReverse(int x) { // 是否小于0 boolean flag = x &lt; 0; // 取绝对值转字符串 String s = String.valueOf(Math.abs(x)); // 转换成char数组进行遍历 char[] chars = s.toCharArray(); // 声明栈 Deque&lt;Character&gt; stack = new LinkedList&lt;&gt;(); // 入栈 for (char aChar : chars) { stack.push(aChar); } StringBuilder res = new StringBuilder(); if (flag) { // x值小于0，前面拼接上负号 res.append(&quot;-&quot;); } // 出栈 while (!stack.isEmpty()) { res.append(stack.pop()); } try { // 强制类型转换 return Integer.parseInt(res.toString()); } catch (Exception e) { // 异常表示溢出 return 0; }} 这种做法，入栈遍历的时间复杂度O(n)，栈结构的空间复杂度O(n)，出栈遍历的时间复杂度O(n)。整体的时间复杂度是O(n)，空间复杂度O(n)。 显然，这种解法并不是最优解。 不做类型转换，只操作整数进行反转。如何操作？其实可以套用生产者消费者的思想。 对于输入整数x： 生产者逻辑： 获取整数的个位数字：n = x % 10。 消费者逻辑： 整个过程开始之前，反转结果res的初始值等于0。 将生产者产出的个位数加到res后面：res = res * 10 + n。 将输入整数的个位数去除：x /= 10。 当消费到x = 0时，整个过程结束，最终的res即为反转结果。 看似完美，但题意中说到了整数溢出。反转之后的范围为：[-2^31,2^31 - 1]，我们需要去考虑溢出的边界。 反转结果res每次消费都会增大一个数量级，我们来看下限制的数值范围：[-2147483648,2147483647] 对于反转结果res： 首先分析正数区间，考虑倒数第二位，如果本次消费前res &gt; 214748364（即去掉正区间最大值的最后一位），无论此次消费到的个位数n为多少都溢出了；另一种情况，考虑最后一位，如果本次消费前res = 214748364，那本次消费时n值只要大于7，就溢出了。 再来看负数区间，同样考虑倒数第二位，如果本次消费前res &lt; -214748364成立，无论此次消费到的个位数n为多少都溢出了；另一种情况，考虑最后一位，如果本次消费前res = -214748364，那本次消费时n值只要小于-8，就溢出了。 代码实现如下： 1234567891011121314151617public static int reverse(int n) { // 反转结果初始值 int res = 0; while (n != 0) { // 生产：获取个位数 int x = n % 10; // 溢出边界 if ((res &gt; Integer.MAX_VALUE / 10 || (res == Integer.MAX_VALUE / 10 &amp;&amp; x &gt; Integer.MAX_VALUE % 10)) || (res &lt; Integer.MIN_VALUE / 10 || (res == Integer.MIN_VALUE / 10 &amp;&amp; x &lt; Integer.MIN_VALUE % 10))) { return 0; } // 消费：加到反转结果后面 res = res * 10 + x; n /= 10; } return res;}","link":"/2020/12/04/algorithm/leetcode/easy/7/"},{"title":"面试必问HashMap","text":"无论是小厂还是大厂面试，HashMap的出场率一直居高不下。作为Java语言中Map数据结构的经典实现，对其内部原理的掌握和理解程度在一定程度上能反映出一个开发人员的水平与实力。 下面我们提供出一些常见面试问法以及对应的官方回答（建议熟读并背诵）： HashMap底层是如何实现的？JDK7和JDK8的实现有何区别？ 答：HashMap底层存储元素的数据结构是数组。在存储元素时如果发生了哈希冲突，JDK7使用“链地址法”（俗称“拉链法”）来解决，采用“头插法”进行元素插入。在JDK8中，当哈希冲突不是很严重时，仍然使用“链地址法”解决，但采用的是“尾插法”；而当哈希冲突特别严重，即链表的长度大于8并且数组的容量大于64时，会将链表结构转化成红黑树结构用以解决链表过长带来的性能问题。 加载因子loadFactor为什么是0.75？ 答：这是一个基于容量和性能考虑的折衷值。如果加载因子设置过大，带来的好处是扩容的门槛提高，节约了内存空间，但出现哈希冲突的几率会变大，从而导致对元素的操作性能下降；如果加载因子设置过小，带来的好处是扩容门槛降低，数组中存储的元素会比较稀疏，不易出现哈希冲突，对元素的操作性能较高。但会存在一定的空间浪费。于是折衷考虑选择了0.75。 什么时机会触发扩容？JDK8在扩容时做了哪些优化？ 答：当存储元素数量大于等于阈值时触发扩容。JDK7在扩容时会对所有元素进行rehash重新哈希计算数组下标；而JDK8在扩容时通过高位运算（哈希码 &amp; 旧容量）来判断元素是否需要移动，如果高位运算结果高一位为0，那么扩容后该元素的位置不会发生变化，如果高位运算结果高一位为1，那么扩容后该元素的位置发生了变化，新的数组下标位置为原下标位置加上原数组长度。 描述插入一个元素的完整过程。 答：首先判断哈希表是否为空，如果为空则表示第一次插入，进行扩容；否则根据键计算出数组下标，然后判断该下标位置的元素是否为null，如果是，则直接插入；否则判断键是否相等（先比较hashCode，哈希码不相等再进行equals比较），如果相等，则直接覆盖值；否则判断是红黑树还是链表，分别执行对应数据结构的插入逻辑。其中链表数据结构在JDK7中使用头插法进行插入，在JDK8中使用尾插法。而红黑树在JDK8才引入，如果已经是红黑树了，则执行红黑树的插入逻辑，如果是链表，在使用尾插法遍历节点时如果发现链表长度大于8了且数组容量小于64时，将链表转换成红黑树后在执行插入，否则执行链表的尾部插入。元素插入完成后，判断哈希表容量是否超过阈值，超过则进行扩容。 HashMap的线程不安全体现在哪？如何去应对？ 答：在多线程条件下，JDK7的HashMap在扩容时会出现死循环的问题，JDK8的HashMap在插入时会出现值被覆盖的问题。应对这种线程不安全，可以使用同步容器HashTable或并发容器ConcurrentHashMap。推荐使用ConcurrentHashMap。 以上面试题及答案基本可以应对那些普通公司的一问一答式的面试了，背诵就完事了。 但有些面试官可能会追着其中某个点一直往下细问，这个时候光靠上面背诵的这点东西就有点力不从心了，你必须对整个HashMap的原理真正的有一定了解才能够从容去应对。 下面我们针对上面的面试题，阅读JDK8的HashMap源码，真正的去搞懂原理。 如何存储元素？1transient Node&lt;K,V&gt;[] table; 元素都存储在这个Node数组里面，我们来看下Node类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Basic hash bin node, used for most entries. (See below for * TreeNode subclass, and in LinkedHashMap for its Entry subclass.) */static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { // hash值 final int hash; // 键 final K key; // 值 V value; // 下一个节点 Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } // getter/setter/toString/equals/hashCode public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + &quot;=&quot; + value; } public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value); } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; } return false; }} 可以看到是一个单链表的数据结构，也就是说table数组中存储的是一个一个的Node节点，而这每一个Node节点都是一个单链表的头节点，当没有发生哈希冲突时，链表长度为1。 静态变量下面我们来看一些主要的静态变量： 1234567891011121314151617// 默认的初始容量-必须为2的整数幂static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16// 最大容量static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// 默认加载因子static final float DEFAULT_LOAD_FACTOR = 0.75f;// 从链表转化成红黑树的阀值static final int TREEIFY_THRESHOLD = 8;// 从红黑树退化成链表的阀值static final int UNTREEIFY_THRESHOLD = 6;// 要执行红黑树化的最小数组容量static final int MIN_TREEIFY_CAPACITY = 64; 有关加载因子loadFactor为什么是0.75？还记得文章开头的解答吗？这是一个基于容量和性能考虑的折衷值。如果加载因子设置过大，带来的好处是扩容的门槛提高，节约了内存空间，但出现哈希冲突的几率会变大，从而导致对元素的操作性能下降；如果加载因子设置过小，带来的好处是扩容门槛降低，数组中存储的元素会比较稀疏，不易出现哈希冲突，对元素的操作性能较高。但会存在一定的空间浪费。于是折衷考虑选择了0.75。 其实这个答案已经很能说明原因了，但有些面试官就是纠结这个数值为什么是0.75，为什么不是0.74或者0.76等。下面我们尝试用一种八股文来对抗面试官： 为什么加载因子是0.75呢？ 理论：通过预测存储桶是否为空，可以避免链接并利用分支预测。如果存储桶为空的可能性超过0.5，则该存储桶可能为空。 证明：s代表大小，n代表增加的键数。根据牛顿二项式定理，存储桶为空的概率为： P(0) = C(n, 0) * (1/s)^0 * (1 - 1/s)^(n - 0) 因此，如果少于log(2)/log(s/(s - 1))个键，当s达到无穷大时并且如果添加的键数使得P(0) = 0.5时，则n/s迅速接近log(2)。 log(2)约等于0.693。 结论：log(2)不是约等于0.693吗？为什么会选择0.75呢？因为阀值需要一个整数，默认初始容量是16，当加载因子等于0.75时乘积才为整数。0.70/0.71/0.72/0.73/0.74...等等，只有0.75的乘积才是整数。 以上理论及证明过程来自 stackoverflow.com 所以问题来了，为什么默认初始容量是16呢？这…，建议准备面下一家公司了… 成员变量除了存储元素的table数组，还有以下其它成员变量： 1234567891011121314// Set缓存，可用于迭代器transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;// map元素个数transient int size;// map修改次数，用来实现fail-fast机制transient int modCount;// 阀值，当size&gt;threshold时会触发扩容int threshold;// 加载因子final float loadFactor; 如何构造HashMap对象？一共有四个构造器，但我们常用的只有两个：无参构造器和指定初始容量的构造器。 1234567891011121314/** * 指定初始容量的构造器，内部调用带两个参数的构造器，传入默认加载因子DEFAULT_LOAD_FACTOR=0.75f */public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR);}/** * 无参构造器，使用默认的初始容量：16，默认的加载因子：0.75f */public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted} 一般在开发时，如果我们能提前预估出数据量，建议调用指定初始容量的构造器来创建一个合适容量的HashMap；如果无法预估，最好使用无参构造器。 我们来看下指定初始容量和指定加载因子的构造器： 1234567891011121314151617public HashMap(int initialCapacity, float loadFactor) { // 容量负值校验 if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); // 容量最大值校验 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 加载因子合法性校验 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); // 赋值 this.loadFactor = loadFactor; // 初始化阀值为初识容量（此处只是进行预初始化，后续调用resize方法时会进行准确赋值） this.threshold = tableSizeFor(initialCapacity);} 初始化赋值的时候，并不会将阀值threshold设置为initialCapacity * loadFactor，而是预初始化成初始容量，此处会调用tableSizeFor方法得到一个大于等于initialCapacity且最近的2的整数次幂的数，然后赋值给threshold，后续第一次调用put方法进行插入时会进行首次扩容，调用resize方法对threshold进行准确赋值。 tableSizeFor方法原理tableSizeFor方法是得到一个大于等于initialCapacity且最近的2的整数次幂的数。我们来看JDK8是如何进行巧妙实现的： 123456789static final int tableSizeFor(int cap) { int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;} 首先我们要知道位运算符号&gt;&gt;&gt;表示无符号右移，忽略符号位，空位都以0补齐。 假设cap = 10，那么n = 9。 执行n != n &gt;&gt;&gt; 1即n = 9 | (9 &gt;&gt;&gt; 1)的步骤是： 9的二进制是1001； 9 &gt;&gt;&gt; 1即：1001 &gt;&gt;&gt; 1 = 0100； 9 | (9 &gt;&gt;&gt; 1) = 1001 | 0100 = 1101。 接下来依次执行： 1234n |= n &gt;&gt;&gt; 2;n |= n &gt;&gt;&gt; 4;n |= n &gt;&gt;&gt; 8;n |= n &gt;&gt;&gt; 16; 过程分别为： n |= n &gt;&gt;&gt; 2;，此时n = 1101，即：n = 1101 | (1101 &gt;&gt;&gt; 2) = 1101 | 0011 = 1111； n |= n &gt;&gt;&gt; 4;，此时n = 1111，即：n = 1111 | (1111 &gt;&gt;&gt; 4) = 1111 | 0000 = 1111； n |= n &gt;&gt;&gt; 8;，此时n = 1111，即：n = 1111 | (1111 &gt;&gt;&gt; 8) = 1111 | 0000 = 1111； n |= n &gt;&gt;&gt; 16;，此时n = 1111，即：n = 1111 | (1111 &gt;&gt;&gt; 16) = 1111 | 0000 = 1111； 最后的结果为：n = 1111，转换成十进制等于15，return语句中进行三目判断，最后返回的值为：n + 1 = 16。 如何插入元素？下面我们来看put方法的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public V put(K key, V value) { // 计算hash值，调用putVal方法 return putVal(hash(key), key, value, false, true);}final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { // 局部变量tab用于接收成员变量table Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) // 如果table数组中无元素，则调用resize()扩容得到一个新的Node&lt;K,V&gt;[]数组并赋值给tab，然后得到新数组的长度为n。 n = (tab = resize()).length; // 根据hash值计算待插入元素的数组下标索引i（对2取模可转化成位运算） if ((p = tab[i = (n - 1) &amp; hash]) == null) // 如果i位置无元素，则直接创建Node节点进行赋值插入 tab[i] = newNode(hash, key, value, null); else { // i位置有元素，说明出现了哈希冲突 Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // 键key相等则直接进行值覆盖 e = p; // 待插入的键不等于下标i处存储的头节点的键 else if (p instanceof TreeNode) // 判断为红黑树节点，则执行红黑树的插入逻辑 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { // 否则为链表结构，进行遍历，binCount用来统计链表长度 for (int binCount = 0; ; ++binCount) { // 对e进行赋值 if ((e = p.next) == null) { // 遍历到尾节点了，e = null // 尾插法插入新元素 p.next = newNode(hash, key, value, null); // 判断链表长度binCount &gt;= 7 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st // 此次循环是第8次，binCount=7，尾插法插入新元素后链表长度为8，调用treeifyBin尝试转换成红黑树 // 在treeifyBin方法中，会首先判断tab数组的长度是否小于MIN_TREEIFY_CAPACITY=64，如果小于，则进行resize扩容结束；否则执行树化逻辑。 treeifyBin(tab, hash); break; } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // 找到了键key相等的节点，结束循环。e = p.next break; // 未找到key相等的节点或未遍历到尾部，此时e = p.next，推动链表的遍历。 p = e; } } // 上面的判断中e的值不为null的情况：即链表中找到了key相等的节点 if (e != null) { // existing mapping for key // 进行值value的覆盖 V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; // 回调钩子，子类LinkedHashMap进行了重写 afterNodeAccess(e); // 返回旧值 return oldValue; } } // 修改次数加一 ++modCount; if (++size &gt; threshold) // 容量达到阀值进行扩容 resize(); // 回调钩子 afterNodeInsertion(evict); return null;} 整个put方法的执行流程如下图所示： 如何优雅地进行扩容？出现扩容的情况有三种： 哈希表为空且第一次执行put方法时，会先进行扩容再存储元素。 当出现哈希冲突，执行尾插法插入元素后，如果链表长度大于8，且数组长度小于MIN_TREEIFY_CAPACITY=64，执行扩容逻辑。 新插入一个键后（元素直接插入、哈希冲突链表尾插、红黑树插入），++size &gt; threshold容量达到阀值，执行扩容逻辑。 下面我们来看下扩容resize的逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127final Node&lt;K,V&gt;[] resize() { // 使用oldTab接收旧的数组table Node&lt;K,V&gt;[] oldTab = table; // 如果oldTab为null引用，说明是第一次调用put方法时进行的扩容，则oldCap旧容量为0；否则为旧数组长度。 int oldCap = (oldTab == null) ? 0 : oldTab.length; // 旧阀值 int oldThr = threshold; // 定义新容量和新阀值（扩容之后的） int newCap, newThr = 0; if (oldCap &gt; 0) { // 旧容量大于0，则原数组有元素，不是第一次调用put if (oldCap &gt;= MAXIMUM_CAPACITY) { // 旧容量超过最大容量，已无法进行扩容 // 设置阀值为最大整型数值 threshold = Integer.MAX_VALUE; // 返回旧数组 return oldTab; } // 计算新容量：oldCap的两倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) // 新容量小于最大容量，且旧容量大于等于默认初始容量，则阀值也为原来的两倍 newThr = oldThr &lt;&lt; 1; // double threshold } // 旧阀值大于0，说明是调用带参构造器创建的HashMap，且此时旧阀值等于带参构造器中指定的初始容量 else if (oldThr &gt; 0) // initial capacity was placed in threshold // 第一次调用put才会走到这个if分支 // 新容量等于带参构造器中指定的容量 newCap = oldThr; else { // zero initial threshold signifies using defaults // 其它情况：调用无参构造器创建的HashMap // 新容量为：默认初始容量 newCap = DEFAULT_INITIAL_CAPACITY; // 新阀值为：默认加载因子 * 默认初始容量 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } // 第一次调用put时，走的上面的else if (oldThr &gt; 0)分支，新阀值未进行赋值，所以等于0 if (newThr == 0) { // 计算新阀值：新容量 * 加载因子 float ft = (float)newCap * loadFactor; // 范围控制，转换成int newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } // 设置阀值 threshold = newThr; // 开辟新容量长度的数组空间 @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; // table引用指向新数组 table = newTab; // 如果是第一次调用put时执行，oldTab为null。 if (oldTab != null) { // 非首次put方法，原table数组中存在元素，执行rehash for (int j = 0; j &lt; oldCap; ++j) { // 遍历旧table数组 Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) { // 释放旧table的引用 help gc oldTab[j] = null; // 无哈希冲突 if (e.next == null) // 新数组newTab赋值 // newCap为2的整数幂，hash &amp; 2^n - 1 即对2取模，求出数组下标。 newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) // 红黑树逻辑 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else { // preserve order // 哈希冲突，有链表，将整个链表分隔成两个部分 // loHead/loTail链接出一个不需要移动位置的链表 Node&lt;K,V&gt; loHead = null, loTail = null; // hiHead/hiTail链接出一个需要移动位置的链表 Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do { next = e.next; // 哈希码 &amp; 旧容量 // 结果为0，表示该元素的下标索引值在扩容后不会发生变化 if ((e.hash &amp; oldCap) == 0) { // 链接原链表每一个元素至loHead头节点 // 第一次执行do-while循环 if (loTail == null) // 赋值loHead头节点 loHead = e; else // 非第一次执行do-while // 链接至loTail loTail.next = e; // 如果是第一次执行do-while，则loTail=loHead指向头节点 // 否则表示loTail右移一位 loTail = e; } // 否则，结果不为0，则该元素的下标索引值在扩容后会改变 else { // 同样地链接逻辑 // 第一次执行do-while循环 if (hiTail == null) // 赋值hiHead头节点 hiHead = e; else // 非第一次执行do-while // 链接至hiTail hiTail.next = e; // 如果是第一次执行do-while，则hiTail=hiHead指向头节点 // 否则表示hiTail右移一位 hiTail = e; } } while ((e = next) != null); // 执行完do-while循环后，loTail和hiTail都指向出现哈希冲突的原链表的尾部 if (loTail != null) { loTail.next = null; // 下标索引不需要移动，链表loHead整体移动 newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; // 下标索引需要移动到j + oldCap位置，链表hiHead整体移动 newTab[j + oldCap] = hiHead; } } } } } // 返回扩容后的新table数组 return newTab;} 可以看到在有哈希冲突时，对链表中的元素并没有进行rehash操作，而是将冲突的链表分隔为两个链表，通过计算e.hash &amp; oldCap，如果结果的高一位为0，则表示该链表节点不需要移动位置，链接至loHead节点；如果结果的高一位为1，则表示该链表节点需要移动位置，链接至hiHead节点。do-while循环结束后，以loHead节点为头节点的链表不需要移动数组下标；而以hiHead节点为头节点的链表需要向右移动旧容量oldCap个位置。原链表各节点之间的相对位置未发生改变。 如何获取元素？相比于put插入，get获取元素的逻辑就相对简单了。正常从HashMap中获取元素的最好时间复杂度是常数O(1)。在哈希冲突的情况下：最坏时间复杂度是O(n)，最好时间复杂度是O(log n)。 下面我们来看下get方法的逻辑： 1234567891011121314151617181920212223242526272829303132public V get(Object key) { Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;}final Node&lt;K,V&gt; getNode(int hash, Object key) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; // table数组已经初始化，且数组中有元素，且key所在下标索引位置有元素 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) // 第一个key相等，直接返回该节点 return first; // key在后面的链表（红黑树）节点中 if ((e = first.next) != null) { if (first instanceof TreeNode) // 执行红黑树的查询逻辑，时间复杂度O(log n) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // 遍历链表找到相等的key，返回对应节点。 return e; } while ((e = e.next) != null); } } return null;} 由于在put插入的时候计算下标的方式为(n - 1) &amp; hash，所以get查询的时候以同样方式计算下标，如果该下标位置无元素，那么待查询的key一定不在HashMap中，直接返回null；反之，如果该下标位置有元素，那么则寻找与待查询的key相等的键。 如何判断key相等？ 在HashMap中，所有判断key是否相等的逻辑都是：先比较hashCode是否相等，再比较equals是否相等。 这就是为什么建议在重写equals方法的同时最好去重写hashCode方法的一个原因。 两个key如果hashCode相等，equals不一定不等。 线程不安全问题是如何产生的？对于JDK7，在多线程进行扩容时会产生死循环问题，由于JDK7已成为历史，本文不再赘述，可以参考网上的一些解释。 而对于JDK8，我们可以看看上文中分析的put插入方法，针对第二个if条件分支，如果未发生哈希冲突，则创建新节点直接进行赋值插入。 12if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); 以上代码在JDK8#HashMap.java源码中分别是第630行和第631行。 此处如果多个线程同时对同一个HashMap执行put方法，根据hash计算出的下标i相同且i下标处恰好为null没有元素，同时多个线程恰好刚执行完第630行的if条件判断但还未执行第631行的赋值插入。这个时候，如果多个线程按先后顺序往下执行，那么后执行的线程就会覆盖先执行的线程在i下标处插入的值。 当然在日常的业务开发中，基本上不会使用到HashMap作为成员变量，更多的是用作局部变量进行传参，而且现在已经不推荐使用HashMap进行传参了，除了一些早期项目，或者使用了MyBatis的早期版本ibatis的项目，基本上很少会用到HashMap。 总结有关HashMap，其实到这里就已经足够了，再往下深入，就是红黑树的查询和插入逻辑了，涉及到红黑树的数据结构和算法，比较复杂。面试如果遇到问红黑树的实现细节的，大可以去反问面试官会不会。 后面有空会专门写一篇文章讲讲红黑树。","link":"/2020/11/17/javase/base/hashmap/"},{"title":"垃圾收集算法","text":"现代虚拟机的垃圾收集器大多基于分代收集理论，基于该理论，堆内存被划分出各种不同的区域，不同的区域有着不同的垃圾收集算法。 分代收集理论分代收集理论建立在两个分代假说之上： 弱分代假说：绝大多数对象都是朝生夕灭的。 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。 这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将堆内存划分出不同的区域，然后将回收对象依据其年龄（一次垃圾回收，如果对象未被回收，则其年龄加一）分配到不同的区域进行存储。 显然，应该将大多数朝生夕死的对象集中在一起，在垃圾回收时只需关注如何保留少量存活的对象，而不是去标记那些大量将被回收的对象；将那些难以消亡的对象也集中在一起，减少对它们回收的频率。这样就有效的在时间和空间开销上做了权衡。 在堆内存划分出不同的区域之后，垃圾收集器才可以每次只回收其中某个区域的内存——因而才有了Minor GC、Major GC和Full GC回收类型的区分；针对不同区域也采用了适当的垃圾收集算法。 一切看似美好，但区域划分后会存在一个明显的问题：对象都不是孤立存在的，很可能存在跨代引用。 现代虚拟机一般都会将堆内存划分出新生代（Young Generation）和老年代（Old Generation）两个基本区域，对于新生代的回收称为Minor GC，但新生代的对象完全有可能被老年代所引用，同样，老年代的对象也完全有可能被新生代所引用，为了找出对应区域中的存活对象，不得不在固定的GC Roots之外，额外遍历老年代或新生代来确保可达性分析的正确性。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会对内存回收带来很大的性能负担。于是有了第三个分代假说： 跨代引用假说：跨代引用相对于同代引用来说仅占极少数。 这个假说可以认为是前两个分代假说的推论：存在互相引用关系的两个对象，倾向于同时生存或同时死亡的。如果某个新生代对象存在跨代引用，由于老年代对象是难以消亡的，该引用会使新生代对象在被回收时存活下来，随后慢慢晋升至老年代，这时跨代引用就不存在了。 依据这条假说，我们就不应该再为了少量的跨代引用去扫描整个老年代，也不必浪费空间去记录每一个对象是否存在以及存在哪些跨代引用，只需在新生代上建立一个全局的称为记忆集（Reference Set）的数据结构，这个结构把老年代划分为若干小块，此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。虽然这种方法需要在对象改变引用关系时维护记录数据的正确性，增加了一定的运行时开销，但跟在收集时扫描整个老年代相比是划算的。 GC分类 新生代收集（Minor GC/Young GC）：对新生代收集。 老年代收集（Major GC/Old GC）：对老年代收集。目前只有CMS收集器会有单独收集老年代的行为。 混合收集（Mixed GC）：对整个新生代以及部分老年代收集。目前只有G1收集器会有这种行为。 整堆收集（Full GC）：对整个堆内存和方法区收集。 垃圾收集算法 标记-清除算法 该算法分为“标记”和“清除”两个阶段：首先使用可达性分析算法标记出所有需要回收的对象，标记完成后统一回收掉所有被标记的对象；也可以反过来，标记所有存活对象，统一回收未被标记的对象。 缺点：执行效率不稳定，如果堆中存在大量对象需要进行回收，则需要进行大量标记和清除的动作，执行效率随对象数量增长而降低；第二个是内存空间的碎片化问题，标记清除后会产生大量不连续的内存碎片。内存碎片太多会导致当需要分配大对象时无法找到连续的内存空间而不得不提前触发再一次的垃圾回收。 标记-复制算法 为了解决标记-清除算法在面对大量可回收对象时执行效率低的问题，有“大佬”提出了一种称为“半区复制”的垃圾收集算法：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存用完的时候才将其存活着的对象复制到另外一块内存上，然后再把已使用过的内存一次性清除。如果第一半内存中多数对象是存活的，那这种算法将会产生大量的内存间复制的开销，但对于多数对象是可回收状态时，算法就只需复制少量的存活对象，而且每次都是针对一半内存进行回收，内存碎片问题几乎不会出现。这种算法实现容易，执行效率也非常高，但其代价是可用内存缩小为了原来的一半。空间利用率太低。 现代虚拟机大多采用了该算法去回收新生代，有研究表明：新生代中朝生夕死的对象有98%都熬不过第一轮垃圾收集。因此并不需要将新生代划分为大小相等的两块，更好的做法是将新生代划分为一块较大的Eden区域和两块较小的Survivor空间，每次内存分配时只使用Eden区域和其中一块Survivor区域。当发生垃圾回收时，将Eden区和Survivor区存活的对象一次性复制到另一块Survivor区域上，然后直接回收掉Eden区和那块使用过的Survivor区。HotSpot虚拟机默认Eden和Survivor区域的大小比例是8 : 1，也就是说新生代中可用的内存空间为整个新生代的90%，这样空间利用率就达到了90%，虽然还有10%的另一块Survivor区域被浪费，但已经比较理想了。当然，任何人都不能保证研究在实际情况中的正确性，无法保证每次对新生代的回收都只有不多于10%的对象存活，于是存在一个兜底的安全设计：当另一块Survivor区域空间不足以容纳一次Young GC之后存活的对象时，就需要其它内存区域（大多指老年代）进行内存分配担保，将多余的存活对象直接复制到老年代。 标记整理 标记-复制算法在对象存活率较高时就会产生大量的内存间复制开销，优化过后的算法也需要浪费10%的空间，且需要其它空间进行内存分配担保。对于老年代来说，大部分对象都是难以消亡的，所以该算法并不适用于老年代。 针对老年代对象难以消亡的特征，有人提出了另一种有针对性的“标记-整理”算法，标记过程仍然采用的是可达性分析算法，但标记完成后并不是立刻进行回收，而是让所有存活对象都向内存空间一端移动，然后去清理边界以外的内存。 标记整理算法和标记清除算法的本质差异在于是否移动存活的对象，标记清除算法是不移动的，而标记整理算法是移动的。 是否移动存活对象是一个优缺点并存的风险决策。如果移动对象，尤其是在老年代这种每次回收都有大量对象存活的区域，移动存活对象并更新所有引用是一个极为负重的操作，而且这种移动对象操作必须全程暂停用户线程才能执行，这个暂停被称为Stop The World。如果不移动对象，那必然会造成内存碎片问题，而要解决内存碎片问题，就需要依赖更为复杂的内存分配器和内存访问器来解决，无疑加重了内存访问的负担，使程序的吞吐量降低。所以，无论是否移动对象都存在弊端，移动则出现Stop The World；不移动则可以忽略Stop The World的时间，但会产生内存碎片问题，且程序吞吐量降低。 参考 《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》 - 周志明","link":"/2020/07/23/javase/jvm/gc-algorithm/"},{"title":"垃圾收集器","text":"如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的实践者。根据分代收集理论，HotSpot虚拟机提供了多种作用于不同分代的垃圾收集器，它们是不同时代的思想汇聚。 Serial新生代收集器最基础且历史最悠久的收集器，曾是HotSpot虚拟机新生代区域的唯一选择。它选用的是标记-复制算法，单线程收集，当它开始工作时，其它工作线程必须挂起，直到它回收内存完毕。Stop The World无法避免。但好处是单线程工作，对于核数较少的处理器来说，没有线程的上下文切换开销，收集效率高，适用于客户端模式的虚拟机。 Serial Old老年代收集器与Serial新生代收集器配合使用，回收老年代，同样使用单线程收集，选用的是标记-整理算法，适用于客户端模式的虚拟机。 ParNew新生代收集器ParNew新生代收集器实质是Serial收集器的多线程并行版本，在多核处理器的虚拟机上效率会大幅提高。选用的同样是标记-复制算法。它的特点是：除了Serial收集器外，目前只有它能与CMS收集器配合工作。大部分服务端模式的虚拟机选用该收集器回收新生代。 CMS老年代收集器CMS (Concurrent Mark Sweep：并发标记-清除)收集器是一种以获取最短回收停顿时间（Stop The World）为目标的收集器。它的回收过程分为四个阶段： 初始标记（CMS initial mark） 并发标记（CMS concurrent mark） 重新标记（CMS remark） 并发清除（CMS concurrent sweep） 初始标记：标记GC Roots能直接关联到的对象，速度很快，但存在Stop The World停顿。 并发标记：从GC Roots的直接关联对象开始遍历整个对象图，耗时较长，但遍历线程与用户线程可并发执行。无Stop The World停顿。 重新标记：修正并发标记阶段，用户线程并发执行时导致标记产生变动的那一部分对象的标记记录（增量更新），存在Stop The World停顿，且一般比初始标记阶段停顿时间长。 并发清除：清理删除掉标记阶段判断为不可达的对象，清理线程可与用户线程并发执行。 由于存在并发标记和并发清除阶段，用户线程在并发执行期间完全有可能产生新的垃圾对象，但这部分对象出现在标记过程结束之后，本次回收无法进行处理，只能等到下一次老年代内存回收时才能被清理掉，这部分垃圾被称为“浮动垃圾”。 在用户线程和收集器线程并发执行期间，是可能会有对象需要进入老年代的，这时就需要老年代预留一定的内存空间。在Java5的虚拟机中，默认设置是老年代内存使用了68%后就会触发CMS收集器回收老年代。这是一个比较保守的值，可以使用参数-XX: CMSInitiatingOccu-pancyFraction来调整这个默认值。到了Java6时，默认设置提高到了92%，但这又会存在一个问题，如果CMS收集器在并发期间，预留的内存无法满足用户线程的需要，就会出现一次“并发失败”，这时，虚拟机采用降级保护方案，挂起用户线程（Stop The World），临时启用Serial Old老年代收集器重新进行老年代的回收。总的来说，-XX: CMSInitiatingOccu-pancyFraction这个参数设置的太高会容易出现“并发失败”问题，性能不增反降；太低又会导致内存利用率不高，且回收频率会上升。所以，用于生产环境时应谨慎调整。 标记-清除算法不可避免的问题就是内存碎片问题，当老年代内存碎片过多时，没有连续空间来容纳大对象，即使还有很多内存没有使用，还是会触发Full GC。CMS收集器提供了一个-XX: +UseCMS-CompactAtFullCollection开关参数（默认开启，Java9废弃）用于在CMS收集器不得不进行Full GC时开启内存碎片的整理过程，此过程需要移动对象，无法进行并发，出现Stop The World停顿。同时CMS收集器还提供了-XX: CMSFullGCsBefore-Compaction参数（默认值为0：每次Full GC都进行碎片整理）要求收集器在执行过指定次数不整理碎片的Full GC后，下一次进入Full GC前先进行碎片整理。 Parallel Scavenge新生代收集器吞吐量优先收集器。采用标记-复制算法。提供开关参数-XX: +UseAdaptiveSizePolicy让虚拟机根据当前系统的运行情况收集性能监控信息，动态调整新生代大小、Eden和Survivor区域比例等参数以提供最合适的停顿时间或最大吞吐量。 Parallel Old老年代收集器吞吐量优先收集器。采用标记-整理算法，多线程并发收集。与Parallel Scavenge新生代收集器搭配使用。 参考 《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》 - 周志明","link":"/2020/07/23/javase/jvm/gcer/"},{"title":"回收前的自救","text":"即使在可达性分析算法中被判定为不可达的对象，也不是“非死不可”的，还有一种自救的方法。 要宣告一个对象已死，至少要经历两次标记过程：在被可达性分析算法判定为不可达后会被标记一次；随后会对不可达对象进行筛选，筛选条件是该对象是否有必要执行finalize()方法，如果对象没有重写finalize()方法，或者finalize()在上一次垃圾回收时被调用过，则该对象没有必要执行finalize()方法，会被第二次标记。对象即被判定为了“死亡”。 如果对象被判定为有必要执行finalize()方法，虚拟机会将该对象放置在一个名为F-Queue的队列之中，并在稍后由一个由虚拟机自动创建的、低调度优先级的Finalizer线程去执行它们的finalize()方法。这里的执行是虚拟机会触发该方法的开始执行，但不会等待它们执行结束。原因是该方法的方法体是经过重写的，无法保证立刻执行结束（等待或死循环的情况），很可能造成F-Queue队列中的其它对象永远处于等待状态，导致整个垃圾回收系统崩溃。 finalize()方法是对象逃离死亡的最后一次机会，触发执行后，垃圾收集器将对F-Queue队列中的对象进行第二次小规模标记，如果对象要在finalize()方法中拯救自己——只需重新与引用链上的任何一个对象建立关联即可，例如将自身（this）赋值给某个类变量或者某个对象的成员变量，那在下一次垃圾回收时该对象将被移出“即将回收”的集合；如果该对象此时还未逃脱，那基本可以说它已经“死了”。 对象自救代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940public class FinalizeEscapeGc { public static FinalizeEscapeGc SAVE_HOOK = null; public void isAlive() { System.out.println(&quot;alive&quot;); } @Override protected void finalize() throws Throwable { super.finalize(); System.out.println(&quot;finalize&quot;); // 将this赋值给当前类的静态变量进行自救 FinalizeEscapeGc.SAVE_HOOK = this; } public static void main(String[] args) throws InterruptedException { SAVE_HOOK = new FinalizeEscapeGc(); // 第一次会进行自救 SAVE_HOOK = null; System.gc(); // Finalizer线程优先级较低，暂停0.5秒以等待它 Thread.sleep(500); if (SAVE_HOOK != null) { SAVE_HOOK.isAlive(); } else { System.out.println(&quot;dead&quot;); } // 第二次被判定为“死亡” SAVE_HOOK = null; System.gc(); // Finalizer线程优先级较低，暂停0.5秒以等待它 Thread.sleep(500); if (SAVE_HOOK != null) { SAVE_HOOK.isAlive(); } else { System.out.println(&quot;dead&quot;); } }} 输出结果： 123finalizealivedead 可看到finalize()方法被执行了，且第一次“自救成功”，第二次则彻底“死亡”。 参考 《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》 - 周志明","link":"/2020/07/20/javase/jvm/finalize-before-gc/"},{"title":"对象是“生”是“死”","text":"简介垃圾收集器对堆内存进行回收时，首先要判断堆中的对象是否还存活。 对象是“生存”还是“死亡”？这是一个问题。经典的判断算法是引用计数法，但存在一定缺陷。现代虚拟机是通过可达性分析算法判断对象是否存活。 引用计数算法引用计数法是一个很好理解的算法。在对象中添加一个引用计数器，每当有一个引用指向该对象时，就将计数器值加一；当引用失效时，计数器值减一。任何时刻计数器值为零的对象可认为是“死亡”的。 一切都看似很正常，但实际上存在循环引用的问题。请看以下代码： 1234567891011121314151617public class ReferenceCountingGc { public Object instance; private byte[] bigSize = new byte[2 * 1024 * 1024]; public static void testGc() { ReferenceCountingGc objA = new ReferenceCountingGc(); ReferenceCountingGc objB = new ReferenceCountingGc(); objA.instance = objB; objB.instance = objA; objA = null; objB = null; System.gc(); } public static void main(String[] args) { testGc(); }} 分析：testGc()方法被调用时，JVM同步创建一个栈帧压入当前执行线程的虚拟机栈中，随后，虚拟机栈中存在两个引用objA和objB分别指向堆内的两个new ReferenceCountingGc()对象，然后，堆内两个对象的成员变量instance互相指向对方，再然后，将虚拟机栈内的引用指向null，最后触发gc。此时，堆内的这两个对象互相引用着对方，引用计数器的值不为零，但它们已经无法再由程序进行访问了，所以如果采用引用计数算法进行垃圾回收，这两个对象将无法被回收，即会出现内存泄露问题。 可达性分析算法现代标准虚拟机都是采用可达性分析算法判断对象是否存活。基本思路是通过一系列称为GC Roots的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，则称该对象是不可达的，即需要被回收。 在Java技术体系里，固定可作为GC Roots的对象包括以下几种： 在虚拟机栈（栈帧中的局部变量表）中引用的对象，例如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。 在方法区中类静态属性引用的对象，即一个Java类的引用类型静态变量。 在方法区中常量引用的对象，例如字符串常量池中的引用。 在本地方法栈中本地Native方法引用的对象。 虚拟机内部的引用，例如基本数据类型对应的Class对象；一些常驻的异常类对象，例如NullPointException和OutOfMemoryError等，另外还有系统类加载器类对象。 所有被同步锁（synchronized）持有的对象。 反应虚拟机内部情况的JMXBean、JVMTI中注册的回调和本地代码缓存等。 以上是固定作为GC Roots节点集的对象，但虚拟机还会根据所选垃圾收集器和当前进行垃圾回收的内存区域，可以将一些其它对象“临时性”地加入节点集，共同组成完整的GC Roots集合，确保可达性分析的正确性。 参考 《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》 - 周志明","link":"/2020/07/20/javase/jvm/object-is-alive-or-dead/"},{"title":"Java虚拟机是如何运行字节码的","text":"为什么Java程序要在虚拟机上运行？Java程序的运行离不开Java运行时环境，又称为JRE，它是Java程序的最小可运行环境，包含Java虚拟机和Java的核心类库。我们每天都在接触的JDK实际上就包含了JRE，同时在/bin目录下还有一些其它的小工具等。 它们的范围大小比较关系是：JDK &gt; JRE &gt; JVM。 对于虚拟机来说，它所能运行的是以.class结尾的字节码文件，我们平时写的.java源文件都需要经过编译器编译成字节码。 通俗一点说，虚拟机只认字节码，不管你是不是Java语言，只要你能编译成字节码就能在我的虚拟机上运行，例如Scala语言，它可以被编译成字节码运行在Java虚拟机上，且可以调用Java的所有类库。 字节码的意义在于什么呢？在于只要有了字节码，就可以在不同平台的虚拟机实现上运行，即：“一次编译，到处运行”。 虚拟机的另一个特点是它能够进行自动内存管理和垃圾回收，不像C++语言那样需要开发者手动进行内存的分配与回收，这一点有利也有弊，“利”是方便了开发者，无需过多关注内存，将精力放在程序的业务逻辑上；“弊”是可能会由于开发者的小失误，导致内存溢出，从而使程序崩溃。于是内存管理和垃圾回收出现了一些可以调优的地方。 虚拟机是如何运行字节码的？从虚拟机视角看，执行Java代码首先需要将它被编译而成的.class字节码文件加载到Java虚拟机中，加载后的Java类会被存放至方法区中，实际运行时，虚拟机会执行方法区内的代码。 对于虚拟机来说，在实际运行时会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有些区域的生命周期和虚拟机进程一致，而有些区域的生命周期和用户线程保持一致。 运行时数据区域根据《Java虚拟机规范》的规定，运行时期虚拟机内部区域划分如下图所示： 这也是我们常说的JVM内存模型。下面我们对每个区域进行详细说明。 程序计数器 这是一块比较小的内存区域，简单的理解就是记录了当前线程正在运行的字节码的行数。对于单核CPU来说，实现多线程的方式是进行线程上下文切换，线程在运行过程中被挂起，当再次切换回来时需要回到之前运行的位置，程序计数器就是来记录该位置的一块内存区域，每个线程各自记录各自的，不会出现OutOfMemoryError错误，它是线程隔离的数据区。 虚拟机栈 虚拟机栈描述的是Java方法执行的线程内存模型，在运行过程中，每当调用一个Java方法，虚拟机会在当前线程的虚拟机栈中同步创建一个栈帧用来存储该方法的信息，包括局部变量表、操作数栈、动态连接和方法出口等信息。当退出当前调用的方法时，虚拟机栈会弹出该栈帧，无论是正常返回还是异常退出。也就是说，每一个Java方法的调用到结束都对应着一个栈帧在当前线程的虚拟机栈中入栈和出栈的过程。 局部变量表存放了编译期可知的Java基本数据类型、对象引用和returnAddress类型（指向方法return返回后将要执行的字节码指令的地址）。其中基本数据类型（boolean/byte/char/short/int/float/long/double）在局部变量表中以局部变量槽的形式表示，长度为64的double和long类型会占用两个变量槽，其余的都只会占用一个变量槽。当一个方法开始执行时，栈帧中的局部变量表内存大小就已经确定了，不会在运行期间动态改变。 如果线程请求的栈深度大于虚拟机栈所允许的深度（递归调用），将抛出StackOverflowError异常；如果线程申请栈空间时空间不足，则会抛出OutOfMemoryError异常。 本地方法栈 本地方法栈描述的是本地Native方法执行的线程模型，其作用与虚拟机栈一致。 堆 堆内存是虚拟机管理的内存中最大的一块，其生命周期和虚拟机进程保持一致。有一句话是这样说的：“new出来的对象都在堆上”。堆内存是垃圾收集器所管理的内存区域，现代垃圾收集器大部分是基于分代收集理论设计的，所以堆内存又被细分为“新生代”、“老年代”、“永久代”、“Eden区”、“From Survivor区”和“To Survivor区”。再次细划出这些区域的原因只是为了更好的的分配和回收内存。 堆内存是支持扩展的，可通过参数-Xmx（最大堆内存）和-Xms（最小堆内存）设置。为了避免GC后堆内存重新分配，通常将两者的值设为一样。 方法区 方法区是存放字节码的内存区域，当一个字节码文件被加载后，会将其对应类型信息、常量、静态变量和即时编译器编译后的代码缓存等数据保存至方法区。 说到方法区，不得不说到永久代的概念，在虚拟机的早期实现中，标准HotSpot虚拟机的垃圾收集器所管理的内存区域包含了方法区，所以方法区又被称为永久代，但实际上HotSpot虚拟机只是用永久代来实现方法区，为了省去专门为方法区提供内存管理的工作。在Java6时代，永久代就被放弃了，改为使用本地内存来实现方法区。到Java7时，原本存放在永久代的字符串常量池和静态变量被移动到堆内存中。而到了Java8时，永久代完全被抛弃，取而代之的是本地内存中的元空间，原本存在于永久代中的类型信息和代码缓存等数据被移到了元空间中。 运行时常量池 运行时常量池属于方法区的一部分，它存放的是常量池表，包含字面量和符号引用。该内存区域可以在运行期动态改变，常用的是String类的intern()方法，受方法区内存大小限制，该区域也会抛出OutOfMemoryError异常。 字节码如何被执行？对于HotSpot虚拟机来说，它所做的工作是将字节码翻译成机器码。而翻译有两种形式：第一种是解释执行，逐条将字节码翻译成机器码并执行；第二种是即时编译，将一个方法所包含的所有字节码翻译成机器码后再执行。 前者的优点是无需等待编译，而后者的优点是实际运行速度更快。HotSpot虚拟机采用了混合模式，综合两种形式，先解释执行字节码，通过热点代码探测技术发现热点代码后，以方法为单位进行即时编译。 HotSpot虚拟机包含多个即时编译器：C1和C2等。 C1又叫做Client编译器，面向的是对启动性能有要求的客户端GUI程序，采用的优化手段相对简单，因此编译时间较短。 C2又叫做Server编译器，面向的是对峰值性能有要求的服务端程序，采用的优化手段相对复杂，因此编译时间较长，但生成的机器码的执行效率更高。 从Java7开始，HotSpot采用分层编译：热点方法首先会被C1编译，然后热点方法中的热点会进一步被C2编译。为了不影响程序的正常运行，热点方法的编译是放在子线程中进行的。HotSpot会根据CPU的核数设置即时编译的线程数，并按照1:2的比例分配给C1和C2编译器。 参考 《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》 - 周志明 《深入拆解Java虚拟机》 - 极客时间","link":"/2020/07/20/javase/jvm/run-class/"},{"title":"何为引用","text":"无论是通过引用计数算法还是通过可达性分析算法判断对象是否存活都离不开“引用”这个概念，那到底什么是“引用”呢？ Java语言中狭隘的“引用”定义是：如果Reference类型的数据中存储的数值代表的是另一块内存区域的起始地址，就称该Reference数据是代表某块内存（某个对象）的引用。在这种定义下，一个对象只存在两种状态：“被引用”/“未被引用”。这样的定义很严谨，但却缺少了一点灵活的空间，就像这个社会一样，不是所有人都值得活着，那些人民子弟兵值得永远存在，但那些犯罪的恶徒多活一秒都是对社会的污染。在Java中也是一样，堆上的对象不是所有的都是必须的，当内存空间出现紧张时，一些对象将会被抛弃。 在JDK 1.2版本后，Java中的引用分为四种类型：强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference），这四种引用强度依次减弱。 强引用（Strongly Reference） 强引用是狭隘的引用定义，被引用的对象只会出现两种状态：“被引用”和“未被引用”。这种引用关系很常见，即类似于Object obj = new Object()这种直接赋值的，只要强引用关系还在，堆内的对象就永远不会被回收。 软引用（Soft Reference） 软引用描述的是还有用，但不是必须的一类对象。只被软引用关联着的对象在虚拟机将要发生内存溢出前，会将这类对象列进回收范围之中进行二次回收，如果将它们回收完成后内存还是不足，才会抛出内存溢出异常。Java中提供SoftReference类实现软引用。 弱引用（Weak Reference） 弱引用描述的也是那些非必须对象，但它的强度比软引用要弱一点，被弱引用关联着的对象只能活到下一次垃圾回收发生的时刻。当垃圾回收开始工作时，无论内存是否充足，都会回收掉弱引用的对象。Java中提供了WeakReference类实现弱引用。 虚引用（Phantom Reference） 虚引用是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会影响该对象的生存周期，也无法通过虚引用得到一个实例对象。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被垃圾回收时收到一个系统通知。Java中提供了PhantomReference类实现虚引用。 参考 《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》 - 周志明","link":"/2020/07/20/javase/jvm/what-is-quote/"},{"title":"勇闯算法-在行列都排好序的矩阵中找指定的数","text":"题目来源：《程序员代码面试指南-IT名企算法与数据结构最优解》-左程云著 牛客网在线OJ系统地址：传送门 题目描述给定一个N × M的整型矩阵matrix和一个整数K，matrix的每一行每一列都是排好序的。实现一个函数，判断K是否在matrix中。 要求： 时间复杂度为O(N + M)，额外空间复杂度为O(1)。 备注： 1 ⩽ N, M ⩽1000 0 ⩽ K, 矩阵中的数 ⩽ 10^9^ 输入描述第一行有三个整数N，M，K； 接下来N行，每行M个整数为输入的矩阵。 输出描述若K存在于矩阵中输出&quot;Yes&quot;，否则输出&quot;No&quot;。 示例示例一输入： 1232 4 51 2 3 42 4 5 6 输出： 1Yes 示例二输入： 1232 4 2331 2 3 42 4 5 6 输出： 1No 思考由于矩阵中的行和列都是排好序的，我们可以知道最后一列是每一行的最大值，最后一行是每一列的最大值。整个矩阵的最大值在右下角。 要想减少时间复杂度，我们必须能够快速排除某些行或列，基于最后一列或行是每一行或列的最大值的特点，我们可以从矩阵右上角或左下角开始查找，如果不是指定的数，我们就可以排除掉一行或一列了。 算法思路思路一：从矩阵右上角开始查找 从矩阵最右上角的数开始查找（row=0,col=M-1：第0行，第M-1列）。 比较当前数matrix[row][col]与K的关系： 如果等于K，则找到了，返回&quot;Yes&quot;，整个过程结束。 如果大于K，则该列被排除，令col=col-1，重复步骤2。 如果小于K，则该行被排除，令row=row+1，重复步骤2。 如果找到越界都没有找到与K相等的数，则返回&quot;No&quot;，整个过程结束。 思路二：从矩阵左下角开始查找 从矩阵最左上角的数开始查找（row=N-1,col=0：第N-1行，第0列）。 比较当前数matrix[row][col]与K的关系： 如果等于K，则找到了，返回&quot;Yes&quot;，整个过程结束。 如果大于K，则该行被排除，令row=row-1，重复步骤2。 如果小于K，则该列被排除，令col=col+1，重复步骤2。 如果找到越界都没有找到与K相等的数，则返回&quot;No&quot;，整个过程结束。 代码实现（Java）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.util.Scanner;public class Main { public static void main(String[] args) { // receive input params Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int m = scanner.nextInt(); int k = scanner.nextInt(); // build matrix int[][] matrix = new int[n][m]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { matrix[i][j] = scanner.nextInt(); } } // do check boolean containsOne = isContainsOne(matrix, k); System.out.println(containsOne ? &quot;Yes&quot; : &quot;No&quot;); // boolean containsTwo = isContainsTwo(matrix, k); // System.out.println(containsTwo ? &quot;Yes&quot; : &quot;No&quot;); } /** * 判断方式一：双重for循环 * 外层循环矩阵每一行 * 内层循环矩阵每一列 * 相等直接返回true； * 若小于k，则排除当前行，结束内层循环，遍历下一行。 * 若大于k，则排除当前列，j--，内存循环进入下一次。 * 若双重循环完成都未找到k，则返回false。 * @param matrix * @param k * @return */ private static boolean isContainsOne(int[][] matrix,int k) { int col = matrix[0].length; for (int[] ints : matrix) { for (int j = col - 1; j &gt;= 0; j--) { int value = ints[j]; if (value == k) { return true; } else if (value &lt; k) { break; } } } return false; } /** * 判断方式二：while循环 * 越界条件：行遍历完或列遍历完 * @param matrix * @param k * @return */ private static boolean isContainsTwo(int[][] matrix,int k) { int row = matrix.length; int col = matrix[0].length; int i = 0; int j = col - 1; while (i &lt; row &amp;&amp; j &gt;= 0) { int value = matrix[i][j]; if (value == k) { return true; } else if (value &lt; k) { i++; } else { j--; } } return false; }}","link":"/2020/07/14/algorithm/coding-interview-guide/arraysandmatrices/solution01/"},{"title":"LeetCode题解-第242题：有效的字母异位词","text":"给定两个字符串s和t ，编写一个函数来判断t是否是s的字母异位词。 示例1: 输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 示例2: 输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false 说明: 你可以假设字符串只包含小写字母。 进阶: 如果输入字符串包含Unicode字符怎么办？你能否调整你的解法来应对这种情况？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-anagram著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路：首先考虑特殊情况，如果字符串s和t都为空字符串，则可认为它们互为字母异位词；如果字符串s和t连长度都不相等，则一定不为字母异位词。然后再考虑如何进行判断，两个字符串中都只包含26个小写的英文字母，如果两个字符串是字母异位词，那么一定满足：每一个小写英文字母在字符串s中出现的次数等于在字符串t中出现的次数。于是，我们只需分别对每一个小写英文字母在两个字符串中出现的次数进行计数，然后比较是否相等即可。 具体到代码实现层面，由于两个字符串互为字母异位词的前提条件是其长度相等，所以在计数时我们可以同时对两个字符串进行遍历；另一方面，分别计数可以转换成对第一个字符串s进行计数累加，而对另一个字符串t进行计数递减，最终如果每一个小写英文字母的累计结果为0，则可明确这两个字符串互为字母异位词，只要出现一个小写英文字母的累计结果不为0，则不满足条件。 如何对每一个小写英文字母进行计数？可定义一个长度为26的int数组，字母a到z依次对应下标索引0到25。在遍历字符串s时，每次遇到a则将索引0位置的值加一，以此类推；而当遍历字符串t时，每次遇到a则将索引0位置的值减一。直到遍历完成，判断数组中的所有元素是否都为0，如果是，则s和t互为字母异位词，否则不是。 代码如下： 12345678910111213141516171819202122232425262728public boolean isAnagram(String s, String t) { // 1. 空字符串情况 if (s.length() == 0 &amp;&amp; t.length() == 0) { return true; } // 2. 长度不相等情况 if (s.length() != t.length()) { return false; } // 字符串转字符数组 char[] sc = s.toCharArray(); char[] tc = t.toCharArray(); // 定义字母计数器 int[] counter = new int[26]; // 同时遍历两个字符数组 for (int i = 0,length = sc.length;i &lt; length;i++) { // 字母对应下标位置的值加一 counter[sc[i] - 'a']++; // 字母对应下标位置的值减一 counter[tc[i] - 'a']--; } // 遍历计数器 for (int c : counter) { // 存在一个计数不为0的则可确定不是字母异位词 if (c != 0) return false; } return true;} 进阶问题： 如果输入字符串包含Unicode字符怎么办？ 思路：Unicode字符可定义100万个以上的唯一字符，如果还选择使用数组来计数，那么需要开辟出一块非常大的内存空间，而且最后遍历数组也是非常耗时的。于是我们可以考虑使用哈希表来计数，可以适应任意的字符范围，另外最后遍历哈希表判断计数结果时，可将哈希表中的数据去重，即转换成一个无序不重复的Set集合，利用空间换时间，如果该集合中只存在一个元素且值为0，则字符串s和t互为字母异位词，否则不是。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public boolean isAnagram(String s, String t) { // 1. 空字符串情况 if (s.length() == 0 &amp;&amp; t.length() == 0) { return true; } // 2. 字符串长度不相等 if (s.length() != t.length()) { return false; } // 字符串转字符数组 char[] sc = s.toCharArray(); char[] tc = t.toCharArray(); // 哈希表计数器 Map&lt;Character,Integer&gt; counter = new HashMap&lt;&gt;(); // 遍历第一个字符串s for (int i = 0,sLength = s.length();i &lt; sLength;i++) { Integer val = counter.get(sc[i]); if (val != null) { // 如果当前字符已存在于哈希表中，则计数加一 val += 1; counter.put(sc[i],val); } else { // 当前字符第一次出现，则计数为1 counter.put(sc[i],1); } } // 遍历第二个字符串t for (int j = 0,tLength = t.length();j &lt; tLength;j++) { Integer val = counter.get(tc[j]); if (val != null) { // 如果当前字符已存在于哈希表中，则计数减一 val -= 1; counter.put(tc[j],val); } else { // 当前字符第一次出现，已经可以断定不是字母异位词 return false; } } // 方案一：遍历哈希表计数器 /** Iterator&lt;Map.Entry&lt;Character,Integer&gt;&gt; iterator = counter.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry&lt;Character,Integer&gt; entry = iterator.next(); // 如果计数结果不等于0，则不是字母异位词 if (entry.getValue() != 0) { return false; } } **/ // 方案二：将哈希表转成无序不重复的Set集合 Set&lt;Integer&gt; set = new HashSet&lt;&gt;(counter.values()); // 如果Set集合中的元素个数不为1，或者唯一一个元素的值不为0，则可确定不是字母异位词。 if (set.size() != 1 || !set.contains(0)) { return false; } return true;}","link":"/2020/07/14/algorithm/leetcode/easy/242/"},{"title":"LeetCode题解-链表标签：链表相交","text":"题目：给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。 示例 1： 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Reference of the node with value = 2 输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null 。 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路：若两个链表相交，那么情况一定是如下图所示： 相交的节点后面，两个链表完全重合，那么如何找到相交的节点呢？如果两个链表长度一样，那么同时遍历两个链表，当遇到引用相等的节点时就是两个链表相交的节点。但如果两个链表长度不一样呢？假设我们能够基于两个长度不同的链表构造出长度一样的两个链表，那么就可以找到相交的节点。那问题转换成如何构造长度一样的链表？如果两个链表的长度相差x个节点，先用一个指针遍历较长的链表x次，这时如果将该指针指向的节点作为头节点，跟另一个较短长度的链表就构成了长度一样的两个链表。然后同时进行遍历，直到遇到引用相等的节点即为头节点。如果整个过程都未遇到引用相等的节点，则可断定两个链表不相交。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041public ListNode getIntersectionNode(ListNode headA, ListNode headB) { // 分别计算两个链表的长度 int lenA = 0; int lenB = 0; ListNode a = headA; ListNode b = headB; while (a != null) { lenA++; a = a.next; } while (b != null) { lenB++; b = b.next; } // 较长链表先遍历长度之差步 ListNode x = headA; ListNode y = headB; if (lenA &gt; lenB) { int diff = lenA - lenB; while (diff &gt; 0) { x = x.next; diff--; } } else { int diff = lenB - lenA; while (diff &gt; 0) { y = y.next; diff--; } } // 此时以x、y为头节点的两个链表长度一样，同时进行遍历，如果遇到引用相等的节点，则一定是相交的节点。 while (x != null &amp;&amp; y != null) { if (x == y) { return x; } x = x.next; y = y.next; } // 遍历结束，可断定两个不相交。 return null;}","link":"/2020/07/14/algorithm/leetcode/tag/linkedlist/intersection-of-two-linked-lists-lcci/"},{"title":"事务的特性和隔离级别","text":"简介提起数据库，那不得不说到事务，但事务并不是MySQL数据库的专属，而是SQL语言的特性，事务就是一组原子性的SQL查询。该组查询语句要么全部执行成功，要么全部执行失败。如果其中有任何一条语句执行失败或因为数据库奔溃等其它原因无法执行，那么所有语句都不会执行。 事务特性事务的特性就是我们俗称的ACID，下面依次进行解释： A：原子性（Atomicity） 一个事务必须是一个不可分割的最小执行单元，整个事务中的所有操作要么全部执行成功，要么全部执行失败后回滚，对于一个事务而言，不可能出现其中一部分操作执行成功，另一部分操作执行失败的情况，这就是事务的原子性。 C：一致性（consistency） 数据库总是从一个一致性的状态转换到另一个一致性的状态。例如银行转账，用户A的账户向用户B的账户转账100元人民币，在这个事务中，首先会从用户A的账户中扣减100元，然后给用户B的账户增加100元，由于事务的原子性的保证，即使在从用户A的账户中扣减100元后数据库系统奔溃，用户A的账户上也不会损失100元，因为事务没有最终进行提交，用户A的账户扣减不会保存至数据库中，同时由于系统奔溃，用户B的账户也不会增加金额。也就是说，经过一次事务，整个账户系统中的金额总数不会改变，这就是事务的一致性。 I：隔离性（isolation） 隔离性是指多个客户端并发访问数据库时，一个客户端的事务不能被其它客户端的事务所干扰，并发事务之间要做到事务隔离。 隔离性需要结合事务的隔离级别来说，下文会对事务的隔离级别进行展开说明。 通常的隔离性是：一个事务中的修改在最终提交事务之前，对其它事务是不可见的。还是银行转账的例子，在用户A给用户B转账的事务提交之前，如果用户A还向另一个用户C转账，这时候看用户A的账户是还未扣减100元的，这就是事务的隔离性。 D：持久性（durability） 一旦事务提交，则该事务中所做的所有修改都将永久保存至数据库中，会被持久化至磁盘上，即使此时系统发生奔溃，事务中发生修改的数据也不会丢失。 在MySQL中，事务的实现在引擎层。MySQL是一个支持多引擎的系统，但并不是所有引擎都支持事务，例如MySQL原生的MyISAM引擎就不支持事务，而我们熟知的InnoDB引擎则是支持事务的。 并发访问的问题当多个事务并发执行的时候，就会出现并发问题，为了解决这些问题，提出了隔离级别的概念，每一种隔离级别都可以解决一个并发问题。 事务的并发执行存在以下三种问题： 脏读 一个事务读到了另一个事务中未提交的数据。 不可重复读 假设存在这样一个事务，首先查询一条记录，然后修改该条记录的值，再次查询该条记录，那么对于这个事务而言，两次查询到的记录的值不一致，这被称为不可重复读。 幻读 假设存在这样一个事务，首先条件查询某个范围内的记录，此时某个并发执行的其它事务在该范围内插入了新的记录，当之前的事务再次以相同的条件范围查询时，就会查询到新插入的行（称为幻行）。InnoDB引擎通过多版本并发控制（MVCC）来解决幻读的问题。 事务的隔离级别每一种隔离级别都解决了一个并发问题，但必须明白，问题解决的越多，效率就会越低。因此很多时候我们需要根据实际业务场景来选择合适的隔离级别。 SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读已提交（read committed）、可重复读（repeatable read）和串行化（serializable）。 读未提交（read uncommitted） 可读取其它事务中未提交的数据，不能解决任何并发问题。 读已提交（read committed） 只能读取其它事务中已提交的数据，可以解决脏读问题。 可重复读（repeatable read） 一个事务执行过程中能读取到的数据，总是跟这个事务在启动时读到的数据保持一致。可以解决脏读和不可重复读问题。 实现原理是在事务启动时创建一个视图，整个事务存在期间都会查询该视图。 串行化（serializable） 最高的事务隔离级别，使用读写锁强制所有操作串行排队执行，解决了所有的并发问题。但其效率也最为低下。对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突时，后启动的事务必须等待前一个事务执行完并提交后，才能执行。 不同隔离级别之间的性能比较（从高到低）：读未提交 &gt; 读已提交 &gt; 可重复读 &gt; 串行化。 性能越高，并发安全性越低。MySQL在5.0版本之后开始，选择可重复读做为默认的隔离级别。 MySQL为什么选择可重复读作为默认的隔离级别？ 传送门 深入理解事务隔离级别这里我们用一个例子来尝试理解事务的隔离级别。 初始化表T，插入一条记录： 1234567CREATE TABLE `T` ( `id` int(11) NOT NULL AUTO_INCREMENT, `num` int(11) NOT NULL DEFAULT 0, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;insert into `T` (`num`) values (1); 假设有两个事务的执行顺序如以下表格所示： 时间轴 事务1 事务2 t0 begin begin t1 select num from T where id = 1; t2 select num from T where id = 1; t3 update T set num = 2 where id = 1; t4 select num from T where id = 1; t5 commit; t6 select num from T where id = 1; t7 commit; t8 select num from T where id = 1; t1时刻事务1查询得到的num值为1。 设t4时刻事务1查询得到的num值为N1，t6时刻事务1查询得到的num值为N2，t8时刻事务1查询得到的num值为N3。 在不同隔离级别下，N1、N2和N3的值会一样吗？分别是多少？ 读未提交隔离级别下： 事务1可读到事务2中未提交数据，于是N1=N2=N3=2。 读已提交隔离级别下： 事务1只能读到事务2中已提交的数据，于是N1=1, N2=2, N3=2。 可重复读隔离级别下： 事务1中读到的数据总是跟该事务刚启动时读到的数据保持一致，于是N1=1, N2=1, N3=2。 串行化隔离级别下： 对同一行数据的操作强制排队执行。t1时刻事务1加读锁；t2时刻事务2加读锁；t3时刻事务2尝试加写锁，进入阻塞状态，等待事务1提交后才会执行update；t8时刻事务2已提交。于是N1=1, N2=1, N3=2。 总结事务的四大特性：ACID； 事务的并发问题：脏读、不可重复读和幻读。 事务的隔离级别：读未提交、读已提交（解决了脏读）、可重复读（解决了不可重复读）和串行化（解决了幻读，无并发问题）。 参考 《MySQL实战45讲》 - 极客时间","link":"/2020/07/12/database/mysql/transaction-characteristics-and-isolation-levels/"},{"title":"MySQL为什么选择可重复读作为默认的隔离级别？","text":"问题在Oracle和SqlServer关系型数据库中，默认的事务隔离级别是读已提交。为什么MySQL的默认隔离级别选择可重复读呢？ 解答这个问题得从主从复制说起，MySQL的主从复制是基于binlog复制的。 binlog有以下三种格式： Statement：记录修改的SQL语句。 Row：记录每一行数据的变更。 Mixed：Statement和Row模式的混合。 MySQL在5.0版本之前，binlog只支持Statement格式，在读已提交隔离级别下，这种格式的主从复制是存在问题的。 我们来看下面的例子： 创建一张S表，并初始化一条数据。 1234567CREATE TABLE `S` ( `id` int(11) NOT NULL AUTO_INCREMENT, `val` varchar(32) NOT NULL DEFAULT '', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;insert into `S` (`val`) values ('hello'); 假设此时我们的MySQL是5.0版本，binlog为Statement格式，且隔离级别为读已提交。在主从架构下，主库上执行以下事务： Statement1 Statement2 begin begin delete from S where id &lt; 5; insert into S (val) values (‘java’); commit; commit; 此时在主库上执行select * from S，会输出一条记录java；而在从库执行该语句会输出Empty Set。 主从库数据出现了不一致。那原因是什么呢？ 在主库上，Statement1的删除先执行，在其提交事务之前Statement2插入数据并提交，Statement2插入的数据不会被删除，最后Statement1事务提交，也就是先删除后插入，表中留下了Statement2事务中插入的数据。在这个过程中，由于Statement2先提交，binlog先将插入记录下来，然后记录后提交的删除。同步到从库上时，就是先插入后删除。所以导致了主从数据不一致。 那么如何解决该问题呢？ 方案一：使用可重复读隔离级别，该级别下引入间隙锁，在Statement1执行删除时，间隙锁会锁住一个id区间（这个区间范围有一定的规则），在这个区间内的操作都会阻塞，所以Statement2执行插入会被阻塞住，直到Statement1事务提交才执行。 方案二：将binlog的格式修改为Row格式，基于行的复制，这样就保证了删除和插入的执行顺序。但该特性在5.0版本之后才引入，所以，MySQL为了保证主从同步数据一致性，将默认隔离级别设置为可重复读。 间隙锁的存在，导致可重复读隔离级别出现死锁的几率变大，一旦出现死锁，对业务的影响将是不可预料的，所以，实际业务开发中，并不推荐使用默认的可重复读隔离级别，而是推荐使用读已提交隔离级别。 总结关于间隙锁，我将单独写一篇博客进行详细介绍。这里只需理解到会锁住一个区间即可，在这个区间内的操作都会阻塞。 MySQL的早期版本没有间隙锁，在读已提交隔离级别下主从同步会出现数据不一致的情况，所以将默认的隔离级别设为了读已提交。 参考 https://www.cnblogs.com/rjzheng/p/10510174.html","link":"/2020/07/12/database/mysql/why-does-mysql-choose-repeatable-read-as-the-default-isolation-level/"},{"title":"关于Java，你不得不学的java.lang.String类","text":"前言在Java开发中，我们从头至尾都在与String打交道。还记得我们敲下的第一行代码吗？ 1System.out.println(&quot;Hello World!&quot;); 这是我们所有开发人员梦开始的地方。那年，青涩的我们在课堂上敲下这第一行代码，殊不知，它竟会影响我们每个人的一生。 java.lang.String类简介对于部分刚学习Java的初学者来说，当问到Java中有哪些基本数据类型时，可能会回答出String字符串。 但事实上，String是一个引用类型。 Java中的基本类型有以下八种：byte、short、int、long、char、float、double和boolean。 ==和equals()区别我们先来看这样一段代码： 12345public static void main(String[] args) { String a = &quot;Hello&quot; + &quot; World&quot; + &quot;!&quot;; String b = &quot;Hello World!&quot;; System.out.println(a == b);} 聪明的你是否已经知道了这段代码的运行结果呢？ 运行结果：true。 如果你立刻知道了结果且懂其原理，那么这一个知识点可以跳过；如果还有一点含糊，那就请仔细往下看。 要解释这个运行结果的原理，需要知道下面三个问题： ==和equals()是如何进行比较的？ 上述代码中的变量a和b在内存中是什么样的？ 编译时的优化方案。 ==的比较方案在Java语言中，==运算符用于比较两个内存单元上的内容是否一样，实际是比较两个数字，在计算机内部就是0和1。 对于七种基本数据类型（boolean除外），就是直接比较两者的数值是否相等。 而对于引用类型，例如示例中的String引用类型，比较的是“引用的值”，实际就是两者的内存地址值。 如果两个引用进行==比较，比较的是两个引用对象的内存地址值是否相等，实际上就是判断两个引用所指向的对象是否存储在同一个内存区域上。如果是，则返回true；否则返回false。 举一个不太恰当的比喻：大家都考上了心仪的大学，现在比较哪些人考上了同一所大学。 equals()方法的比较方案对于equals()方法，它的源头来自于Object类。在Java中，任何对象都隐式的继承了java.lang.Object类。所以任何对象都可以调用equals()方法进行比较。 而在java.lang.Object类中，equals()方法的实现是这样的： 123public boolean equals(Object obj) { return (this == obj);} 直接使用了==运算符比较。这意味着：如果调用equals()方法进行比较的类及其显式使用extends关键字继承的父类列表中都没有重写过equals()方法，那么调用equals()方法就等同于使用==运算符进行比较。 equals()方法之所以存在于Object类中，就是希望子类去重写，以实现比较对象相等的功能。 java.lang.String类就重写了equals()方法，因为对于字符串来说，只要字符串内容相同，则可认为这两个字符串是“相等”的。 两个对象“相等”并不意味着对象的所有属性都要相等，需要根据对象的具体业务场景进行具体分析。 例如，两个罗技牌鼠标，它们的属性除了品牌、型号、尺寸和价格外，还有如生产地区、售卖方式等属性，但是我们可能只需要对比它们的品牌、型号和尺寸等属性，在这个范围内其余的属性不需关心。也就是说，两个对象的值是否相等需要根据对象的业务场景决定，而不是有一个唯一的标准来比较。 所以，Object类提供了equals()方法来让各个类选择重写，用以实现符合自身业务场景的对象相等比较。 上述代码中的变量a和b在内存中的结构在Java中，对象在内存中的存储通常是：栈中的引用指向堆内的对象。对于字符串对象来说，还有一个字符串常量池用来存储字符串对象（它是一个JVM级别的字符串缓存），也就是会出现栈中的引用指向常量池中的对象。 在Java6之前，字符串常量池位于方法区内； 而在Java7中，字符串常量池被移到了堆内存中； 在Java8中，提出了元空间的概念，字符串常量池也随之移动到了元空间。 编译时的优化变量a是通过+拼接字面量进行赋值的，在编译期，String a = &quot;Hello&quot; + &quot; World&quot; + &quot;!&quot;;就已经被编译成String a = &quot;Hello World!&quot;;了，为什么会这样呢？因为字面量的值是确定的，运行时不再需要任何计算，也就没有使用+运算符的必要了，编译器也这么觉得：“这不是在脱裤子放屁吗”？所以在编译期运算符就被去除了。于是a和b的赋值是完全一样的。 运行原理对于变量a和b这种使用字面量创建字符串的方式，在创建变量a时，JVM首先会去字符串常量池中查找&quot;Hello World!&quot;这个字符串对象，如果不存在，则在字符串常量池中创建一个&quot;Hello World!&quot;对象，然后将常量池中&quot;Hello World!&quot;这个对象的引用地址赋给栈中的引用a，这样栈中的引用a就指向了常量池中的&quot;Hello World!&quot;对象；如果已经存在，则不会再次创建新对象，直接将已有的&quot;Hello World!&quot;对象的地址返回，赋给栈中的引用b，于是，栈中的引用b也指向了常量池中的&quot;Hello World!&quot;对象。 常量池中的&quot;Hello World!&quot;对象只有一份，于是使用==运算符比较变量a和b会返回true。 编译器的优化我们再来看下面这段代码： 123456789101112131415public static void main(String[] args) { String m = &quot;a&quot;; final String n = &quot;a&quot;; String x = m + &quot;b&quot;; String y = n + &quot;b&quot;; String z = getA() + &quot;b&quot;; String compare = &quot;ab&quot;; System.out.println(x == compare); System.out.println(y == compare); System.out.println(z == compare);}public static String getA() { return &quot;a&quot;;} 你心中有答案吗？知道每个答案的原理吗？ 如果还没有，下面的内容你应该仔细阅读。 输出结果： 123falsetruefalse 首先，第一个输出，变量x与compare比较，变量x等于局部变量m加上字符串&quot;b&quot;，虽然局部变量m也指向了一个字面量&quot;a&quot;，但是这个引用关系并未进行“强制约束”，在运行期，可通过字节码增强技术来动态改变该引用的指向，所以编译器并未直接将其优化成&quot;ab&quot;。而是将其优化成了StringBuilder的形式： 123StringBuilder temp = new StringBuilder();temp.append(m).append(&quot;b&quot;);String x = temp.toString(); 使用new关键字创建的StringBuilder对象位于堆内存中，于是变量x指向了堆中的对象。而局部变量compare指向字面量&quot;ab&quot;，按照前文的叙述，JVM将会先去字符串常量池寻找&quot;ab&quot;字符串对象，如果找到，则会直接返回常量池中地址返回，赋给引用compare。 变量x指向堆内存，而变量compare指向常量池内存，所以使用==运算符比较的结果为false。 第二个输出，变量y与compare比较，变量y等于局部变量n加上字符串&quot;b&quot;，虽然与变量x十分类似，但是，请注意局部变量n前面声明的final关键字，它具有不可变性，即n只会被赋值一次。保证了局部变量n始终指向字面量&quot;a&quot;所在的内存地址，按照程序的逻辑顺序，字面量&quot;a&quot;此时已经存在于字符串常量池中了，所以局部变量n始终指向常量池中&quot;a&quot;所在的内存地址。这个引用关系是无法进行修改的。所以编译器将变量y直接优化成了&quot;ab&quot;。 第三个输出，变量z与compare比较，变量z由一个方法的返回值加上字符串&quot;b&quot;组成，虽然方法内返回一个常量的引用，但是编译器并不会看方法内返回了什么，因为方法内部的行为是未知的，可能会出现多重递归，而且递归过后也不一定会返回固定的常量值。所以编译器不会将变量z优化成&quot;ab&quot;。 编译器的代码优化一定是在编译期就能确定优化后不会改变原有功能，类似于final引用，这个引用只会被赋值一次。只有在编译阶段能确定这个引用被赋值的内容，编译器才可能进行编译期优化，不要和运行期的动作关联到一起，编译期能确定的内容只来源于常量池，使用new关键字创建对象属于运行期的动作。同样地，方法的返回值也是不能确定的，运行期的方法可能会返回不同的值。 String#intern()方法有了上面的知识后，我们再来看以下代码： 12345678910public static void main(String[] args) { String a = &quot;a&quot;; String b = a + &quot;b&quot;; String c = &quot;ab&quot;; String d = new String(b); System.out.println(b == c); System.out.println(c == d); System.out.println(c == d.intern()); System.out.println(b.intern() == d.intern());} 这段代码增加了intern()方法的调用，其输出结果为： 1234falsefalsetruetrue 对于前两个输出，你应该能知道答案。第一个输出在上一个例子中讲过了，输出为false；第二个输出，变量c在常量池中，变量d在堆中，输出为false。 对于后两个输出，如果你不了解intern()方法的作用，恐怕不能给出合理的解释。 当调用String类的intern()方法时，JVM会在常量池中通过equals()方法查找是否存在值相等的字符串，如果存在，则直接返回常量池中的地址；否则，则会将该字符串加入常量池（开辟新的内存空间），然后返回常量池中新开辟的这块内存空间地址。所以，只要是值相等（equals()方法比较相等）的字符串，当调用intern()方法时，都会得到常量池中对应字符串的引用地址，所以使用==运算符比较会返回true。 对于第三个输出，变量c使用字面量赋值，得到的是常量池中的引用；而变量d使用new关键字创建了一个堆中对象，但调用intern()方法后发现常量池中已经存在了&quot;ab&quot;，所以返回常量池的引用地址，于是使用==运算符比较返回true。 对于第四个输出，变量b和d都调用了intern()方法，得到的都是常量池中的引用地址，自然使用==运算符比较返回true。 StringBuilder对象在阿里巴巴开发手册中，推荐在for循环体内使用StringBuilder对象的append()方法进行字符串拼接，而不是+号。 手册中给出的反例如下： 1234String str = &quot;start&quot;;for (int i = 0;i &lt; 100;i++) { str = str + &quot;hello&quot;;} 由于没有给出正例，有些人在理解上可能出现了一些偏差，于是出现了以下代码： 1234567String str = &quot;start&quot;;for (int i = 0;i &lt; 100;i++) { StringBuilder sb = new StringBuilder(); sb.append(str) .append(&quot;hello&quot;); str = sb.toString();} 实际上这也是反例，只不过是手册中给出的反例经过编译器编译之后的。 阿里巴巴的这个推荐的初衷是不要在循环体内使用+号，因为+号会被编译器优化成StringBuilder对象，所以它的建议实际是不要在循环体内创建StringBuilder对象。 正确的写法如下： 1234567StringBuilder sb = new StringBuilder();String str = &quot;start&quot;;sb.append(str);for (int i = 0;i &lt; 100;i++) { sb.append(&quot;hello&quot;);}str = sb.toString(); 为什么这样建议？使用+有什么不好的地方？ 使用+号实际是在循环体内创建了StringBuilder对象，调用append()方法拼接后重新给引用str赋值，这会导致str指向的字符串越来越大，到达一定程度后会进入老年代，甚至出现OOM。同时每次循环都会创建一个StringBuilder对象，在一次循环结束后，该对象就会变成垃圾等待回收，导致内存开销增大。 而正确的写法会在循环体外预先创建一个StringBuilder对象，每次循环中都调用该对象的append()方法拼接字符串，避免了内存开销大的情况。 小结：要明确的一点是，不是+号操作本身慢，而是在循环体中每次循环都会创建对象导致内存开销变大，每一次循环后，创建的对象变成了垃圾引发GC进行垃圾回收，导致程序变慢。 总结关于String类，本文只是抛砖引玉，很多细节并未提及，例如StringBuilder在进行append时的扩容，在拼接大字符串和小字符串时如何合理使用让内存利用率更高，还包括StringBuffer同步类等其它字符串相关的内容。总之，字符串是开发中必定会使用到的数据类型，如果涉及到字符串操作，请一定要考虑到效率问题，从小的细节入手精心雕琢代码。","link":"/2020/06/29/javase/base/string/"},{"title":"勇闯算法-递归法拿下反转链表的三杀","text":"前言编程语言：Java（JDK8） 单链表节点类： 12345public class ListNode { int val; ListNode next; ListNode(int x) { val = x; }} 关于反转链表，有迭代和递归两种实现方式，本文使用递归实现反转。 首先介绍递归的思想，然后从最基本的反转整个单链表开始，由浅入深，最终拿下反转链表的“三杀”！ 递归思想 任何一个问题，如果能够用迭代解决，那么一定可以转换成递归。 —— 某算法大神 我们很难去证明大神的说法不正确，但我们可以先假设他的理论成立。先强行让自己接受。 恩！没错！能够用迭代解决就一定能用递归解决！ 是不是有递归“内味”了？先假设条件成立，把主要逻辑走通。 那么到底如何将迭代转换成递归呢？ 迭代是遍历，一个一个地进行迭代处理； 而递归呢？在处理第一个的时候要先假设后面的全部都处理完了，只需处理第一个，所以，只要第一个处理完了，整个就处理完了（感觉完全无法接受啊）。 “假设”始终是假设，但是它能让我们的当前逻辑走通。在第一次的假设中，我们可以进行第二次地假设，假设后面的数据的第一个之后的数据全都处理完了，则只需处理此时的第一个。这样不停地假设下去，直到假设到整体的最后一个数据，这个时候没有数据让我们假设了，不能再“骗自己”了！要拿出点真本事来！我们对整体的最后一个数据进行真实的处理，这个时候我们发现，倒数第二个数据的假设成立了！多米偌骨牌效应！之前所有的假设都成立了！问题解决了！ First Blood：反转整个单链表首先用递归来解决最基本的整个单链表的反转。（“对面辅助开始搞事情了”） 例如：单链表为：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null，那么反转之后的单链表为：null &lt;- 1 &lt;- 2 &lt;- 3 &lt;- 4 &lt;- 5。 对应上面的递归思想：在反转第一个节点的时候，先假设后面的节点全都反转完了，返回了反转后的头节点，它就是整个单链表反转完成后的头节点，于是我们只需将第一个节点进行反转，整个链表的反转就完成了。在第一次假设中，同样进行假设，不停地假设，直到最后一个节点，后面没有节点让我们进行假设了，我们进行真实的反转。这时之前所有的假设像多米偌骨牌一样地成立了，整个单链表反转完成！ 好像无法理解？没关系，按递归的思想，先假设自己理解了。我们来看下代码： 12345678910111213public static ListNode reverse(ListNode head) { // 最后一个节点 if (head.next == null) // 不能再“骗自己”了 return head; // 假设后面的节点全都反转完成，返回了反转后的头节点，即为整个单链表反转后的头节点 ListNode reverseHead = reverse(head.next); // 反转第一个节点 head.next.next = head; head.next = null; // 返回反转后的头节点 return reverseHead;} reverse函数的定义是这样的：输入一个节点head，将以head为头节点的链表反转，返回反转后的头节点。 我们要反转的链表为：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null： reverse(1)：输入第一个节点1时； 假设后面的节点已经反转完成并返回了反转后的头节点：ListNode reverseHead = reverse(head.next); 后面的节点反转后的结果为：null &lt;- 2 &lt;- 3 &lt;- 4 &lt;- 5，返回的头节点reverseHead为5； 此时我们只需要对节点1进行反转： 1234// 将节点1的下一个节点2的指针域指向节点1head.next.next = head;// 将节点1的下一个节点指向nullhead.next = null; 整个链表的反转就完成了！ 但是我们不能“骗自己”！reverse函数不停地进行假设，当它接收到原链表的最后一个节点时，没有节点进行假设了，必须去反转！ 由于只有一个节点，反转后还是自身，所以我们只需返回该节点，即为反转后的头节点。这时我们惊奇的发现前面所有的假设都成立了！ 这就是所谓的递归的出口： 12if (head.next == null) return head; 我们画张图来看下整个流程。 我们的递归算法只需要关注原链表的第一个节点（头节点）和最后一个节点（尾节点），也就是递归开始的节点和无法再进行假设的节点。在递归函数中，首先要处理尾节点，因为这是不可再假设的节点；当处理头节点时，我们进行假设，假设头节点之后的所有节点都已完成反转同时返回了反转后的新头节点，然后对头节点进行反转，此时就完成了整个单链表的反转。 学会了递归思想后，我们就可以愉快的开始“三杀”之旅了！ Double Kill：反转单链表的前N个节点有了上面的“一血”，“双杀”简直就是白送！（“辅助死了，ADC开始送了”） 我们要实现的函数如下： 123456/** * 将单链表的前n个节点进行反转。（n &lt;= 单链表长度） * @param head 单链表头节点 * @param n 前n个节点 */public ListNode reverseN(ListNode head,int n) {...} 假设我们要反转单链表的前3个元素，那我们要实现的效果如下图所示： 按照递归思想，我们只需要关注递归开始的节点和无法再进行假设的节点：即头节点和第N个节点。 对于原单链表的头节点，先假设其后面的N - 1个节点已经反转完成并返回了反转后的新头节点，此时我们只需要反转头节点，将头节点指向第N + 1个节点，链表前N个节点的反转就完成了。但是此时第N + 1个节点我们无法得知。 由于单链表的特性，我们只有遍历到第N个节点时才能得到第N + 1个节点，那我们有必要单独对链表进行遍历获取第N + 1个节点吗？ 完全没必要！因为我们的递归算法本身一开始就要处理第“N”个节点，因为它是无法再进行假设的节点，所以，递归函数中第一步处理第“N”个节点时要记录下第N + 1个节点（使用全局变量）。注意：这里的第N个节点是针对原单链表而言的；对于最后一个无法再进行假设的假设来说：N = 1。 于是我们就可以完成对原链表头节点的反转。从而完成整个单链表的前N个节点反转： 1234567891011121314151617181920/** * 记录原链表的第N+1个节点 */static ListNode nNext;public static ListNode reverseN(ListNode head,int n) { if (n == 1) { // 记录原链表的第 n + 1 个节点 nNext = head.next; // 无法再进行假设了，返回反转后的头节点 return head; } // 假设后面节点的前 N - 1 个节点已经完成了反转，并返回了反转后的新头节点 ListNode reverseHead = reverseN(head.next,n - 1); // 反转原链表的头节点 head.next.next = head; head.next = nNext; // 返回反转后的新头节点 return reverseHead;} “双杀”拿下，不知道你有没有掌握到递归的套路？（“此时对面打野赶到下路，即将送出三杀”） Triple Kill：反转单链表的第m个到第n个节点给定单链表的索引区间[m,n]（约定不越界），反转此区间内的节点。（“敌方打野正在路上”） 已知条件为：单链表的头节点和区间m、n的值，我们要实现的函数如下： 1234567/** * 反转从m到n之间的节点。1 &lt;= m &lt; n &lt;= 链表长度 * @param head 原链表头节点 * @param m 反转开始节点 * @param n 反转结束节点 */public static ListNode reverseBetweenMToN(ListNode head,int m,int n); 例如：单链表为：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null，m = 2, n = 4，那么反转之后的单链表为：1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; null。 按照递归的思想，我们在处理头节点head时，先假设后面的节点已经反转完成并返回了反转后的新头节点，那么只需将头节点的指针域指向反转后的新头节点就完成了需求。 对于去除头节点head之后的链表，我们需要反转的是从m - 1到n - 1区间内的节点： 12head.next = reverseBetweenMToN(head.next,m - 1,n - 1);return head; 那按照递归思想，我们什么时候不能再“骗自己”了呢？当假设到原链表的第m个节点时，对于这个假设来说，是这个假设的第1个节点，此时这个假设需要反转从第1个到第n - m + 1 = n个节点，这不正是Double Kill中的反转单链表的前N个节点吗？ 于是递归函数完整实现为： 1234567public static ListNode reverseBetweenMToN(ListNode head,int m,int n) { if (m == 1) { return reverseN(head,n); } head.next = reverseBetweenMToN(head.next,m - 1,n - 1); return head;} “三杀”拿下！ 总结掌握递归的思想很重要：处理第一个时，先假设后面的全部都处理完了，只需处理第一个；不停地假设，直到不能再假设的时候，开始真正进行处理；这样前面所有的假设就像多米偌骨牌效应一样全都成立了，最终，问题就解决了。 递归虽好，但却不如迭代法高效，虽然时间复杂度都为O(N)，但因为递归需要申请额外的栈空间，所以其空间复杂度为O(N)，而迭代法的空间复杂度仅为O(1)。","link":"/2020/06/04/algorithm/base/recursive-reverse-link/"},{"title":"JDK源码解析之ArrayList","text":"简介ArrayList底层数据结构是动态数组，与普通的数组相比，它的容量可以动态增长。在添加的元素数量达到一定值时，会触发自动扩容机制，保证集合的可用性。 它继承了AbstractList抽象类，并实现了List、RandomAccess、Cloneable 和 java.io.Serializable接口。 AbstractList抽象类已经实现了List接口，为什么ArrayList还要去实现List接口？ 由于底层由数组存储元素，其取指定下标位置元素、在集合尾部插入元素和求数组长度的时间复杂度为O(1)；而在指定索引位置插入和删除元素的时间复杂度为O(n)。 使用分析在开发中，我们会经常使用ArrayList来存储对象，例如对数据库批量插入/修改的入参实体集合、数据库的列表查询结果集转换成前端视图模型对象等。一般来说，我们的使用形式如下： 12345678910111213141516// 无参构造List&lt;String&gt; list = new ArrayList&lt;&gt;();// 连续添加10个元素list.add(&quot;a&quot;);list.add(&quot;b&quot;);list.add(&quot;c&quot;);list.add(&quot;d&quot;);list.add(&quot;e&quot;);list.add(&quot;f&quot;);list.add(&quot;g&quot;);list.add(&quot;h&quot;);list.add(&quot;i&quot;);list.add(&quot;j&quot;);// 添加第11个元素list.add(&quot;k&quot;);// do other 这样使用似乎没有任何问题，但这却不是一个匠心程序员该写出来的代码。 为什么这么说呢？我们知道ArrayList底层是动态数组，那这个数组什么时候进行动态呢？换句话说，数组什么时候会进行扩容？又扩容到多少呢？ 以上代码执行完后到底有没有进行扩容？这些都是问题，让我们带着这些问题来看下面的源码。 源码详解成员变量1234567891011121314151617181920212223242526272829303132333435363738/** * 序列化ID */private static final long serialVersionUID = 8683452581122892189L;/** * 默认初始容量 */private static final int DEFAULT_CAPACITY = 10;/** * 用于空ArrayList实例的共享空数组实例 */private static final Object[] EMPTY_ELEMENTDATA = {};/** * 共享的空数组实例，用于默认大小的空实例。 * 将该成员变量与EMPTY_ELEMENTDATA区分开来，以了解添加第一个元素时需要填充多少。 */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};/** * 存储ArrayList的元素的数组缓冲区。ArrayList的容量是此数组缓冲区的长度。 * 添加第一个元素时，任何具有elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA的空ArrayList都将扩展为DEFAULT_CAPACITY。 * 非私有成员以简化嵌套类访问。 */transient Object[] elementData;/** * ArrayList的大小（它包含的元素个数）。 */private int size;/** * 分配的最大数组大小。某些VM在数组中保留一些标头字。 * 尝试分配更大的数组可能会导致OutOfMemoryError：请求的数组大小超出VM限制。 */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 构造器无参构造构造一个初始容量为10的空列表。将DEFAULTCAPACITY_EMPTY_ELEMENTDATA空列表赋给存储元素的elementData数组缓冲区。 123public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;} 有参构造1、 构造一个具有指定初始容量的空列表。入参initialCapacity为列表的指定初始容量，如果为负数则抛出IllegalArgumentException异常。 123456789101112public ArrayList(int initialCapacity) { if (initialCapacity &gt; 0) { // 创建initialCapacity大小的Object类数组。 this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { // 指定容量为0，赋值静态空数组成员变量。 this.elementData = EMPTY_ELEMENTDATA; } else { // 负数抛出异常。 throw new IllegalArgumentException(&quot;Illegal Capacity: &quot; + initialCapacity); }} 2、 构造一个包含指定集合元素的列表，其顺序由集合的迭代器返回。入参c集合中的元素将被放入此列表，如果集合为null则抛出NullPointerException异常。 12345678910111213public ArrayList(Collection&lt;? extends E&gt; c) { // 集合转数组赋值给elementData elementData = c.toArray(); // 集合元素个数不为0。 if ((size = elementData.length) != 0) { // c.toArray方法返回的可能不是Object[]数组，此处判断如果不为Object[]类型则转换成Object[]类型。 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // 赋值静态空数组成员变量。 this.elementData = EMPTY_ELEMENTDATA; }} 数组拷贝方法由于ArrayList底层使用数组进行元素存储，其很多实现都是对数组进行直接操作。所以在看其它方法之前，很有必要先弄懂一些数组的方法。 java.util.Arrays是JDK提供的一个数组工具类，在ArrayList中大量使用了它的一个静态方法： 123456789101112131415161718192021222324252627282930313233343536373839/** * 数组拷贝 * @param original 待拷贝数组 * @param newLength 拷贝后新数组的长度 */public static &lt;T&gt; T[] copyOf(T[] original, int newLength) { return (T[]) copyOf(original, newLength, original.getClass());}/** * @param original 待拷贝数组 * @param newLength 拷贝后新数组的长度 * @param newType 数组元素类型 */public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) { @SuppressWarnings(&quot;unchecked&quot;) // 传入的newType类型是否是Object类型，是则创建Object数组，否则创建指定类型数组。 T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); // native方法 System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); // 返回创建的新长度的数组 return copy;}/** * 将src数组中srcPos索引及其之后的length个元素分别拷贝至dest数组中destPos索引及其之后的length个位置上。 * * @param src 源数组 * @param srcPos 源数组拷贝开始位置索引 * @param dest 目标数组 * @param destPos 目标数组拷贝开始位置索引 * @param length 拷贝的长度 */public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 插入元素ArrayList提供了两个重载的add插入方法。第一个是将指定元素添加至列表末尾；第二个是将指定元素添加至指定位置；同时还提供了两个重载的addAll方法，用来批量插入。 插入至列表末尾源码如下： 12345public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;} 看到这里我们可以对使用分析中的示例代码进行分析了： 首先使用new关键字调用无参构造器初始化一个ArrayList集合对象，我们知道其实质是将DEFAULTCAPACITY_EMPTY_ELEMENTDATA空列表赋给存储元素的elementData数组缓冲区。创建出的list对象的size成员变量初始化为0，然后调用list对象的add方法添加元素。 第一次调用：list.add(&quot;a&quot;); 在add方法中首先调用ensureCapacityInternal方法，确保内部容量，然后将传入的元素赋值给elementData数据域末尾。最后返回true。 确保内部容量ensureCapacityInternal方法源码如下： 123private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));} 第一次调用add方法时：elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA（构造器中初始化），minCapacity = size + 1（其值为1）。 调用calculateCapacity(elementData, minCapacity)方法计算容量： 1234567private static int calculateCapacity(Object[] elementData, int minCapacity) { // new ArrayList&lt;&gt;() 时，初始化为 elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity;} 此时elementData等于DEFAULTCAPACITY_EMPTY_ELEMENTDATA，返回DEFAULT_CAPACITY（其值为10）和minCapacity（其值为1）中较大的值，即返回10。 随即调用了ensureExplicitCapacity(10)方法： 1234567private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);} 首先增加当前集合的修改次数。然后判断计算出的容量是否超出了当前elementData数组长度，如果超过则进行grow扩容。 在第一次调用add方法时显然超过了，进行扩容： 12345678910111213141516private void grow(int minCapacity) { // overflow-conscious code // 旧的容量 int oldCapacity = elementData.length; // 新容量为原来的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) // 新容量小于传入的计算出的容量，则新容量为传入容量。 newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) // 新容量超过了最大值，则计算最大容量 newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: // 数组内容拷贝 elementData = Arrays.copyOf(elementData, newCapacity);} 扩容流程为： 获取旧容量oldCapacity； 计算新容量，利用位运算（速度远超整除运算）得到旧容量的一半再加上旧容量，即扩容1.5倍； 检查新容量是否小于传入的计算容量minCapacity，如果小于，则将传入的容量作为新容量； 检查得到的新容量是否大于ArrayList定义的所能容纳的最大容量：Integer,MAX_VALUE - 8； 如果大于，则调用hugeCapacity(minCapacity)计算最大容量：如果minCapacity大于Integer.MAX_VALUE - 8，则最大容量为Integer.MAX_VALUE，否则为Integer.MAX_VALUE - 8。 最后调用Arrays.copyOf(elementData, newCapacity)进行数组拷贝，得到一个以新容量为长度的数组对象并赋值给elementData。 第一次调用add方法时，旧容量oldCapacity = 0，通过位运算计算出的新容量也为0，所以最后新容量newCapacity = minCapacity，等于10。 所以我们使用new关键字调用无参构造器创建ArrayList对象时，实际上只初始化了一个空数组，在第一次调用add方法时才会进行空数组的扩容。 扩容完成后，elementData数组容量充足，可以往其末尾添加元素： 1elementData[size++] = e; 像使用分析中的示例代码一样，我们不断地向其中添加元素，当添加的元素个数不超过10时，ensureExplicitCapacity(int minCapacity)方法判断minCapacity - elementData.length始终小于0（经过第一次扩容后elementData.length的值为10），不会进行grow扩容; 而当添加至第11个元素k时，情况发生变化： calculateCapacity(elementData, minCapacity)方法直接返回minCapacity = 11； 然后调用ensureExplicitCapacity(int minCapacity)方法，此时elementData数组长度为10，minCapacity - elementData.length大于0，将再次进行grow扩容。 而扩容的流程我们知道，会调用Arrays.copyOf(elementData, newCapacity)方法进行数组拷贝，会有性能损耗。 所以，具有匠心的代码应该像下面这样： 12345678910111213141516// 指定初始容量的构造List&lt;String&gt; list = new ArrayList&lt;&gt;(11);// 连续添加10个元素list.add(&quot;a&quot;);list.add(&quot;b&quot;);list.add(&quot;c&quot;);list.add(&quot;d&quot;);list.add(&quot;e&quot;);list.add(&quot;f&quot;);list.add(&quot;g&quot;);list.add(&quot;h&quot;);list.add(&quot;i&quot;);list.add(&quot;j&quot;);// 添加第11个元素list.add(&quot;k&quot;);// do other 调用指定初始容量的构造器，在创建list对象时就会对elementData数组进行初始化，而不是在第一次调用add方法时。 所以如果能提前预估到集合容量，尽量提前指定容量，避免频繁的扩容带来的性能损耗。 根据使用场景，如果集合的数据量不好预估，且只会对其进行增删操作，则不建议使用ArrayList集合，而是建议使用LinkedList集合。 插入至指定位置源码如下： 1234567891011121314151617/** * @param index 待插入元素的指定的位置的索引 * @param element 待插入的元素 */public void add(int index, E element) { // 校验索引是否越界 rangeCheckForAdd(index); // 确保容量，修改modCount值 ensureCapacityInternal(size + 1); // Increments modCount!! // 数组拷贝：将[index,size)索引区间的元素整体向后移动一个单位，将集合的`index`位置留空。 System.arraycopy(elementData, index, elementData, index + 1, size - index); // 给index索引位置赋值为待插入元素 elementData[index] = element; // 集合大小增加 size++;} 将一个集合全部元素插入至当前集合末尾源码如下： 1234567891011121314public boolean addAll(Collection&lt;? extends E&gt; c) { // 集合转数组 Object[] a = c.toArray(); // 待添加元素个数 int numNew = a.length; // 确保容量 ensureCapacityInternal(size + numNew); // Increments modCount // 数组拷贝 System.arraycopy(a, 0, elementData, size, numNew); // 集合大小增加 size += numNew; // 传入集合无元素则返回false，否则返回true。 return numNew != 0;} 首先将传入的集合c转为Object[]对象数组，调用Collection的toArray()方法，不管是哪种集合的实现，最终都会返回一个数组。以下是ArrayList类的实现： 123public Object[] toArray() { return Arrays.copyOf(elementData, size);} 调用工具类的方法Arrays.copyOf方法进行数组拷贝，返回一个Object[]数组。 从当前集合指定索引位置开始，将一个集合全部元素插入源码如下： 123456789101112131415161718192021222324252627/** * * @param index 指定索引 * @param c 待插入集合 */public boolean addAll(int index, Collection&lt;? extends E&gt; c) { // 校验索引是否越界 rangeCheckForAdd(index); // 集合转Object数组 Object[] a = c.toArray(); // 待插入集合元素个数 int numNew = a.length; // 确保容量 ensureCapacityInternal(size + numNew); // Increments modCount // 需要移动的元素个数 int numMoved = size - index; if (numMoved &gt; 0) // 不是从末尾添加，则将[index,size)索引上的元素整体向后移动numMoved个单位。 System.arraycopy(elementData, index, elementData, index + numNew, numMoved); // Object数组拷贝至elementData System.arraycopy(a, 0, elementData, index, numNew); // 集合大小增加 size += numNew; // 传入集合无元素则返回false，否则返回true。 return numNew != 0;} 删除元素删除集合中的元素有多种情况：删除指定索引位置元素/删除指定元素/删除指定索引范围内的元素/删除全部元素/指定条件删除（Java8新增）等。 删除指定索引位置元素源码如下： 12345678910111213141516171819202122/** * 删除指定索引位置的元素 * @param index 指定索引 */public E remove(int index) { // 校验索引是否越界 rangeCheck(index); // 修改次数增加 modCount++; // 获取旧的index索引位置元素值 E oldValue = elementData(index); // 计算需要移动的元素个数 int numMoved = size - index - 1; if (numMoved &gt; 0) // 移动元素：[index+1,size)索引区间的元素整体向前移动一个单位。 System.arraycopy(elementData, index+1, elementData, index, numMoved); // 清除末尾索引原有的引用，减小集合大小 elementData[--size] = null; // clear to let GC do its work // 返回被删除的元素值 return oldValue;} 为什么判断size - index - 1 &gt; 0？ 答：集合大小size是从1开始计算，而数组下标索引index是从0开始计算。 删除指定元素由于ArrayList集合中的元素可以重复，指定的元素可能在集合中出现多次，所以该方法删除的是指定元素在集合中第一次出现位置的元素。 源码如下： 123456789101112131415161718192021/** * @param o 指定元素 */public boolean remove(Object o) { if (o == null) { // 指定元素为null：==运算符比较 for (int index = 0; index &lt; size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { // 非null：equals方法比较 for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false;} fori循环是从索引为0开始遍历，所以删除的是具有最低索引的元素。 我们来看下fastRemove(index);的实现： 123456789101112131415/** * @param index 指定索引 */private void fastRemove(int index) { // 修改次数增加 modCount++; // 计算需要移动的元素个数 int numMoved = size - index - 1; if (numMoved &gt; 0) // 移动元素：[index+1,size)索引区间元素整体向前移动一位。 System.arraycopy(elementData, index+1, elementData, index, numMoved); // 清除末尾索引原有的引用，减小集合大小 elementData[--size] = null; // clear to let GC do its work} 删除指定索引范围内的元素该方法为ArrayList类中受保护的方法，外部无法直接进行调用。由JDK集合框架内部进行使用。 源码如下： 123456789101112131415161718192021222324/** * 约定 fromIndex 小于 toIndex，否则，进行元素移动时会出现索引越界。 * @param fromIndex 开始索引 * @param toIndex 结束索引 */protected void removeRange(int fromIndex, int toIndex) { // 修改次数增加 modCount++; // 计算需要移动的元素个数 int numMoved = size - toIndex; // 移动元素：[toIndex,size)索引区间元素整体向前移动toIndex - fromIndex个单位。 System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work // 计算新的数组大小 int newSize = size - (toIndex-fromIndex); for (int i = newSize; i &lt; size; i++) { // 清除删除的索引位置原有的引用 elementData[i] = null; } // 指定新的数组大小 size = newSize;} 删除全部元素有两种情况：一种是删除当前集合全部元素，方法为clear()；另一种是从当前集合中删除指定集合中包含的所有元素，方法为removeAll(Collection&lt;?&gt; c)。 clear()方法源码如下： 1234567891011public void clear() { // 修改次数增加 modCount++; // clear to let GC do its work // 清除所有索引位置的引用对象 for (int i = 0; i &lt; size; i++) elementData[i] = null; // 集合大小置0 size = 0;} removeAll(Collection&lt;?&gt; c)方法源码如下： 12345public boolean removeAll(Collection&lt;?&gt; c) { // 非空 Objects.requireNonNull(c); return batchRemove(c, false);} 首先，调用Java8提供的Objects.requireNonNull(c);方法对传入的集合c进行非空校验。 然后，调用私有方法batchRemove(c, false)，传入集合c和布尔值false： 12345678910111213141516171819202122232425262728private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) { final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try { for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; } finally { // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) { System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; } if (w != size) { // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; } } return modified;} 我们来写一个简单的demo来看下其过程： 12345678910111213141516171819...... List&lt;Integer&gt; removeList = new ArrayList&lt;&gt;(); removeList.add(1); removeList.add(2); removeList.add(3); removeList.add(4); removeList.add(5); removeList.add(6); List&lt;Integer&gt; beRemovedList = new ArrayList&lt;&gt;(); beRemovedList.add(3); beRemovedList.add(4); beRemovedList.add(6); System.out.println(removeList); System.out.println(beRemovedList); removeList.removeAll(beRemovedList); System.out.println(removeList);...... 创建一个removeList集合并初始化六个元素，再创建一个待删除的beRemovedList集合并初始化三个元素（在removeList中）。 下面我们来分析removeAll方法的具体执行流程： 当我们调用removeList.removeAll(beRemovedList);时，会先对beRemovedList进行非空校验，然后调用batchRemove方法： 1、使用局部最终变量elementData指向当前集合（removeList）的引用： 1final Object[] elementData = this.elementData; 2、定义两个索引并初始化为0，以及定义一个布尔值用来记录当前集合是否被修改： 12int r = 0, w = 0;boolean modified = false; 3、从r到size进行遍历，判断传入的集合c是否包含r位置的元素。 123for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; 我们对着我们的demo程序进行分析，c = {3, 4, 6}，elementData = {1, 2, 3, 4, 5, 6}，size=6，complement = false。 每次循环r的值增一，循环结束的条件为r &lt; size不成立，即当r = size时循环结束。 第一次循环：r = 0，elementData[r] = 1，c.contains(1) = false。if条件成立，w = 0。将elementData[r]赋值给elementData[w++]：即将当前不在c集合中的元素赋值到集合的第0位置，随后w增一。此时elementData的第0位置元素为：1。 第二次循环：r = 1，elementData[r] = 2，c.contains(2) = false。if条件成立，w = 1。将elementData[r]赋值给elementData[w++]：即将当前不在c集合中的元素赋值到集合的第1位置，随后w增一。此时elementData的第1位置元素为：2。 第三次循环：r = 2，elementData[r] = 3，c.contains(3) = true。if条件不成立，w的值为2，不做任何操作。 第四次循环：r = 3，elementData[r] = 4，c.contains(4) = true。if条件不成立，w的值为2，不做任何操作。 第五次循环：r = 4，elementData[r] = 5，c.contains(5) = false。if条件成立，w = 2，将elementData[r]赋值给elementData[w++]：即将当前不在c集合中的元素赋值到集合的第2位置，随后w增一。此时elementData的第2位置元素为：5。 第六次循环：r = 5，elementData[r] = 6，c.contains(6) = true。if条件不成立，w的值为3，不做任何操作。 循环结束，w = 3，elementData = {1, 2, 5, ......}，r = 6。 接下来我们来看下finally块中的代码： 1234567891011121314// Preserve behavioral compatibility with AbstractCollection,// even if c.contains() throws.if (r != size) { System.arraycopy(elementData, r,elementData, w,size - r); w += size - r;}if (w != size) { // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true;} 对于我们的demo程序： 此时r = size，第一个if块不进入。 此时(w = 3) != (size = 6)，进入第二个if块，将索引从w到size - 1位置的元素置为null，释放对原来元素的引用。 接下来是一些收尾工作： 记录修改次数，修改（移除）了size - w个元素； 将集合大小设为w：为在for循环中给elementData域赋值的元素个数。 设置修改标记为true，此处是c集合中的元素全部从集合中删除。 最后，batchRemove方法返回modified布尔值：表示是否当前集合中删除了指定集合c中包含的所有元素。 修改元素修改方法只有一个：修改指定索引位置的元素为新的元素。 源码如下： 1234567891011121314/** * @param index 指定索引 * @param element 指定的新元素 */public E set(int index, E element) { // 校验索引是否越界 rangeCheck(index); // 获取index索引位置的旧元素 E oldValue = elementData(index); // 赋值为新的指定元素 elementData[index] = element; // 返回旧元素 return oldValue;} 查询元素由于ArrayList底层由elementData数组存储元素，所以支持按数组下标访问：即随机快速访问。其查询的时间复杂度为O(1)，这也是为什么ArrayList实现RandomAccess的原因：标记该类支持随机快速访问。 12345678910public E get(int index) { // 校验索引是否越界 rangeCheck(index); // 按数组下标取值 return elementData(index);}E elementData(int index) { return (E) elementData[index];} 其它方法clone方法传送门 size方法获取集合大小：返回成员变量size。 isEmpty方法判断集合是否为空集合：返回size == 0得到的值。 indexOf方法返回指定元素在当前集合中第一次出现的位置索引。如果当前集合中不包含此元素，返回-1。 123456789101112131415public int indexOf(Object o) { if (o == null) { // 指定元素为null：使用==运算符比较 for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; } else { // 非null：使用equals方法比较 for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; } // 未找到，返回-1。 return -1;} 从前往后遍历，null值使用==运算符进行比较，其它对象使用equals方法比较。 lastIndexOf方法返回指定元素在当前集合中最后一次出现的位置索引。如果当前集合中不包含此元素，返回-1。 123456789101112public int lastIndexOf(Object o) { if (o == null) { for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; } else { for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; } return -1;} 从后往前遍历，null值使用==运算符进行比较，其它对象使用equals方法比较。 contains方法判断指定元素是否在集合中。调用的是indexOf(o)方法，判断其返回值是否大于等于0，等于-1说明不在集合中。 iterator方法该方法是迭代器设计模式的体现。使用了new关键字创建了一个私有内部类Itr对象。 123456789101112public Iterator&lt;E&gt; iterator() { return new Itr();}private class Itr implements Iterator&lt;E&gt; { int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; Itr() {} ......} 私有内部类Itr实现了java.util.Iterator迭代器接口。其成员变量有三个： cursor：游标（下一个要返回元素的索引）。 lastRet：初始化为-1，最后一个被返回元素的索引；如果集合中本来没有任何元素则返回-1。 expectedModCount：期望的修改次数。初始化为当前集合的modCount。 只有一个无参构造函数。 我们知道使用迭代器对ArrayList进行遍历的写法如下： 123456789101112List&lt;Integer&gt; iteratorList = new ArrayList&lt;&gt;();iteratorList.add(1);iteratorList.add(2);iteratorList.add(3);iteratorList.add(4);iteratorList.add(5);iteratorList.add(6);Iterator&lt;Integer&gt; iterator = iteratorList.iterator();while (iterator.hasNext()) { Integer next = iterator.next(); System.out.println(next);} 其中关键的两个方法为：hasNext()和next()。接下来我们着重来看下这两个方法。 首先调用iteratorList对象的iterator()方法得到一个迭代器对象，经过上面的分析我们可知这实际是一个Itr对象。 其hasNext()方法源码如下： 123public boolean hasNext() { return cursor != size;} 返回当前游标cursor是否不等于集合大小size。如果不等于size，说明还有下一个元素。可继续迭代。否则迭代完成。 next()方法源码如下： 123456789101112131415161718public E next() { // fail-fast机制 checkForComodification(); // 获取当前游标 int i = cursor; // 当前游标超过集合大小则抛出异常 if (i &gt;= size) throw new NoSuchElementException(); // 获取存储元素的数组对象 Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) // 当前游标超出数组长度：与hasNext方法中的判断出现了矛盾。并发修改：fail-fast机制 throw new ConcurrentModificationException(); // 校验通过，游标加一 cursor = i + 1; // 最后一个被返回元素的索引赋值为旧的游标i，返回旧的游标对应的元素。 return (E) elementData[lastRet = i];} 在Itr类中使用this指代的是当前Itr对象，使用ArrayList.this指代的是集合对象。 为什么ArrayList使用迭代器遍历没有普通fori循环遍历效率高？ 答：经过以上代码的分析，原因显而易见：使用迭代器遍历，首先需要使用new关键字创建一个Itr对象，创建对象需要耗时（一次）；其次，中间有多次条件判断并且有局部变量产生，以及一个加1操作，这也需要耗费时间（多次：每次调用next方法）。 Demo实战123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package com.sunchaser.javase.collect;import java.util.ArrayList;import java.util.Iterator;import java.util.List;/** * @author sunchaser * @date 2020/5/2 * @since 1.0 */public class ArrayListTest { public static void main(String[] args) { // 插入元素 ArrayList&lt;String&gt; addList = new ArrayList&lt;&gt;(); // 集合尾部插入 addList.add(&quot;测试1&quot;); System.out.println(addList); // 集合指定索引位置插入 addList.add(1,&quot;指定位置1&quot;); System.out.println(addList); // 集合指定索引位置插入：索引位置无元素且不是尾部：索引越界。 // addList.add(10,&quot;指定位置2&quot;); // 待插入集合初始化 ArrayList&lt;String&gt; toBeAddList = new ArrayList&lt;&gt;(); toBeAddList.add(&quot;测试2&quot;); toBeAddList.add(&quot;测试3&quot;); toBeAddList.add(&quot;测试4&quot;); // 待指定索引位置插入集合初始化 ArrayList&lt;String&gt; toBeAddIndexList = new ArrayList&lt;&gt;(); toBeAddIndexList.add(&quot;测试5&quot;); toBeAddIndexList.add(&quot;测试6&quot;); // 将一个集合全部元素插入至当前集合末尾 addList.addAll(toBeAddList); System.out.println(addList); // 从当前集合指定索引位置开始，将一个集合全部元素插入 addList.addAll(1,toBeAddIndexList); System.out.println(addList); // 删除元素 List&lt;Integer&gt; removeList = new ArrayList&lt;&gt;(); removeList.add(1); removeList.add(2); removeList.add(6); removeList.add(3); removeList.add(4); removeList.add(5); removeList.add(6); removeList.add(4); System.out.println(removeList); // 删除指定索引位置元素 removeList.remove(1); System.out.println(removeList); // 删除指定元素在集合中第一次出现位置的元素 removeList.remove(new Integer(6)); System.out.println(removeList); // 待删除元素集合 List&lt;Integer&gt; beRemovedList = new ArrayList&lt;&gt;(); beRemovedList.add(2); beRemovedList.add(3); beRemovedList.add(6); System.out.println(removeList); System.out.println(beRemovedList); // 从当前集合中删除指定集合中包含的所有元素 boolean b = removeList.removeAll(beRemovedList); System.out.println(b); System.out.println(removeList); // 删除全部元素 removeList.clear(); System.out.println(removeList); // 修改元素集合初始化 ArrayList&lt;Integer&gt; operatorList = new ArrayList&lt;&gt;(); operatorList.add(1); operatorList.add(2); operatorList.add(3); operatorList.add(2); operatorList.add(1); System.out.println(operatorList); // 修改元素，将索引为1的元素修改为6 operatorList.set(1,6); System.out.println(operatorList); // 查询元素 Integer integer = operatorList.get(1); System.out.println(integer); // 克隆 Object clone = operatorList.clone(); System.out.println(clone); // size System.out.println(operatorList.size()); // isEmpty System.out.println(operatorList.isEmpty()); // indexOf System.out.println(operatorList.indexOf(1)); // lastIndexOf System.out.println(operatorList.lastIndexOf(1)); // contains System.out.println(operatorList.contains(3)); System.out.println(operatorList.contains(4)); // 迭代器设计模式 List&lt;Integer&gt; iteratorList = new ArrayList&lt;&gt;(); iteratorList.add(1); iteratorList.add(2); iteratorList.add(3); iteratorList.add(4); iteratorList.add(5); iteratorList.add(6); Iterator&lt;Integer&gt; iterator = iteratorList.iterator(); while (iterator.hasNext()) { Integer next = iterator.next(); System.out.println(next); } // 普通fori循环遍历 for (int i = 0,size = iteratorList.size(); i &lt; size; i++) { System.out.println(iteratorList.get(i)); } // forEach遍历，底层实现为迭代器 for (Integer i : iteratorList) { System.out.println(i); } }} 总结ArrayList集合是我们在工作中用到的最多的集合，我们必须熟练掌握其特性。 通过上面的源码分析可知，ArrayList集合查找效率非常高。顺序添加元素至末尾效率也很高，但需要确保不扩容，否则进行数组拷贝很耗时。所以我们在创建ArrayList对象时，如果可以预估到集合中元素个数，最好指定初始容量，以避免在插入时扩容带来的性能损耗。 本文Demo实战代码见：传送门","link":"/2020/06/01/javase/base/arraylist/"},{"title":"JDK源码解析之AbstractSequentialList","text":"简介AbstractSequentialList类是一个抽象类，它继承了AbstractList抽象类。同样提供了有序集合的骨架实现，但是它是最大程度地减少了支持顺序访问数据的实现类所需的工作。如果需要随机访问数据，优先使用AbstractList抽象类。 从某种意义上说，该类与AbstractList抽象类相反，该类实现了随机访问方法，而不是像AbstractList抽象类一样抛出异常。 特性该抽象类提供了有序集合的骨架实现。让实现类支持顺序访问。 如果要实现集合，只需继承该类并实现该类的listIterator()抽象方法和AbstractCollection#size()方法； 如果要实现不可修改的集合，只需继承该类并实现列表迭代器ListIterator的hasNext/next/hasPrevious/previous/index方法。 如果要实现可修改的集合，在实现不可修改集合的基础上，需要另外实现列表迭代器的set方法；对于可变大小的集合，还需要实现列表迭代器的remove和add方法。 此外，实现类同样应该遵循Collection接口中提出的规范：必须提供两个标准构造器：void无参构造器和带Collection类型的单个参数的构造器。 源码详解构造器12protected AbstractSequentialList() {} 只有一个使用protected修饰符修饰的无参构造器。说明该抽象类不允许外部直接实例化使用，因为它只是一个骨架实现，并不提供顺序访问集合的完整功能。 抽象方法1public abstract ListIterator&lt;E&gt; listIterator(int index); 按正确的顺序返回此列表的列表迭代器，其开始索引为入参index。该类中的其它方法都是基于此抽象方法返回的列表迭代器实现的。 已实现方法所有的已实现方法都传入了索引值，对于客户端而言，看似是随机访问，但内部实现却是顺序访问。 获取指定索引位置的元素1234567public E get(int index) { try { return listIterator(index).next(); } catch (NoSuchElementException exc) { throw new IndexOutOfBoundsException(&quot;Index: &quot;+index); }} 获取index索引开始的列表迭代器后调用其next方法获取index索引位置元素返回。 用指定元素替换指定索引位置的元素12345678910public E set(int index, E element) { try { ListIterator&lt;E&gt; e = listIterator(index); E oldVal = e.next(); e.set(element); return oldVal; } catch (NoSuchElementException exc) { throw new IndexOutOfBoundsException(&quot;Index: &quot;+index); }} 获取index索引开始的列表迭代器后调用其next方法获取index索引位置的旧值，然后调用列表迭代器的set方法，覆盖next方法最后返回的index索引位置的元素，最后返回旧值。 在指定索引位置插入指定元素1234567public void add(int index, E element) { try { listIterator(index).add(element); } catch (NoSuchElementException exc) { throw new IndexOutOfBoundsException(&quot;Index: &quot;+index); }} 此实现会将当前位于index位置的元素（如果有的话）和后续所有元素右移一位（索引增一）。 首先获取index索引开始的列表迭代器，然后调用列表迭代器的add方法插入指定的元素。 所以列表迭代器必须实现add方法，否则该方法将抛出UnsupportedOperationException异常。 删除指定索引位置的元素12345678910public E remove(int index) { try { ListIterator&lt;E&gt; e = listIterator(index); E outCast = e.next(); e.remove(); return outCast; } catch (NoSuchElementException exc) { throw new IndexOutOfBoundsException(&quot;Index: &quot;+index); }} 此实现会将index索引位置后续所有元素左移一位（索引减一）。 首先获取index索引开始的列表迭代器，然后获取index索引位置的旧元素，再调用列表迭代器的remove方法删除元素，最后返回旧元素。 所以列表迭代器必须实现remove方法，否则该方法将抛出UnsupportedOperationException异常。 在指定索引位置插入指定集合1234567891011121314public boolean addAll(int index, Collection&lt;? extends E&gt; c) { try { boolean modified = false; ListIterator&lt;E&gt; e1 = listIterator(index); Iterator&lt;? extends E&gt; e2 = c.iterator(); while (e2.hasNext()) { e1.add(e2.next()); modified = true; } return modified; } catch (NoSuchElementException exc) { throw new IndexOutOfBoundsException(&quot;Index: &quot;+index); }} 此实现会将当前位于index索引位置及其后续所有元素右移，指定集合中的元素将以其迭代器返回的顺序显示在当前集合中。 分别获取当前集合的列表迭代器和指定集合的普通迭代器，迭代指定集合，依次将元素add至当前集合中。 所以列表迭代器必须实现add方法，否则该方法将抛出UnsupportedOperationException异常。 获取普通迭代器123public Iterator&lt;E&gt; iterator() { return listIterator();} 直接调用当前类的抽象方法listIterator()，返回列表迭代器。 总结该抽象类提供了顺序访问集合的骨架实现，是LinkedList集合的直接父类。所有实现依托于该类的listIterator()抽象方法。","link":"/2020/05/27/javase/base/abstract-sequential-list/"},{"title":"JDK源码解析之LinkedList","text":"前言LinkedList的底层实现是双向链表，在学习其源码之前，我们首先要搞懂链表的原理。 单链表简介单链表中的数据是以节点的形式来表示的，每个节点存储了当前节点的元素值（数据域）和下一个节点（后继节点）的地址值（指针域）。每个节点的内存空间可以是不连续的，它通过每个节点的指针域将各个节点连接起来。 每个节点只有一个指针域的链表称为单链表。如果想要遍历单链表，则必须从头节点开始迭代。 双向链表简介双向链表与单链表相比，它的每个节点在单链表的基础上还存储了上一个节点（前驱节点）的地址值。也就是说，我们从任一节点开始，都可以遍历整个链表。 循环链表简介单链表和双链表都可以构造成循环链表，只需将最后一个节点的后继结点指针域指向头节点，形成一个环。因此，从循环链表的任意一个节点开始，都可以遍历整个链表。 LinkedList简介LinkedList类是基于双向链表实现的，它继承了AbstractSequentialList顺序访问集合抽象模板类，实现了有序集合接口List和双端队列接口Deque。所以，LinkedList即可以作为集合使用，同时可以用作双端队列，还可以用作栈。这是一个非常优秀的实现类。 LinkedList特性由于LinkedList类继承自AbstractSequentialList抽象类，而AbstractSequentialList抽象类又继承自AbstractList抽象类。于是LinkedList类得到了AbstractList抽象类的modCount字段。基于该字段实现了fail-fast机制。 源码详解成员变量12345678910111213141516171819202122/** * 定义集合的大小 */transient int size = 0;/** * 指向双向链表第一个节点的引用 */transient Node&lt;E&gt; first;/** * 指向双向链表最后一个节点的引用 */transient Node&lt;E&gt; last;.../** * 序列化ID */private static final long serialVersionUID = 876323262645176354L; Node节点类1234567891011121314private static class Node&lt;E&gt; { // 数据域 E item; // 后继节点 Node&lt;E&gt; next; // 前驱节点 Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev; }} 构造器遵循了Collection接口的规范：提供了两个标准构造器：void无参构造器和带Collection类型的单个参数构造器。 12345678910111213/** * 无参构造器 */public LinkedList() {}/** * 带参构造器：构造一个包含指定集合中元素的链表，其顺序为指定集合迭代器返回的顺序 */public LinkedList(Collection&lt;? extends E&gt; c) { this(); addAll(c);} 无参构造器中没有任何操作。 带参构造器中首先调用了无参构造器，然后调用addAll(c)方法构造链表。 123public boolean addAll(Collection&lt;? extends E&gt; c) { return addAll(size, c);} 该addAll(c)方法是将指定集合c添加至此列表末尾，由于是在构造器中调用，所以size为初始值0。 我们来看下重载的addAll(size,c)方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public boolean addAll(int index, Collection&lt;? extends E&gt; c) { // 校验索引是否越界 checkPositionIndex(index); // 集合转Object数组 Object[] a = c.toArray(); // 计算数组长度 int numNew = a.length; if (numNew == 0) return false; // pred： 插入位置的前驱节点（索引：index - 1） // succ： 插入位置的后继节点（索引：index + 1） Node&lt;E&gt; pred, succ; if (index == size) { // 插入位置为末尾 // 后继节点为null succ = null; // 前驱节点为 last pred = last; } else { // 插入位置不在末尾，在链表中间 // 后继节点为 node(index) succ = node(index); // 前驱节点为后继节点succ的前驱节点 pred = succ.prev; } // 迭代Object数组a for (Object o : a) { // 强制类型转换 @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o; // 创建一个新的节点newNode：其前驱节点为pred，节点数据域为此次迭代元素e，后继节点为null Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) // 前驱节点为null：链表初始为空链表；新节点newNode为头节点 first = newNode; else // 前驱节点不为null：将pred的后继节点指向newNode pred.next = newNode; // 将前驱节点置为newNode，以便下次迭代链接节点。 pred = newNode; } // 迭代完成 if (succ == null) { // 后继节点为null：初始插入位置为链表末尾：将last置为最后一次迭代的pred，即为链表末尾元素。 last = pred; } else { // 后继节点不为null：从链表中间进行插入：将最后一次迭代的pred元素的后继节点指向succ。 pred.next = succ; // 将succ的前驱节点指向pred。 succ.prev = pred; } // 集合大小增加 size += numNew; // 修改次数增加 modCount++; return true;} 该方法是将指定集合插入至指定索引位置，指定索引位置的元素（如果有的话）和后续所有元素都将右移。 分为两种情况： 1、 从链表尾部插入 初始条件为： 初始链表为：[L,I,N] 指定索引位置：index：3 待插入元素集合：collection：[K,E,D] 插入位置的前驱节点：pred：N 插入位置的后继节点：succ：null 插入过程： 迭代开始： 待插入集合转数组：a：[K,E,D] 第一次迭代：创建新节点newNode，值为K，前驱节点pred为N，后继节点succ为null，将N的后继节点指向K，将前驱节点pred引用newNode:K。 第二次迭代：创建新节点newNode，值为E，前驱节点pred为K，后继节点succ为null，将K的后继节点指向E， 将前驱节点pred引用newNode:E。 第三次迭代：创建新节点newNode，值为D，前驱节点pred为E，后继节点succ为null，将E的后继节点指向D，将前驱节点pred引用newNode:D。 迭代完成。 此时后继节点succ仍指向null，前驱节点pred引用newNode:D，为链表末尾节点，将last引用置为pred。 集合大小增加了数组a的长度个；修改次数modCount增加。 2、 从链表中间插入 初始条件为： 初始链表为：[L,I,N,D] 指定索引位置：index：3 待插入元素集合：collection：[K,E] 插入位置的前驱节点：pred：N 插入位置的后继节点：succ：D 插入过程： 迭代开始： 待插入集合转数组：a：[K,E] 第一次迭代：创建新节点newNode，值为K，前驱节点pred为N，后继节点succ为D，将N的后继节点指向K，将前驱节点pred引用newNode:K。 第二次迭代：创建新节点newNode，值为E，前驱节点pred为K，后继节点succ为D，将K的后继节点指向E， 将前驱节点pred引用newNode:E。 迭代完成。 此时后继节点succ仍指向D，前驱节点pred引用newNode:E，last引用仍指向D。 将pred的后继节点指向D，将D的前驱节点指向E。 集合大小增加了数组a的长度个；修改次数modCount增加。 内部方法LinkedList类中提供了一些默认或私有方法用来将一个指定元素连接至整个链表。 连接指定元素作为头节点123456789101112131415161718private void linkFirst(E e) { // 获取链表头节点f final Node&lt;E&gt; f = first; // 创建一个新的节点，其数据域为e，后继节点为链表头节点f。 final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); // 链表头节点引用指向新节点 first = newNode; if (f == null) // 旧的头节点为null：原链表为空链表。将尾节点引用last也指向新节点。 last = newNode; else // 旧的头节点不为null：新节点将作为整个链表的新的头节点。将旧的头节点的前驱节点指向新节点。 f.prev = newNode; // 集合大小增加 size++; // 修改次数增加 modCount++;} 首先通过头节点引用first获取当前链表头节点f，然后创建一个新的Node节点newNode，其数据域为指定元素e，后继节点为当前链表头节点f； 然后将头节点引用first指向newNode，判断旧的头节点f是否为null，如果是，则原链表为空链表，将尾节点引用last指向newNode；否则，将旧的头节点f的前驱节点指向newNode。 连接指定元素作为尾节点123456789101112131415161718void linkLast(E e) { // 获取链表尾节点 final Node&lt;E&gt; l = last; // 创建一个新的节点，其数据域为e，前驱节点为链表尾节点l final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); // 链表尾节点引用执行新节点 last = newNode; if (l == null) // 旧的尾节点为null：原链表为空链表。将头节点引用也指向新节点。 first = newNode; else // 旧的尾节点不为null：新节点将作为整个链表的新的尾节点。将旧的尾节点的后继节点指向新节点。 l.next = newNode; // 集合大小增加 size++; // 修改次数增加 modCount++;} 首先通过尾节点引用last获取当前链表尾节点l，然后创建一个新的Node节点newNode，其数据域为指定元素e，前驱节点为当前链表尾节点l； 然后将尾节点引用last指向newNode，判断旧的尾节点l是否为null，如果是，则原链表为空链表，将头节点引用first指向newNode；否则，将旧的尾节点l的后继节点指向newNode。 在指定节点之前连接指定元素12345678910111213141516171819202122/** * 约定指定节点succ不为null */void linkBefore(E e, Node&lt;E&gt; succ) { // assert succ != null; // 获取指定节点的前驱节点 final Node&lt;E&gt; pred = succ.prev; // 创建一个新的节点，其数据域为e，前驱节点为指定节点的前驱节点，后继节点为指定节点。 final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); // 指定节点的前驱节点指向新节点 succ.prev = newNode; if (pred == null) // 指定节点的旧的前驱节点为null：指定节点为原链表的头节点。新节点将作为新的头节点。 first = newNode; else // 指定节点的旧的前驱节点不为null：将指定节点的旧的前驱节点的后继节点指向新节点。 pred.next = newNode; // 集合大小增加 size++; // 修改次数增加 modCount++;} 约定指定节点succ非空，否则将导致NPE问题。 首先获取指定节点的前驱节点pred，然后创建一个新的Node节点newNode，其前驱节点为pred，数据域为指定元素e，后继节点为指定节点succ。 将指定节点succ的前驱节点指向newNode，判断指定节点succ的旧的前驱节点pred是否为null，如果是，则指定节点succ为原链表的头节点，将头节点引用first指向newNode；否则，将旧的前驱节点pred的后继节点指向newNode。 取消头节点的连接123456789101112131415161718192021222324252627/** * 约定指定节点f为链表头节点且不为null */private E unlinkFirst(Node&lt;E&gt; f) { // assert f == first &amp;&amp; f != null; // 获取头节点的元素值 final E element = f.item; // 获取头节点的后继节点：即将成为新的头节点。 final Node&lt;E&gt; next = f.next; // 将原头节点的数据域和后继节点置为null。解除对其它对象的引用，便于GC清理。 f.item = null; f.next = null; // help GC // 将头节点引用指向next first = next; if (next == null) // next为null：原链表只有一个节点。将尾节点引用置为null。 last = null; else // next不为null：将next的前驱节点置为null。取消对原头节点的引用，便于GC清理。 next.prev = null; // 集合大小减少 size--; // 修改次数增加 modCount++; // 返回被剔除的节点元素值。 return element;} 约定指定节点为链表的头节点且非空，否则将导致NPE问题。 获取头节点的数据域值element和后继节点next，将头节点的数据域和后继节点置为null。解除对原对象的引用，便于GC清理。 然后将头节点引用first指向next，判断next是否为null，如果是，则原链表只有一个节点，将尾节点引用last置为null；否则，将next节点的前驱节点置为null，取消对原链表头节点的引用。 取消尾节点的连接123456789101112131415161718192021222324252627/** * 约定指定节点l为链表尾节点且不为null */private E unlinkLast(Node&lt;E&gt; l) { // assert l == last &amp;&amp; l != null; // 获取尾节点的元素值 final E element = l.item; // 获取尾节点的前驱节点：即将成为新的尾节点。 final Node&lt;E&gt; prev = l.prev; // 将原尾节点的数据域和前驱节点置为null。解除对其它对象的引用，便于GC清理。 l.item = null; l.prev = null; // help GC // 将尾节点引用指向prev last = prev; if (prev == null) // prev为null：原链表只有一个节点。将头节点引用置为null。 first = null; else // prev不为null：将prev的后继节点置为null。取消对原尾节点的引用，便于GC清理。 prev.next = null; // 集合大小减少 size--; // 修改次数增加 modCount++; // 返回被剔除的节点元素值 return element;} 约定指定节点为链表的尾节点且非空，否则将导致NPE问题。 获取尾节点的数据域值element和前驱节点prev，将尾节点的数据域和前驱节点置为null。解除对原对象的引用，便于GC清理。 然后将尾节点引用last指向prev，判断prev是否为null，如果是，则原链表只有一个节点，将头节点引用first置为null；否则，将prev节点的后继节点置为null，取消对原链表尾节点的引用。 取消指定节点的连接1234567891011121314151617181920212223242526272829303132333435363738394041/** * 约定指定节点x不为null */E unlink(Node&lt;E&gt; x) { // assert x != null; // 获取指定节点x的数据域元素 final E element = x.item; // 获取指定节点x的后继节点 final Node&lt;E&gt; next = x.next; // 获取指定节点x的前驱节点 final Node&lt;E&gt; prev = x.prev; if (prev == null) { // 指定节点的前驱节点为null：指定节点为原链表头节点。指定节点的后继节点将作为新的头节点。 first = next; } else { // 否则，将指定节点的前驱节点的后继节点指向指定节点的后继节点。 prev.next = next; // 指定节点的前驱节点置为null x.prev = null; } if (next == null) { // 指定节点的后继节点为null：指定节点为原链表尾节点。指定节点的前驱节点将作为新的尾节点。 last = prev; } else { // 否则，将指定节点的后继节点的前驱节点指向指定节点的前驱节点。 next.prev = prev; // 指定节点的后继节点置为null x.next = null; } // 指定节点的数据域元素置为null x.item = null; // 集合大小减少 size--; // 修改次数增加 modCount++; // 返回被剔除的节点元素值 return element;} 约定指定节点x非空，否则将导致NPE问题。 分别获取指定节点x的数据域元素element、后继节点next和前驱节点prev。 如果前驱节点prev为null，则在原链表中，指定节点x为头节点，指定节点的后继节点next将作为新的头节点：将first引用指向后继节点next；否则将前驱节点prev的后继节点指向next，将指定元素x的前驱节点置为null。 如果后继节点next为null，则在原链表中，指定节点x为尾节点，指定节点的前驱节点prev将作为新的尾节点：将last引用指向前驱节点prev；否则将后继节点next的前驱节点指向prev，将指定元素x的后继节点置为null。 最后将指定节点x的数据域置为null，解除对象引用，便于GC清理。 获取指定索引位置的Node节点1234567891011121314151617181920212223242526/** * 约定指定索引合法 */Node&lt;E&gt; node(int index) { // assert isElementIndex(index); // 二分法 if (index &lt; (size &gt;&gt; 1)) { // 指定索引在[0,size/2)之间 // 获取头节点x Node&lt;E&gt; x = first; // 从0迭代到index，每次迭代将x赋值为x的后继节点 for (int i = 0; i &lt; index; i++) x = x.next; // 迭代完成，x即为指定索引位置的节点 return x; } else { // 指定索引在[size/2,size]之间 // 获取尾节点 Node&lt;E&gt; x = last; // 从size-1迭代到index，每次迭代将x赋值为x的前驱节点 for (int i = size - 1; i &gt; index; i--) x = x.prev; // 迭代完成，x即为指定索引位置的节点 return x; }} 约定指定索引不会产生越界。 采用二分法的思想优化时间复杂度，如果指定索引index在[0,size/2)范围内，则从0迭代至index - 1，迭代之前获取头节点x，每次迭代将x赋值为x的后继节点，迭代完成时，x即为指定索引index位置的元素；如果指定索引index在[size/2,size)之间，则从size - 1迭代至index + 1，迭代之前获取尾节点x，每次迭代将x赋值为x的前驱节点，迭代完成时，x即为指定索引index位置的元素。 集合方法LinkedList继承了AbstractSequentialList有序集合顺序访问抽象模板类。对集合方法进行了实现，可以作为集合使用。 添加指定元素至集合末尾12345public boolean add(E e) { // 调用内部方法linkLast(e) linkLast(e); return true;} 该方法的最初来源是Collection接口中定义的add(E e)方法。 AbstractSequentialList抽象类继承了AbstractList抽象类，在AbstractList抽象类中已经实现了add(E e)方法。它只要求子类去实现add(int index,E e)方法即可实现add(E e)。在LinkedList类中已经提供了add(int index,E e)方法的实现，它为什么还要重写add(E e)方法呢？ 理解：LinkedList作为一个优秀的实现类，它继承/实现了多个接口。在编码开发时，我们经常面向接口编程，例如：List&lt;String&gt; list = new LinkedList&lt;&gt;()。LinkedList类的对象会向上转型为List类。对于实例对象list来说，此时它是一个List，它所具有的方法是List接口中定义的方法，而不是LinkedList类中的方法，所以当我们调用list.add(E e)时，实际上调用的是List类中定义的add(E e)方法，而它的实现是在LinkedList类中。 也就是说，当我们想把LinkedList作为List集合使用时，我们可以写成：List&lt;String&gt; list = new LinkedList&lt;&gt;()。而当我们想把LinkedList当做Queue队列使用时，我们可以写成Queue&lt;String&gt; queue = new LinkedList&lt;&gt;()。它可以向上转型成任意的父接口（或父接口的父接口），向上转型后，实例对象只拥有转型后的接口中所定义的方法。所以，LinkedList类中对所有父接口中定义的方法都进行了实现，以便向上转型使用。 这体现了Java的多态机制。 直接调用了内部方法linkLast(e)，在不出现异常的情况下固定返回true。 在指定索引位置添加指定元素1234567891011public void add(int index, E element) { // 校验索引是否越界 checkPositionIndex(index); if (index == size) // 指定索引在集合末尾：调用内部方法连接指定元素至链表末尾 linkLast(element); else // 指定索引在集合中间：调用内部方法连接指定元素至指定索引位置的节点之前。 linkBefore(element, node(index));} 首先校验指定索引是否越界，然后判断指定索引是否在集合末尾，如果是，则指定元素为链表的新尾节点，调用内部方法linkLast(e)，将指定元素连接至链表末尾；否则，调用内部方法linkBefore(e,node)将指定元素连接至指定索引位置的节点之前。 清空所有元素1234567891011121314151617181920212223public void clear() { // Clearing all of the links between nodes is &quot;unnecessary&quot;, but: // - helps a generational GC if the discarded nodes inhabit // more than one generation // - is sure to free memory even if there is a reachable Iterator for (Node&lt;E&gt; x = first; x != null; ) { // 迭代：初始x为头节点；迭代结束的条件为：x为null。 // 获取x的后继节点 Node&lt;E&gt; next = x.next; // 当前x的数据域、后继节点和前驱节点都置为null x.item = null; x.next = null; x.prev = null; // x赋值为其后继节点，进行下一次迭代。 x = next; } // 清除头尾节点引用 first = last = null; // 重置集合大小 size = 0; // 修改次数增加 modCount++;} 迭代链表，for循环中获取原链表头节点x，迭代过程中对x进行重新赋值，迭代结束的条件为x为null。 每次迭代将当前迭代的节点x的数据域、后继节点和前驱节点都置为null，然后将x赋值为x的后继节点，进行下一次迭代，直至x为尾节点。 迭代完成后清除头尾节点first和last的引用，重置集合大小为0。 获取指定元素在集合中第一次出现的索引位置123456789101112131415161718192021222324public int indexOf(Object o) { // 索引记录 int index = 0; if (o == null) { // 指定元素为null for (Node&lt;E&gt; x = first; x != null; x = x.next) { // 迭代：获取链表头节点x，迭代结束的条件为x为null，每次迭代完成将x赋值为x的后继节点 // 判断节点x的数据域是否为null：是则找到了指定元素的第一次出现，返回索引记录index；否则，索引增一。 if (x.item == null) return index; index++; } } else { // 指定元素不为null，采用equals方法比较是否相等 for (Node&lt;E&gt; x = first; x != null; x = x.next) { // 迭代的条件同指定元素为null的情况 if (o.equals(x.item)) return index; index++; } } // 迭代完成仍未返回：集合中不存在指定元素，返回-1。 return -1;} 首先创建一个索引记录index初始为0，然后迭代链表，分为指定元素为null和非null两种情况，为null则采用==运算符比较；非null则采用equals方法比较是否相等。从链表头节点开始迭代，一旦找到相等的元素，则返回索引index，否则索引增一。如果迭代完成仍未找到指定元素，则返回-1。 获取指定元素在集合中最后一次出现的索引位置12345678910111213141516171819202122232425public int lastIndexOf(Object o) { // 索引记录初始为集合大小size int index = size; if (o == null) { // 指定元素为null，采用==运算符比较 for (Node&lt;E&gt; x = last; x != null; x = x.prev) { // 迭代：获取链表尾节点x，迭代结束的条件为x为null，每次迭代后将x赋值为x的前驱节点 // 首先索引记录减一 index--; // 判断节点x的数据域是否为null：是则找到了指定元素的最后一次出现，返回索引记录index；否则，进行下一次迭代。 if (x.item == null) return index; } } else { // 指定元素不为null，采用equals方法比较是否相等 for (Node&lt;E&gt; x = last; x != null; x = x.prev) { // 迭代的条件同指定元素为null的情况 index--; if (o.equals(x.item)) return index; } } // 迭代完成仍未返回：集合中不存在指定元素，返回-1。 return -1;} 首先创建一个索引记录index初始为集合大小size，然后迭代链表，分为指定元素为null和非null两种情况，为null则采用==运算符比较；非null则采用equals方法比较是否相等。从链表尾节点开始迭代，迭代一开始就将索引记录减一，然后进行相等比较，一旦找到相等的元素，则返回索引index，否则进行下一次迭代。如果迭代完成仍未找到指定元素，则返回-1。 判断指定元素是否在集合中至少出现一次123public boolean contains(Object o) { return indexOf(o) != -1;} 实际上调用的是indexOf方法寻找指定元素的索引位置，如果返回-1则集合中不存在该指定元素，否则表示指定元素在集合中至少出现过一次。 获取指定索引位置的元素123456public E get(int index) { // 校验索引是否越界 checkElementIndex(index); // 调用内部方法node(index)获取指定索引位置的节点，取出数据域item返回。 return node(index).item;} 首先校验指定索引是否越界，然后调用内部方法node(index)获取指定索引位置的节点，取出其数据域item返回。 剔除指定索引位置的元素123456public E remove(int index) { // 校验指定索引是否越界 checkElementIndex(index); // 调用内部方法node获取指定索引位置节点，再调用内部方法unlink取消此节点的连接 return unlink(node(index));} 首先校验指定索引是否越界，然后调用内部方法node(index)获取指定索引位置的节点，最后调用内部方法unlink(node)取消此节点的连接。 剔除指定元素的第一次出现1234567891011121314151617181920212223public boolean remove(Object o) { if (o == null) { // 指定元素为null：从头节点x开始迭代，迭代结束的条件为x为null，每次迭代将x赋值为x的后继节点。 for (Node&lt;E&gt; x = first; x != null; x = x.next) { if (x.item == null) { // 如果找到了null元素，则调用内部方法unlink剔除x元素的连接。 unlink(x); return true; } } } else { // 指定元素非null for (Node&lt;E&gt; x = first; x != null; x = x.next) { // 迭代的条件同指定元素为null的情况，使用equals比较当前迭代元素x与指定元素是否相等。 if (o.equals(x.item)) { unlink(x); return true; } } } // 迭代完成都未返回，则集合中无该元素，返回false。 return false;} 迭代链表，分为指定元素为null和非null两种情况，为null采用==运算符进行比较，非null则采用equals方法比较是否相等。从链表头节点开始迭代，一旦找到相等的元素，则调用内部方法unlink(node)取消该节点的连接，返回true。如果迭代完成时都未找到相等的元素，则返回false。 覆盖指定索引位置的元素123456789101112public E set(int index, E element) { // 校验指定索引是否越界 checkElementIndex(index); // 获取指定索引位置节点x Node&lt;E&gt; x = node(index); // 取出x的数据域 E oldVal = x.item; // 给x的数据域赋值为指定元素 x.item = element; // 返回x节点旧的数据域 return oldVal;} 首先校验指定索引是否越界，然后调用内部方法node(index)获取指定索引位置的节点x，取出节点x的数据域，然后为x的数据域重新赋值为指定元素，最后返回节点x旧的数据域。 获取集合中元素个数123public int size() { return size;} 直接返回size成员变量。 转换成Object数组1234567891011public Object[] toArray() { // 定义size长度的数组 Object[] result = new Object[size]; int i = 0; // 从头节点x开始迭代，迭代结束的条件为x=null，每次迭代完成将x赋值为x的后继节点 for (Node&lt;E&gt; x = first; x != null; x = x.next) // 填充数组 result[i++] = x.item; // 返回数组 return result;} 首先定义一个size长度的Object数组，然后从链表头节点开始迭代，每次迭代向Object数组中填充一个元素，迭代完成时数组中的元素即为链表中的全部元素，最后返回数组。 转换成指定类型数组1234567891011121314151617181920@SuppressWarnings(&quot;unchecked&quot;)public &lt;T&gt; T[] toArray(T[] a) { // 指定数组长度是否小于链表长度 if (a.length &lt; size) // 小于：重新分配一个size长度数组 a = (T[])java.lang.reflect.Array.newInstance( a.getClass().getComponentType(), size); int i = 0; // 返回数组容器 Object[] result = a; // 迭代链表，填充元素。 for (Node&lt;E&gt; x = first; x != null; x = x.next) result[i++] = x.item; // 迭代完成，如果指定数组的长度大于链表长度，则将返回数组容器中size索引位置的元素置为null // null元素之前为原链表元素，null元素之后为原指定数组元素。 if (a.length &gt; size) a[size] = null; // 数组返回。此时数组中元素类型已由Object强转成泛型T return a;} 入参为泛型数组a，判断入参数组长度是否小于链表长度，小于则重新分配一个链表长度size大小的数组空间。迭代链表，将元素填充至数组，迭代完成时，如果是重新分配的数组空间，则数组中的元素恰好全部为链表中的元素；否则数组中的元素多于链表中的元素，将size索引位置的元素置为null，此时，null元素之前为原链表元素，之后为原入参数组元素。最后返回将Object数组强转成泛型数组。 此方法可用于将集合中的元素类型转换为指定类型并转换成数组。 双端队列方法LinkedList实现了Deque双端队列接口，提供了双端队列的基本实现。 入队列入队首123public void addFirst(E e) { linkFirst(e);} 直接调用内部方法linkFirst(e)连接指定元素e作为新的头节点。 1234public boolean offerFirst(E e) { addFirst(e); return true;} 同样是调用了内部方法linkFirst(e)连接指定元素e作为新的头节点。然后返回特殊值true。 入队尾123public void addLast(E e) { linkLast(e);} 直接调用内部方法linkLast(e)连接指定元素e作为新的尾节点。 1234public boolean offerLast(E e) { addLast(e); return true;} 同样是调用了内部方法linkLast(e)连接指定元素e作为新的尾节点。然后返回特殊值true。 出队列从队首出队列123456public E removeFirst() { final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);} 首先获取链表头节点，如果头节点为null，则为空队列，抛出NoSuchElementException异常。 否则调用内部方法unlinkFirst(e)剔除头节点的连接。 1234public E pollFirst() { final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);} 同样是先获取链表头节点，如果头节点为null，则为空队列，返回null，不会抛出异常；否则调用内部方法unlinkFirst(e)剔除头节点的连接。 此实现符合Deque接口中的定义：当队列为空队列时，removeFirst()方法抛出异常，而pollFirst()方法返回特殊值null。 从队尾出队列123456public E removeLast() { final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l);} 首先获取链表尾节点，如果尾节点为null，则为空队列，抛出NoSuchElementException异常。 否则调用内部方法unlinkLast(e)剔除尾节点的连接。 1234public E pollLast() { final Node&lt;E&gt; l = last; return (l == null) ? null : unlinkLast(l);} 同样是先获取链表尾节点，如果尾节点为null，则为空队列，返回null，不会抛出异常；否则调用内部方法unlinkLast(e)剔除尾节点的连接。 此实现也符合Deque接口中的定义：当队列为空队列时，removeLast()方法抛出异常，而pollLast()方法返回特殊值null。 查询队首元素123456public E getFirst() { final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;} 首先获取链表头节点，如果头节点为null，则为空队列，抛出NoSuchElementException异常。否则返回头节点的数据域。 1234public E peekFirst() { final Node&lt;E&gt; f = first; return (f == null) ? null : f.item; } 同样是先获取链表头节点，如果头节点为null，则为空队列，返回null，不会抛出异常；否则返回头节点的数据域。 此实现也符合Deque接口中的定义：当队列为空队列时，getFirst()方法抛出异常，而peekFirst()方法返回特殊值null。 查询队尾元素123456public E getLast() { final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item;} 首先获取链表尾节点，如果尾节点为null，则为空队列，抛出NoSuchElementException异常。否则返回尾节点的数据域。 1234public E peekLast() { final Node&lt;E&gt; l = last; return (l == null) ? null : l.item;} 同样是先获取链表尾节点，如果尾节点为null，则为空队列，返回null，不会抛出异常；否则返回尾节点的数据域。 此实现也符合Deque接口中的定义：当队列为空队列时，getLast()方法抛出异常，而peekLast()方法返回特殊值null。 删除第一次出现的指定元素123public boolean removeFirstOccurrence(Object o) { return remove(o);} 直接调用集合方法remove(o)剔除指定元素的第一次出现。 删除最后一次出现的指定元素1234567891011121314151617181920212223public boolean removeLastOccurrence(Object o) { if (o == null) { // 指定元素为null // 从尾节点开始迭代链表，一旦找到数据域为null的节点，则调用内部方法unlink剔除该节点的连接。 for (Node&lt;E&gt; x = last; x != null; x = x.prev) { if (x.item == null) { unlink(x); return true; } } } else { // 指定元素非null，使用equals比较元素是否相等 // 迭代的条件同指定元素为null的情况 for (Node&lt;E&gt; x = last; x != null; x = x.prev) { if (o.equals(x.item)) { unlink(x); return true; } } } // 迭代完成仍未找到，返回false。 return false;} 分为指定元素为null和非null两种情况，为null采用==运算符比较，非null采用equals方法比较。从尾节点开始迭代，一旦找到数据域与指定元素相等的节点，则调用内部方法unlink剔除该节点的连接。 普通队列方法Deque双端队列接口中同样声明了普通队列Queue接口中定义的一系列方法。LinkedList类也对其进行了实现。 Queue接口中定义的方法如下： action throws exception returns special value insert add(e) offer(e) remove remove() poll() get head element() peek() 它有三组共六个方法，在Queue接口的声明中约定了每组方法中有一个是失败时抛出指定异常，另一个是返回特殊值null或false。 LinkedList类却没有完全遵守Queue接口的约定，所有方法在执行失败时均未抛出指定异常。这是为什么呢？ 在我看来，LinkedList的实现初衷是作为List集合使用（这点可从类名体现出来，它是一种List）。由于其底层数据结构是双向链表，它可以用来实现队列等其它数据结构，所以设计者让LinkedList类实现了队列接口。 是因为双向链表这种数据结构可以用来实现队列，所以才实现队列接口。而不是因为实现了队列接口，才决定使用双向链表这种数据结构。 从队尾入队列第一个方法是add(e)，实际上这也是在List接口中定义的方法，它的实现既符合列表的定义，又符合队列的定义。 详情见集合方法中的add(e)。 第二个方法是offer(e)： 123public boolean offer(E e) { return add(e);} 直接调用了add(e)方法。 从队首出队列第一个方法是remove()，该方法同样也定义在了List接口中，详情见集合方法中的remove。 第二个方法是poll()： 1234public E poll() { final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);} 首先获取链表头节点，如果头节点为null，则为空队列，返回特殊值null；否则调用内部方法unlinkFirst(f)剔除头节点的连接。这符合Queue接口中poll方法的定义。 查询队首元素第一个方法是element()： 123public E element() { return getFirst();} 直接调用双端队列的getFirst()方法查询队首元素。 第二个方法是peek()： 1234public E peek() { final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;} 首先获取链表头节点，如果头节点为null，则为空队列，返回特殊值null；否则返回头节点的数据域。这符合Queue接口中peek方法的定义。 迭代器LinkedList类只提供了列表迭代器的实现，基类AbstractSequentialList类中提供的普通迭代器实现也是列表迭代器。 123456public ListIterator&lt;E&gt; listIterator(int index) { // 校验索引是否越界 checkPositionIndex(index); // 返回从index位置开始的迭代器对象 return new ListItr(index);} 迭代器ListItr实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170private class ListItr implements ListIterator&lt;E&gt; { /** * 最后一次通过迭代器返回的节点对象 */ private Node&lt;E&gt; lastReturned; /** * 当前迭代器所持有的节点对象，它将作为迭代的依据，调用previous方法将返回其前驱节点；调用next方法将返回其后继节点。 */ private Node&lt;E&gt; next; /** * 当前迭代器所持有的节点对象的索引 */ private int nextIndex; /** * fail-fast机制的期望修改次数，初始化为AbstractList#modCount */ private int expectedModCount = modCount; /** * 带参构造器，构造指定索引位置的列表迭代器。由外部校验索引合法。 */ ListItr(int index) { // assert isPositionIndex(index); // index = size 是合法的，便于从后向前迭代。此时next为尾节点last的后继节点null，可以调用previous方法迭代尾节点。 next = (index == size) ? null : node(index); nextIndex = index; } /** * 判断是否迭代到了列表末尾 */ public boolean hasNext() { return nextIndex &lt; size; } /** * 获取当前nextIndex索引位置的节点元素，且索引右移一位。 */ public E next() { // fail-fast checkForComodification(); if (!hasNext()) throw new NoSuchElementException(); // 记录最后一次通过迭代器返回的节点对象 lastReturned = next; // 当前迭代器所持有的节点对象 赋值 为其后继节点 next = next.next; // 索引右移 nextIndex++; // 返回元素值 return lastReturned.item; } /** * 判断是否迭代到了列表开头 */ public boolean hasPrevious() { return nextIndex &gt; 0; } /** * 获取当前nextIndex索引位置的节点元素，且索引左移一位。 */ public E previous() { // fail-fast机制 checkForComodification(); if (!hasPrevious()) throw new NoSuchElementException(); // 如果next为null，则初始化该迭代器对象时，构造方法中传入的index=size。 // 表示从列表尾部开始迭代，将next赋值为尾节点last；否则赋值为其前驱节点。 lastReturned = next = (next == null) ? last : next.prev; nextIndex--; return lastReturned.item; } /** * 返回当前迭代索引，其值由构造器初始化。 */ public int nextIndex() { return nextIndex; } /** * 返回当前迭代索引前一位 */ public int previousIndex() { return nextIndex - 1; } /** * 安全地从列表中删除上一次迭代方法（next/previous）返回的节点。 * 迭代过程中只能调用该方法修改列表，否则将引发fail-fast机制。 */ public void remove() { // fail-fast机制 checkForComodification(); // 迭代状态校验：调用此remove方法之前必须先调用迭代方法。 if (lastReturned == null) throw new IllegalStateException(); // 获取上次迭代返回节点的后继节点 Node&lt;E&gt; lastNext = lastReturned.next; // 剔除lastReturned节点的连接（会导致AbstractList#modCount增加） unlink(lastReturned); // 从后往前（previous）迭代时，next = lastReturned成立 if (next == lastReturned) // 当前迭代器所持有的节点对象赋值为上次迭代返回节点的后继节点 next = lastNext; else // 从前往后（next）迭代时，进入else分支，迭代索引减一。 nextIndex--; // 重置迭代器迭代状态，下次调用迭代方法之前不可再调用remove方法。 lastReturned = null; // 期望修改次数增加 expectedModCount++; } /** * 覆盖上次迭代方法返回的节点数据域 */ public void set(E e) { // 迭代状态校验 if (lastReturned == null) throw new IllegalStateException(); // fail-fast机制 checkForComodification(); // 覆盖 lastReturned.item = e; } /** * 在下次调用迭代方法将返回的节点之前连接指定节点e */ public void add(E e) { checkForComodification(); lastReturned = null; if (next == null) linkLast(e); else linkBefore(e, next); nextIndex++; expectedModCount++; } /** * JDK8 新增 */ public void forEachRemaining(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); while (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) { action.accept(next.item); lastReturned = next; next = next.next; nextIndex++; } checkForComodification(); } /** * fail-fast机制：校验实际修改次数是否等于期望修改次数。不等则立即抛出ConcurrentModificationException异常。 */ final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); }} 其它方法克隆该类提供了深拷贝方法（从LinkedList维度来说可以称为深拷贝）。由于其内部持有的是对象引用，列表中的元素并没有进行“深拷贝”。 1234567891011121314151617181920212223242526272829/** * 克隆实现 */public Object clone() { // 获取一个浅拷贝对象 LinkedList&lt;E&gt; clone = superClone(); // 初始化状态 // Put clone into &quot;virgin&quot; state clone.first = clone.last = null; clone.size = 0; clone.modCount = 0; // 值填充 // Initialize clone with our elements for (Node&lt;E&gt; x = first; x != null; x = x.next) clone.add(x.item); return clone;}/** * 私有方法：调用Object#clone浅拷贝 */private LinkedList&lt;E&gt; superClone() { try { return (LinkedList&lt;E&gt;) super.clone(); } catch (CloneNotSupportedException e) { throw new InternalError(e); }}","link":"/2020/05/27/javase/base/linkedlist/"},{"title":"JDK源码解析之Deque","text":"双端队列简述双端队列是一种更特殊的线性表。普通队列Queue只允许在队首删除元素，在队尾插入元素。而双端队列同时允许在队首和队尾插入和删除元素。 Deque接口简述Deque接口是Java中的双端队列定义，继承java.util.Queue接口，它提供了操作队首和队尾的六组方法：插入队首/队尾元素、删除队首/队尾元素、提取队首/队尾元素。同Queue接口一样，每组操作都包含两种形式：一种在操作失败时抛出异常；另一种返回特殊的值（null或false）。 当把双端队列当做普通队列使用时，将出现FIFO（先进先出）行为。继承自Queue接口的方法等同于Deque接口中的特定方法。 双端队列也可用做LIFO（后进先出）堆栈。应该优先选用此接口，尽量不要使用旧版java.util.Stack类（继承自同步集合Vector）。 接口详解双端队列操作接口： 操作位置 队首（Head） 队尾（Tail） 响应 throws exception special value throws exception special value insert addFirst(e) offerFirst(e) addLast(e) offerLast(e) remove removeFirst() pollFirst() removeLast() pollLast() get element getFirst() peekFirst() getLast() peekLast() 入队列入队首1void addFirst(E e); 插入指定元素至队首，如果成功则返回true，如果达到了当前队列的最大容量限制，则抛出IllegalStateException异常。 1boolean offerFirst(E e); 同样是插入指定元素至队首，如果成功则返回true，如果达到了当前队列的最大容量限制，则返回false。不会抛出异常。 所以，当使用容量受限的队列时，通常使用offerFirst方法插入指定元素至队首。 入队尾1void addLast(E e); 插入指定元素至队尾，如果成功则返回true，如果达到了当前队列的最大容量限制，则抛出IllegalStateException异常。 1boolean offerLast(E e); 同样是插入指定元素至队尾，如果成功则返回true，如果达到了当前队列的最大容量限制，则返回false。不会抛出异常。 所以，当使用容量受限的队列时，通常使用offerLast方法插入指定元素至队尾。 出队列从队首出队列1E removeFirst(); 删除队首第一个元素，如果为空队列，则抛出NoSuchElementException异常。 1E pollFirst(); 同样是删除队首第一个元素，如果为空队列，则返回null。不会抛出异常。 从队尾出队列1E removeLast(); 删除队尾第一个元素，如果为空队列，则抛出NoSuchElementException异常。 1E pollLast(); 同样是删除队尾第一个元素，如果为空队列，则返回null。不会抛出异常。 查询队列元素查询队首元素1E getFirst(); 获取队首元素，如果为空队列，则抛出NoSuchElementException异常。 1E peekFirst(); 同样是获取队首元素，如果为空队列，则返回null。不会抛出异常。 查询队尾元素1E getLast(); 获取队尾元素，如果为空队列，则抛出NoSuchElementException异常。 1E peekLast(); 同样是获取队尾元素，如果为空队列，则返回null。不会抛出异常。 删除指定元素删除第一次出现的指定元素1boolean removeFirstOccurrence(Object o); 从此双端队列中删除第一次出现的指定元素e。如果从未出现，则队列保持不变。判断队列中的元素与指定元素相等的条件为：o == null ? e == null : o.equals(e)。 删除最后一次出现的指定元素1boolean removeLastOccurrence(Object o); 从此双端队列中删除最后一次出现的指定元素e。如果从未出现，则队列保持不变。判断队列中的元素与指定元素相等的条件为：o == null ? e == null : o.equals(e)。 作为普通队列该双端队列Deque接口同样提供了普通队列Queue的六个操作方法。用作普通队列时，产生FIFO（先进先出）行为，其方法等同于上述双端队列的特定方法。下面是它们的对应关系： Queue Method Equivalent Deque Method add(e) addLast(e) offer(e) offerLast(e) remove() removeFirst() poll() pollFirst() element() getFirst() peek() peekFirst() 虽然Deque接口也提供了普通队列的六个操作方法，但我们尽量不要去使用它们，而是使用其对应的方法。 例如入队列，最好不要调用offer(e)，而是调用offerLast(e)。 因为当使用offer(e)时，我们还需要思考，offer(e)实际上就是offerLast(e)：从队尾入队列。如果我们直接调用offerLast(e)，一眼就能看出是从队尾入队列。 所以，使用Deque接口时，推荐明确使用xxxLast/xxxFirst这类方法。 作为栈双端队列可以当做栈（LIFO后进先出）来使用。它提供了遗留类Stack中对栈的基本操作方法。这些方法等同于上述双端队列的特定方法。下面是它们的对应关系： Stack Method Equivalent Deque Method push(e) addFirst(e) pop() removeFirst() peek() peekFirst() 当做栈使用时，尽量使用栈的方法：push(e)/pop/peek，不要调用其对应的方法。 因为遗留类Stack已经存在了，考虑到类库兼容性问题无法将其覆盖，所以在Deque接口中定义了栈的方法，当我们把Deque当做栈使用时，直接调用栈的方法会使语义更加明确。 作为集合由于Deque接口继承了Queue接口，而Queue接口又继承了Collection接口，所以Deque也可作为集合使用。它也定义了一些集合的基本操作。 判断指定元素o与双端队列中元素e相等的条件为：o == null ? e == null : o.equals(e)。 删除第一次出现的指定元素1boolean remove(Object o); 与Collection接口中定义的类似，删除指定元素在集合中的第一次出现。实际上，该方法等同与removeFirstOccurrence(o)方法。 判断是否包含指定元素1boolean contains(Object o); 该双端队列中至少包含一个指定的元素o。 查询元素个数1public int size(); 返回该双端队列中的元素个数。 迭代器提供了两个不同元素顺序的迭代器。 从队首到队尾的迭代器1Iterator&lt;E&gt; iterator(); 迭代器中的元素顺序为双端队列从队首到队尾的元素顺序。 从队尾到队首的迭代器1Iterator&lt;E&gt; descendingIterator(); 以相反的顺序返回迭代器。 总结Deque接口定义了一个双端队列（Double Ended Queue），它可以从队首或队尾操作元素；也可以当做普通队列Queue使用；同时还可以当做栈Stack来使用。","link":"/2020/05/11/javase/base/deque/"},{"title":"JDK源码解析之Queue","text":"队列简述队列是一种特殊的线性表，它具有先进先出（FIFO）的特点，只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。 Queue接口简述Queue接口是Java中的队列定义，它也是Java容器中的一员，继承自java.util.Collection接口。Queue接口在Collection接口的基础上定义了三组操作：插入、删除和提取。每组操作都包含两种形式：一种在操作失败时抛出异常；另一种返回特殊的值（null或false）。 接口详解 action throws exception returns special value insert add(e) offer(e) remove remove() poll() get head element() peek() 入队列1boolean add(E e); 插入指定元素至队尾，如果成功则返回true，如果达到了当前队列的最大容量限制，则抛出IllegalStateException异常。 1boolean offer(E e); 同样是插入指定元素至队尾，如果成功则返回true，如果达到了当前队列的最大容量限制，则返回false。不会抛出异常。 所以，当使用容量受限的队列时，通常使用offer方法插入元素。 出队列1E remove(); 删除队首第一个元素，如果为空队列，则抛出NoSuchElementException异常。 1E poll(); 同样是删除队首第一个元素，如果为空队列，则返回null。不会抛出异常。 查询队首元素1E element(); 获取队首元素，如果为空队列，则抛出NoSuchElementException异常。 1E peek(); 同样是获取队首元素，如果为空队列，则返回null。不会抛出异常。 总结Queue接口实现通常不允许插入null元素，尽管某些实现（例如LinkedList）可以插入null元素，也不应将null插入队列中，因为poll和peek方法会在队列为空队列时返回特殊值null，会产生歧义。","link":"/2020/05/11/javase/base/queue/"},{"title":"JDK源码解析之AbstractList","text":"简介AbstractList类是一个抽象类，它继承了AbstractCollection抽象类并实现了List接口。List接口定义了一种有序集合，可以精确控制每个元素的插入位置；而AbstractCollection抽象类提供了两个抽象方法，基于这两个抽象方法提供出了集合的最基本实现。 所以，AbstractList抽象类提供的是有序集合的骨架实现，用以最大程度地减少支持随机访问数据（例如数组）的实现类所需的工作。而对于顺序访问数据（例如链表），应该优先使用AbstractSequentialList抽象类。 特性该抽象类提供了有序集合的骨架实现。让实现类支持随机快速访问。 如果要实现不可修改的有序集合，只需继承该类并为get和size方法提供实现；如果要实现可修改的有序集合，在实现不可修改的有序集合基础之上，还要另外重写此类的两个重载的set方法（否则将抛出UnsupportedOperationException异常），如果集合的大小是可变的，还要再另外重写两个重载的add方法和一个remove方法。 此外，实现类同样应该遵循Collection接口中提出的规范：必须提供两个标准构造器：void无参构造器和带Collection类型的单个参数的构造器。 与其它抽象集合实现不同，此类的实现类不是必须要提供迭代器实现；此类的迭代器和列表迭代器是在“随机访问”方法之上由此类自身进行实现的。 “随机访问”方法（索引访问）有： get(int) set(int, Object) set(int, E) add(int Object) add(int, E) remove(int) 源码详解构造器只有一个使用protected修饰符修饰的无参构造器。说明该抽象类不允许外部直接实例化使用，因为它只是一个骨架实现，并不提供有序集合的完整功能。 12protected AbstractList() {} 成员变量1protected transient int modCount = 0; 只有一个成员变量，表示该列表被结构修改的次数。 结构修改是指：更改列表大小或以其它方式干扰列表。 此字段由iterator和listIterator方法返回的迭代器使用。如果在迭代过程中修改了该字段的值，则迭代器将在next、remove和previous方法中抛出ConcurrentModificationException异常。这里就是Java普通集合的fail-fast机制。否则将出现不确定的行为。 子类对该字段的使用是可选的，当子类需要提供具有fail-fast机制的迭代器（或列表迭代器）时，只需在其add和remove方法中修改该字段的值，一次调用add或remove方法必须修改该值且不超过1。否则迭代器将抛出ConcurrentModificationException异常；当子类不需要提供具有fail-fast机制的迭代器时，可直接忽略该字段。 抽象方法该类中只包含一个抽象方法，用于支持随机快速访问（根据索引取值）。 1abstract public E get(int index); 已实现方法所有的实现方法都是基于该类的抽象方法或其它已实现方法，大部分实现是基于迭代器的。部分方法中直接抛出UnsupportedOperationException异常，这样的实现表示该方法需要子类进行重写实现。总的来看，该类提供了有序集合的模板实现。下面我们来具体的分析每个方法。 快速访问添加指定元素至列表末尾1234public boolean add(E e) { add(size(), e); return true;} 调用了重载的add方法，传入size()方法的返回值和指定元素，然后返回true。 只要重载的add方法中不出现异常，则该add方法始终返回true。 需要注意的是，支持此操作的列表可能会对可以添加至列表的元素进行限制。例如，某些列表拒绝添加null元素，而另一些对可能添加的元素进行类型限制。所以实现类应在其文档中明确指出对可以添加的元素有哪些限制。 在指定索引位置添加指定元素123public void add(int index, E element) { throw new UnsupportedOperationException();} 该方法中直接抛出UnsupportedOperationException异常，是必须要子类重写进行具体实现的。 用指定元素来覆盖指定索引位置的值123public E set(int index, E element) { throw new UnsupportedOperationException();} 该方法中直接抛出UnsupportedOperationException异常，是必须要子类重写进行具体实现的。 添加指定元素至指定索引位置123public void add(int index, E element) { throw new UnsupportedOperationException();} 该方法中直接抛出UnsupportedOperationException异常，是必须要子类重写进行具体实现的。 删除指定索引位置的元素123public E remove(int index) { throw new UnsupportedOperationException();} 该方法中直接抛出UnsupportedOperationException异常，是必须要子类重写进行具体实现的。 查询操作查询指定元素在列表中第一次出现的索引位置12345678910111213public int indexOf(Object o) { ListIterator&lt;E&gt; it = listIterator(); if (o==null) { while (it.hasNext()) if (it.next()==null) return it.previousIndex(); } else { while (it.hasNext()) if (o.equals(it.next())) return it.previousIndex(); } return -1;} 该方法的实现为：首先调用该类的listIterator()方法获取一个指向列表开头的列表迭代器，然后，从前往后遍历列表，直到第一次找到指定的元素或到达列表的末尾（返回-1）。 查询指定元素在列表中最后一次出现的索引位置12345678910111213public int lastIndexOf(Object o) { ListIterator&lt;E&gt; it = listIterator(size()); if (o==null) { while (it.hasPrevious()) if (it.previous()==null) return it.nextIndex(); } else { while (it.hasPrevious()) if (o.equals(it.previous())) return it.nextIndex(); } return -1;} 该方法的实现为：首先调用该类的listIterator()方法传入size()方法的返回值（该列表的大小）获取一个指向列表末尾的列表迭代器，然后，从后往前遍历列表，直到第一次找到指定的元素或到达列表的开头（返回-1）。 批量操作清空列表123public void clear() { removeRange(0, size());} 删除此列表中的所有元素，内部调用的是removeRange方法。子类必须重写本类的remove或removeRange方法，否则将抛出UnsupportedOperationException异常。 我们来看下removeRange方法的实现： 1234567protected void removeRange(int fromIndex, int toIndex) { ListIterator&lt;E&gt; it = listIterator(fromIndex); for (int i=0, n=toIndex-fromIndex; i&lt;n; i++) { it.next(); it.remove(); }} 从该列表中删除索引介于fromIndex和toIndex之间的元素，将toIndex索引后的所有元素左移。当fromIndex等于toIndex时，此方法不会做任何操作。 入参有两个： fromIndex：要删除的第一个元素的索引； toIndex：要删除的最后一个元素之后的索引。 首先调用listIterator(fromIndex)方法获取位于fromIndex之前的列表迭代器，然后迭代索引区间为[0,toIndex-fromIndex)的元素，在每次迭代过程中，调用ListIterator.next方法获取下一个元素，然后调用ListIterator.remove方法删除当前迭代索引元素，直到删除了整个范围内的元素为止。 如果ListIterator.remove方法的时间复杂度为O(n)，那么该方法的时间复杂度为O(n^2)。 将指定集合从指定索引位置开始插入123456789public boolean addAll(int index, Collection&lt;? extends E&gt; c) { rangeCheckForAdd(index); boolean modified = false; for (E e : c) { add(index++, e); modified = true; } return modified;} 将指定集合c从索引为index的位置开始插入，需要子类实现add(int,E)方法，否则将抛出UnsupportedOperationException异常。 首先调用rangeCheckForAdd(index)方法校验索引范围（区间为[0,size())），然后迭代指定集合c，使用add(int,E)方法进行插入。 一般来说，子类会选择重写该方法来提高批量插入效率。 迭代器普通迭代器123public Iterator&lt;E&gt; iterator() { return new Itr();} 直接创建内部类Itr的实例对象返回。我们来看下这个内部类Itr： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private class Itr implements Iterator&lt;E&gt; { /** * Index of element to be returned by subsequent call to next. */ int cursor = 0; /** * Index of element returned by most recent call to next or * previous. Reset to -1 if this element is deleted by a call * to remove. */ int lastRet = -1; /** * The modCount value that the iterator believes that the backing * List should have. If this expectation is violated, the iterator * has detected concurrent modification. */ int expectedModCount = modCount; public boolean hasNext() { return cursor != size(); } public E next() { checkForComodification(); try { int i = cursor; E next = get(i); lastRet = i; cursor = i + 1; return next; } catch (IndexOutOfBoundsException e) { checkForComodification(); throw new NoSuchElementException(); } } public void remove() { if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try { AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException e) { throw new ConcurrentModificationException(); } } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } 有三个成员变量： cursor：游标，初始化为0，后续调用该内部类的next方法返回的元素索引。 lastRet：初始化为-1，最近一次调用next或previous方法返回的元素索引。如果一次调用中删除了当前指向的元素，则将其重置为-1。 expectedModCount：期望修改次数，初始化为外部类AbstractList的成员变量modCount，迭代器认为后续迭代过程中列表应该具有的modCount值，如果期望值与实际modCount值不相等，则出现了并发修改的情况。 有三个公共方法： 1、判断是否还有下一个元素： 123public boolean hasNext() { return cursor != size();} 判断当前游标是否等于列表大小。size()方法为父类AbstractCollection中的抽象size()方法。 2、获取当前游标索引指向的元素： 12345678910111213public E next() { checkForComodification(); try { int i = cursor; E next = get(i); lastRet = i; cursor = i + 1; return next; } catch (IndexOutOfBoundsException e) { checkForComodification(); throw new NoSuchElementException(); }} 首先调用当前内部类的checkForComodification()方法校验期望修改次数expectedModCount是否等于实际修改次数modCount。如果不相等，则已出现并发修改，抛出ConcurrentModificationException异常。 然后调用外部类AbstractList的抽象方法get(int)根据当前游标索引取值，将当前游标值赋给成员变量lastRet，当前游标右移一位，最后返回取到的元素。 先校验modCount的值，如果在校验通过且代码执行到get(i)之前时有其它线程修改了当前列表的大小，则可能会出现索引越界IndexOutOfBoundsException的异常，此时将其捕获，在catch块中再次进行modCount校验，如果校验不通过，则会直接抛出ConcurrentModificationException异常；但可能在这次校验之前又有其它线程将当前列表还原了，此时校验又会通过，所以在校验之后主动抛出NoSuchElementException异常。 3、删除最近一次通过next方法获取到的元素： 123456789101112131415public void remove() { if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try { AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException e) { throw new ConcurrentModificationException(); }} 首先如果lastRet小于0，则该迭代器的next方法未先调用，抛出IllegalStateException异常。 然后检查expectedModCount与modCount是否相等，不相等则出现并发修改，抛出ConcurrentModificationException异常。 接下来调用外部类AbstractList的remove方法，删除上次通过next方法获取到的元素。所以AbstractList的子类必须重写AbstractList类的remove方法。 删除元素之后，将游标左移一位，此时指向的是删除的元素之后的第一个元素。然后重置lastRet=-1，重新将修改过后的modCount赋给expectedModCount。 解释： 例如列表A,B,C。 初始状态：初始游标cursor为0指向元素A，lastRet=-1； 第一次调用next方法：游标cursor右移一位为1指向元素B，lastRet=0； 此时调用AbstractList的remove方法：删除索引为lastRet=0的元素A，lastRet=0 &lt; cursor=1，游标左移一位为0指向元素B，重置lastRet=-1并将modCount重新赋值给expectedModCount。 由于调用过外部类AbstractList的remove方法，此时的modCount值已经修改。 列表迭代器123public ListIterator&lt;E&gt; listIterator() { return listIterator(0);} 直接调用listIterator(0)方法返回，我们来看下该方法： 12345public ListIterator&lt;E&gt; listIterator(final int index) { rangeCheckForAdd(index); return new ListItr(index);} 首先校验传入索引index范围，然后直接一个返回ListItr的实例对象。我们来看下ListItr的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private class ListItr extends Itr implements ListIterator&lt;E&gt; { ListItr(int index) { cursor = index; } public boolean hasPrevious() { return cursor != 0; } public E previous() { checkForComodification(); try { int i = cursor - 1; E previous = get(i); lastRet = cursor = i; return previous; } catch (IndexOutOfBoundsException e) { checkForComodification(); throw new NoSuchElementException(); } } public int nextIndex() { return cursor; } public int previousIndex() { return cursor-1; } public void set(E e) { if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try { AbstractList.this.set(lastRet, e); expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } public void add(E e) { checkForComodification(); try { int i = cursor; AbstractList.this.add(i, e); lastRet = -1; cursor = i + 1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } } 该类继承了内部类Itr并实现了ListIterator接口。 继承得到了Itr类的三个属性：cursor、lastRet和expectedModCount。 只有一个带参构造器： 123ListItr(int index) { cursor = index;} 让游标指向传入的索引index。 重写了ListIterator接口的六个方法，我们来依次看下实现： 1、判断是否有前一个元素 123public boolean hasPrevious() { return cursor != 0;} 直接判断当前游标cursor是否指向0，为0表示指向列表开始位置，无前一个元素。 2、获取前一个元素 123456789101112public E previous() { checkForComodification(); try { int i = cursor - 1; E previous = get(i); lastRet = cursor = i; return previous; } catch (IndexOutOfBoundsException e) { checkForComodification(); throw new NoSuchElementException(); }} 获取当前游标指向索引的前一位i，获取其元素值previous，将索引i赋值给游标cursor和最后返回元素索引lastRet，最后返回元素previous。校验逻辑同Itr迭代器的next方法。 3、获取下一个即将迭代元素索引 123public int nextIndex() { return cursor;} 直接返回游标cursor。 4、获取即将迭代元素的前一个元素的索引 123public int previousIndex() { return cursor-1;} 直接返回游标cursor减一。 5、用指定元素替换最近一次迭代返回的元素 123456789101112public void set(E e) { if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try { AbstractList.this.set(lastRet, e); expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); }} 仅能在上次调用next或previous方法之后没有调用迭代器的remove或add方法的情况下才能调用。 调用了外部抽象类AbstractList的set方法将lastRet索引指向的元素替换成指定元素e，然后将实际modCount赋给期望修改次数expectedModCount。校验逻辑同Itr迭代器的remove方法。 6、插入指定元素至列表 12345678910111213public void add(E e) { checkForComodification(); try { int i = cursor; AbstractList.this.add(i, e); lastRet = -1; cursor = i + 1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); }} 将指定元素e插入列表，该元素的插入位置为：next方法返回的元素（如果有元素）之前和previous方法返回的元素（如果有元素）之后。如果列表中本来不包含任何元素，则指定元素e将成为列表中的唯一元素。调用此方法后，nextIndex和previousIndex方法的调用返回值将增加一。 首先获取当前游标指向索引i，然后调用外部类AbstractList的add方法将指定元素e插入指定索引i位置。将lastRet重置为-1，游标cursor增一，即下次调用next方法将返回指定元素e之后的元素，而调用previous方法将返回指定元素e。最后将实际modCount赋给期望修改次数expectedModCount。校验逻辑同set方法。 比较和哈希equals比较12345678910111213141516public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof List)) return false; ListIterator&lt;E&gt; e1 = listIterator(); ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator(); while (e1.hasNext() &amp;&amp; e2.hasNext()) { E o1 = e1.next(); Object o2 = e2.next(); if (!(o1==null ? o2==null : o1.equals(o2))) return false; } return !(e1.hasNext() || e2.hasNext());} 比较指定对象与此对象是否相等。当且仅当指定对象也是一个列表，且两个列表具有相同的大小，并且两个列表中所有对应的元素也均相等时，返回true。判断两个元素相等的条件为：当且仅当e1 == null ? e2 == null : e1.equals(e2)时，两个元素认为是相等的。 换句话说，如果两个列表包含相同顺序的相同元素，则将它们定义为相等。 此实现首先检查指定的对象是否为当前列表（==判断地址是否相等），如果是，则返回true；如果不是，将检查指定对象是否为List类型，如果不是则返回false；如果是，则迭代两个列表，比较相对应的元素对，如果有任何比较返回false，则该方法返回false。如果比较完成后任意一个迭代器还有元素，则返回false（因为两个列表长度不相等），否则迭代完成后将返回true。 hashCode123456public int hashCode() { int hashCode = 1; for (E e : this) hashCode = 31*hashCode + (e==null ? 0 : e.hashCode()); return hashCode;} 此实现完全使用List#hashCode方法文档中定义的列表哈希函数的代码。","link":"/2020/05/08/javase/base/abstract-list/"},{"title":"JDK源码解析之AbstractCollection","text":"简介java.util.AbstractCollection类是一个抽象类，它实现了Collection接口。从设计模式的角度来看，以Abstract开头的类应该是一个模板方法类。事实也是如此，它提供了对Collection接口的最基本实现。以最大程度地减少实现类所需的工作。 特性该抽象类只提供了集合的最基本实现，并未对实现类的特性进行任何限制。 如果要实现不可修改的集合，只需继承该类并为iterator和size方法提供实现（由iterator方法返回的迭代器必须实现hasNext和next方法）；如果要实现可修改的集合，在实现不可修改集合的基础之上，还要另外重写此类的add方法（否则将抛出UnsupportedOperationException异常），同时由iterator方法返回的迭代器必须另外实现其remove方法。 此外，实现类同样应该遵循Collection接口中提出的规范：必须提供两个标准构造器：void无参构造器和带Collection类型的单个参数的构造器。 所有未进行实现的方法都被标记为抽象方法待子类实现。下面我们来看下在该抽象类中是如何对集合进行最基本实现的。 源码详解构造器只有一个使用protected修饰符修饰的无参构造器。说明该抽象类不允许外部直接实例化使用，因为它只是最基本的实现，并不具备集合的完整功能。 12protected AbstractCollection() {} 成员变量1private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 只有一个静态成员变量，它表明了要分配的数组的最大大小。如果超出此限制可能会导致OutOfMemoryError。 抽象方法所有的抽象方法都是待具体子类去实现的方法。一共有两个： public abstract Iterator&lt;E&gt; iterator();：返回一个迭代器。 public abstract int size();：计算集合大小。 已实现方法所有实现方法都是最基本的实现，当子类有更好的实现方式时完全可以进行重写。 查询操作判断集合是否为空123public boolean isEmpty() { return size() == 0;} 只需判断size()方法计算出的集合大小是否为0即可。由于size()方法是抽象方法，此方法相当于还是交由子类实现。 判断集合中是否包含指定的元素12345678910111213public boolean contains(Object o) { Iterator&lt;E&gt; it = iterator(); if (o==null) { while (it.hasNext()) if (it.next()==null) return true; } else { while (it.hasNext()) if (o.equals(it.next())) return true; } return false;} 首先调用抽象的iterator方法获取一个迭代器对象，然后对集合进行迭代遍历。 分为两种情况，指定的元素为null和非null，如果为null，则使用==运算符比较；如果为非null，则使用equals方法进行比较。 迭代器对象的hasNext和next方法均由具体子类进行实现。 将集合转换成对象数组将该集合的迭代器返回的所有元素按相同顺序连续存储在数组中，数组索引从0开始。返回的数组长度等于集合元素的数量，即使在迭代过程中此集合的大小发生了改变（并发修改），最终返回的数组也与集合保持一致。 源码如下： 1234567891011public Object[] toArray() { // Estimate size of array; be prepared to see more or fewer elements Object[] r = new Object[size()]; Iterator&lt;E&gt; it = iterator(); for (int i = 0; i &lt; r.length; i++) { if (! it.hasNext()) // fewer elements than expected return Arrays.copyOf(r, i); r[i] = it.next(); } return it.hasNext() ? finishToArray(r, it) : r;} 首先创建size()大小的Object数组，调用iterator方法得到集合的迭代器，然后对创建的Object数组进行下标索引遍历： 正常情况下，在for循环的遍历中，it.hasNext()方法将一直返回true，if条件判断将不会成立，循环完成后，迭代器的hasNext方法将返回false，最终将r数组返回； 而在并发修改的情况下，会出现迭代过程中集合元素减少的情况，这时if(!it.hasNext())判断成立，将返回Arrays.copyOf(r,i)：拷贝一个新数组，其长度为i； 同样地，并发修改会造成集合元素增加的情况，for循环遍历原集合长度r.length次后就已经结束了，再返回时进行了三目表达式判断，如果迭代器的hasNext方法返回true（还有下一个元素），则调用finishToArray(r, it)方法并返回。 下面我们来看下finishToArray方法的具体实现： 12345678910111213141516private static &lt;T&gt; T[] finishToArray(T[] r, Iterator&lt;?&gt; it) { int i = r.length; while (it.hasNext()) { int cap = r.length; if (i == cap) { int newCap = cap + (cap &gt;&gt; 1) + 1; // overflow-conscious code if (newCap - MAX_ARRAY_SIZE &gt; 0) newCap = hugeCapacity(cap + 1); r = Arrays.copyOf(r, newCap); } r[i++] = (T)it.next(); } // trim if overallocated return (i == r.length) ? r : Arrays.copyOf(r, i);} 入参为原集合的对象数组（并发修改前的集合）和集合的迭代器。 首先记录原数组的长度为i； 然后开始迭代，再次记录一次原数组长度，用局部变量cap接收，在第一次迭代时i == cap成立，对cap进行扩容，newCap = cap + (cap &gt;&gt; 1) + 1;：扩容大约为原cap的1.5倍。 扩容后如果发现大于了定义的静态成员变量MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8时，则进行容量最大化处理：调用hugeCapacity方法。 hugeCapacity方法源码如下： 12345678private static int hugeCapacity(int minCapacity) { if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError (&quot;Required array size too large&quot;); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;} 可看到返回的最大容量为Integer.MAX_VALUE。 接下来调用r = Arrays.copyOf(r, newCap);，将数组r中的元素拷贝至一个新的容量为newCap的数组中并赋值给r。 再接下来调用r[i++] = (T)it.next();将集合中的剩余元素（并发修改产生的，索引大于i）填充至新容量的r数组中。 然后进行下一次的迭代，如果newCap容量的数组仍不能完全填充集合中的剩余元素，则i == cap条件会再次成立，会再次进行扩容，直至完全填充。 填充完成后，r数组并不是恰好被填满，因为扩容是直接扩容1.5倍，很可能数组末尾没有任何元素，所以在return时利用三目运算符判断i == r.length是否成立，如果成立则表示恰好填满，直接返回r数组；否则调用Arrays.copyOf(r, i)将r数组拷贝至一个新的容量为i的数组中返回。 修改操作添加元素至集合此抽象类直接抛出UnsupportedOperationException异常。由具体子类去重写add方法来实现向集合中添加元素。 添加元素已经属于集合的个性化操作了，不同的集合保存元素的方式不同，添加的方式也不同，在抽象类中不应有任何具体实现。 123public boolean add(E e) { throw new UnsupportedOperationException();} 从集合中删除指定元素此抽象类中没有任何存储集合元素的介质，唯一能接触到集合元素的是迭代器。 这里就体现出迭代器设计模式的好处了：不用去关心子类采用何种算法去实现迭代，只需要知道hasNext方法可判断集合中是否还有元素；next方法可获取到本次迭代的元素即可。 所以删除指定元素利用的是迭代器的删除方法。我们来看下具体代码实现： 12345678910111213141516171819public boolean remove(Object o) { Iterator&lt;E&gt; it = iterator(); if (o==null) { while (it.hasNext()) { if (it.next()==null) { it.remove(); return true; } } } else { while (it.hasNext()) { if (o.equals(it.next())) { it.remove(); return true; } } } return false;} 分为指定元素为null和非null两种情况：null使用==运算符比较；非null使用equals方法比较。最终都会调用迭代器的remove方法删除指定元素。 所以实现类如果不重写该remove(Object o)方法，则必须在iterator()方法返回的迭代器中实现迭代器的remove方法。否则将抛出UnsupportedOperationException异常。 批量操作判断是否包含指定集合中的全部元素使用迭代器遍历指定集合中的所有元素，遍历过程中调用本抽象类中的contains方法判断是否包含，只要出现一个不包含的情况，返回false，全部包含返回true。 语法糖：JDK5引入的forEach循环实际调用的是迭代器，这是一个语法糖。 123456public boolean containsAll(Collection&lt;?&gt; c) { for (Object e : c) if (!contains(e)) return false; return true;} 添加指定集合至当前集合使用迭代器迭代指定的集合，并将迭代器返回的每个对象添加至当前集合中。 由于当前集合的add方法中直接抛出UnsupportedOperationException异常，所以该方法依赖于具体子类的add方法实现。 1234567public boolean addAll(Collection&lt;? extends E&gt; c) { boolean modified = false; for (E e : c) if (add(e)) modified = true; return modified;} 删除指定集合中的全部元素使用迭代器遍历当前集合，如果迭代器返回的元素包含在指定集合中，则调用迭代器的remove方法将其从当前集合中删除。 所以，子类实现的iterator方法返回的迭代器必须包含remove方法实现。否则调用该方法将抛出UnsupportedOperationException异常。 123456789101112public boolean removeAll(Collection&lt;?&gt; c) { Objects.requireNonNull(c); boolean modified = false; Iterator&lt;?&gt; it = iterator(); while (it.hasNext()) { if (c.contains(it.next())) { it.remove(); modified = true; } } return modified;} 从当前集合中删除指定集合之外的全部元素使用迭代器遍历当前集合，如果迭代器返回的元素不包含在指定集合中，则调用迭代器的remove方法将其重当前集合中删除。 所以，子类实现的iterator方法返回的迭代器必须包含remove方法实现。否则调用该方法将抛出UnsupportedOperationException异常。 123456789101112public boolean retainAll(Collection&lt;?&gt; c) { Objects.requireNonNull(c); boolean modified = false; Iterator&lt;E&gt; it = iterator(); while (it.hasNext()) { if (!c.contains(it.next())) { it.remove(); modified = true; } } return modified;} 清空集合在此抽象类中，是使用迭代器遍历当前集合，调用迭代器的remove方法依次删除每个元素。 但大多数具体实现类会选择重写该方法以提高效率。 1234567public void clear() { Iterator&lt;E&gt; it = iterator(); while (it.hasNext()) { it.next(); it.remove(); }} 转换成字符串此方法是重写Object#toString方法，避免在控制台打印集合时打印出集合对象的地址值。其格式为：最外层用方括号[]括起来，方括号中间填充由迭代器返回的元素，顺序为迭代器返回的顺序。相邻元素中间以英文逗号,分隔。每一个元素通过String.valueOf(Object)方法转换成字符串。 123456789101112131415public String toString() { Iterator&lt;E&gt; it = iterator(); if (! it.hasNext()) return &quot;[]&quot;; StringBuilder sb = new StringBuilder(); sb.append('['); for (;;) { E e = it.next(); sb.append(e == this ? &quot;(this Collection)&quot; : e); if (! it.hasNext()) return sb.append(']').toString(); sb.append(',').append(' '); }} 此方法是大多数集合的toString方法，具体实现类（例如ArrayList）中并未重写该方法。 总结该抽象类虽然提供了很多方法的实现，但所有的实现都是基于iterator和size这两个方法。从模板方法设计模式的角度看，该类定义了集合操作的算法骨架，具体实现还是得由子类去进行实现。","link":"/2020/05/05/javase/base/abstract-collection/"},{"title":"JDK源码解析之Collection","text":"简介Collection接口是Java容器类库中的顶层接口之一。它概括了序列的概念：一种存放一组对象的方式。 JDK不提供Collection接口的直接实现，而是提供更特殊的子接口的实现，比如Set和List。该接口通常用于传递集合并在需要最大通用性的地方操纵它们。 特性所有通用的Collection接口实现类（通常通过其子接口之一来间接实现）应该提供两个标准构造器： void无参构造器：创建一个空集合。 带有Collection类型的单个参数的构造器：创建一个新集合，该集合具有与参数相同的元素。 事实上，后一个构造器允许我们复制任何集合，从而产生所需实现类型的等效集合。 由于接口无法包含构造器，所以无法强制执行此规范，但是Java平台库中的所有通用Collection实现都遵循了该规范。 此接口中包含一些“破坏性”方法：修改集合的操作。如果实现类不支持，将抛出UnsupportedOperationException异常。在这种情况下，如果调用对集合没有影响，则可以但不强制要求这些方法抛出UnsupportedOperationException异常。例如，对不可修改的集合调用addAll(Collection c)方法时，如果待添加的集合c为空，则可以但不是必须抛出异常。 有些集合实现对它们可能包含的元素有限制。例如，有些实现禁止null元素，而有些实现对其元素类型有限制。尝试添加不合法元素会引发未经检查的异常，通常为NullPointerException或ClassCastException。尝试查询不合法元素的存在可能会引发异常，或者可能仅返回false。一些实现类将表现出前者的行为，而某些实现类则表现出后者的行为。更一般的，尝试对不合法元素进行操作，该操作的完成不会导致不合法元素插入集合中，这可能会抛出异常，或者可能会成功，一切都取决于实现类。对于Collection接口的规范来说，这些异常是可选的，并未显式抛出。 该接口中的许多方法都是根据Object#equals(Object o)方法的术语定义的。例如以下方法： 1boolean contains(Object o); 此接口的定义为：当且仅当此集合中至少包含一个元素e，使得o == null ? e == null : o.equals(e)成立。 不应理解为对集合中所有元素都调用equals方法，找到一个满足条件的就可以返回。实现类可以自由进行优化，从而避免equals频繁调用。例如，可以先比较两个元素的哈希码（Object#hashCode()方法的规范保证了具有不相等哈希码的两个对象一定不相等。） 简单的说，各种Collection接口实现类都可以自由利用基础方法（Object类的方法），只要实现类认为合适即可。 接口签名查询操作 int size()：返回集合中的元素个数，最多为Integer.MAX_VALUE。 boolean isEmpty()：如果集合中不包含任何元素则返回true。 boolean contains(Object o)：当且仅当此集合中至少包含一个元素e使得o == null ? e == null : o.equals(e)成立时返回true。 Iterator&lt;E&gt; iterator()：返回此集合中元素的迭代器。 Object[] toArray()：返回包含此集合中所有元素的数组。如果此集合对由其迭代器返回元素的顺序进行了任何保证，则此方法必须按相同的顺序返回元素。操作返回的数组不会对原集合产生任何影响（安全）。此方法充当基于数组的API和基于集合的API之间的桥梁。 修改操作 boolean add(E e)：插入元素e至集合中，如果此集合由于调用该方法发生更改，则返回true；如果集合不允许重复元素，且已经包含e，则返回false。 boolean remove(Object o)：从集合中删除元素o。需满足条件：o == null ? e == null : o.equals(e)。如果存在多个满足条件的元素，则只会删除先找到的那个。 批量操作 boolean containsAll(Collection&lt;?&gt; c)：如果集合中包含指定集合c中的所有元素，则返回true。 boolean addAll(Collection&lt;? extends E&gt; c)：将指定集合c中的所有元素添加至当前集合中。如果在操作过程中修改了指定的集合c，则此操作的行为是不确定的。 boolean removeAll(Collection&lt;?&gt; c)：删除所有包含在指定集合c中的元素。此调用返回后，当前集合中将不包含与指定集合相同的元素。 boolean retainAll(Collection&lt;?&gt; c)：仅保留此集合中包含在指定集合c中的元素。换句话说，此操作完成后，当前集合与指定集合中的元素完全相同。 void clear()：删除此集合中的全部元素。 比较和哈希该接口重新声明了Object#equals和Object#hashCode方法，强制子类必须实现这两个方法。 Collection接口要求hashCode方法返回该集合的哈希码；equals方法比较指定的对象与该集合是否相等。 JDK8新增默认方法JDK8的StreamAPI提供的两个方法。在此顶层接口中定义默认实现，表示所有的集合都可以使用流操作。 获取串行流123default Stream&lt;E&gt; stream() { return StreamSupport.stream(spliterator(), false);} 获取并行流123default Stream&lt;E&gt; parallelStream() { return StreamSupport.stream(spliterator(), true);}","link":"/2020/05/05/javase/base/collection/"},{"title":"JDK源码解析之List","text":"简介List接口继承了Collection接口，更精确的定义了一种集合类型。 该接口定义的是一种有序集合，也称为序列。接口的使用者可以精确控制序列中每个元素的插入位置。可以通过其整数索引（序列中的位置）访问元素，并在序列中搜索元素。 与Set集合不同，序列通常允许重复的元素（equals比较相等）。并且允许多个null元素。 主要接口签名对于Iterator、add、remove、equals和hashCode方法，序列在Collection接口的定义之外，又增加了一些其它定义。同时为了方便起见，序列中还包含了对继承方法的重新声明。 hashCode()Collection接口中的hashCode方法只是定义了返回值是该集合的哈希码（调用的是Object类的hashCode方法）。而List接口明确规定了集合hashCode的计算方式： 123int hashCode = 1;for (E e : list) hashCode = 31*hashCode + (e==null ? 0 : e.hashCode()); 计算每一个元素的hashCode并相加。 这确保了对于任意两个集合list1和list2，如果满足list1.hashCode() == list2.hashCode()，则list1.equals(list2)一定相等。这符合Object#hashCode的规定。 equals(Object o)Collection接口中的equals方法的定义是指定对象与当前集合是否相等，如果实现类希望不使用默认的Object#equals方法的==比较，那么需要重写该方法。 List接口中重写的equals方法规定了判断指定对象与集合是否相等的逻辑：当且仅当指定的对象也是一个List序列，具有相同的大小，并且两个序列中所有对应位置的元素都相等（相等的条件为：e1 == null ? e2 == null : e1.equals(e2)）。 换句话说，如果两个序列中相同索引位置的元素都相等，那么这两个序列被定义为相等。 这个定义确保了equals方法可以在List接口的不同实现类中正常运行。 add(E e)Collection接口中的add方法定义了可以向集合中添加元素。而List接口中定义的add方法规定了元素添加的位置：添加到原集合末尾。 add(int index, E element)List接口中新增的接口签名，在指定索引位置插入指定元素。如果指定索引位置有元素，该元素及其之后的所有元素整体向后移动一位。 addAll(Collection&lt;? extends E&gt; c)同样地，Collection接口中的add方法只是定义了可以向当前集合中插入另一个集合。而List接口明确规定了插入的位置为原集合末尾。 addAll(int index, Collection&lt;? extends E&gt; c)List接口中新增的接口签名，在指定索引位置插入指定集合。如果指定索引位置有元素，该元素及其之后的所有元素整体向后移动指定集合大小位。 remove(int index)List接口中新增的接口签名，删除序列中指定索引位置的元素。如果指定索引位置后还有其它元素，则之后的所有元素整体向前移动一位，最后返回被移除的那个元素。 IteratorList接口提供了一个称为ListIterator的特殊迭代器，除了允许Iterator接口提供的常规操作外，它还允许元素的插入和替换以及双向访问。提供了一种方式来获取从序列的指定位置开始的序列迭代器。 定义了以下两个方法获取序列迭代器： 123ListIterator&lt;E&gt; listIterator();ListIterator&lt;E&gt; listIterator(int index); 其中重载的带一个参数的listIterator(int index)方法从指定索引位置开始返回序列迭代器，它表示在首次调用ListIterator#next方法时将返回指定索引位置的元素。首次调用ListIterator#previous方法时将返回指定索引减一位置的元素。 其它特性List接口定义了四个方法用于对序列元素进行位置（索引）访问。索引从0开始。在某些实现类中，例如LinkedList，这些方法的实现可能在时间上与索引的值成比例增长。因此，如果在编码过程中不知道List的实现类（例如使用反射等）具体是哪个类，则遍历序列可能比通过索引进行索引更加高效。 void add(int index, E element);：在指定索引位置添加指定元素。 E get(int index);：获取指定索引位置的元素。 E remove(int index);：移除指定索引位置的元素。 E set(int index, E element);：给指定索引位置的元素赋值。 另外，List接口还定义了两个用来搜索指定对象的方法，从性能来看，应谨慎使用这些方法。在许多实现类中，它们的执行效率非常低下。 int indexOf(Object o);：返回指定元素第一次出现在该序列中的索引位置。如果不存在则返回-1。 int lastIndexOf(Object o);：返回指定元素最后一次出现在该序列中的索引位置。如果不存在则返回-1。 总结List接口是对Collection接口的进一步定义，明确了一种集合的类型：序列。 接口中的方法一部分是对父接口方法的重新声明，另一部分是为了对序列这种集合建模而增加的接口。 我们学习该接口是为了“从上往下”地对集合框架的特性进行认知。","link":"/2020/05/05/javase/base/list/"},{"title":"JDK源码解析之Cloneable","text":"Cloneable接口简介1、一个类实现java.lang.Cloneable标记性接口以向java.lang.Object#clone()方法指示该方法为该类的实例进行逐域复制是合法的。 2、在未实现java.lang.Cloneable接口的实例上调用java.lang.Object#clone()方法会导致抛出java.lang.CloneNotSupportedException异常。 3、按照约定，实现了java.lang.Cloneable接口的类应使用public公共方法重写java.lang.Object#clone()方法（protected受保护的）。 克隆的基本使用由于java.util.ArrayList类实现了Cloneable接口，我们可以将一个ArrayList集合的数据克隆至另一个新的集合中。 代码如下： 123456789101112131415161718192021222324package com.sunchaser.javase.base.cloneable;import com.google.common.collect.Lists;import java.util.ArrayList;/** * 将一个ArrayList集合的数据克隆至另一个新的集合 * @author sunchaser * @date 2020/4/1 * @since 1.0 */public class ArrayListClone { public static void main(String[] args) { ArrayList&lt;String&gt; list = Lists.newArrayList(); list.add(&quot;Java大法好&quot;); list.add(&quot;PHP是世界上最好的语言&quot;); list.add(&quot;向日葵的自我修养&quot;); Object clone = list.clone(); System.out.println(clone == list); System.out.println(clone); System.out.println(list); }} 代码说明： 创建一个ArrayList集合对象； 往其中添加三个元素； 调用集合对象的clone()方法； 判断克隆后的集合地址与原集合地址是否相等； 分别打印两个集合的内容。 运行程序，可以看到，克隆后的ArrayList集合与旧集合的地址不一样，但其内容相同。 ArrayList#clone()方法源码分析调用了list对象的clone()方法，我们来看下其实现： 1234567891011public Object clone() { try { ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; } catch (CloneNotSupportedException e) { // this shouldn't happen, since we are Cloneable throw new InternalError(e); }} 可以发现其调用的是super.clone()方法得到的一个新的集合。 那么该super指代的是哪个父类呢？ java.util.ArrayList的直接父类是java.util.AbstractList； java.util.AbstractList的直接父类是java.util.AbstractCollection； java.util.AbstractCollection是一个抽象类，实现了java.util.Collection接口，没有继承任何父类。 但是我们却没有在java.util.AbstractList和java.util.AbstractCollection类中找到clone()方法。 事实上可以直接借助IDEA的快捷键得到其是Object类的clone()方法。 只有java.util.ArrayList类中有clone()方法，这也是为什么在基本使用的代码中创建的集合，使用java.util.ArrayList接收而不用顶层接口java.util.List接收的原因。 我们来看下Object#clone()方法的源码： 1protected native Object clone() throws CloneNotSupportedException; 这是一个本地navive方法，使用了protected访问修饰符，并显式抛出了java.lang.CloneNotSupportedException异常。其实现是由底层的c/c++语言进行实现的，我们无法从Java语言层面看到。 克隆出一个ArrayList对象v之后，调用工具类java.util.Arrays的copyOf方法，将原集合的数据elementData和集合大小size传入，拷贝集合元素至克隆集合v的elementData域中。 我们来看下java.util.Arrays#copyOf()方法的实现： 12345678910111213public static &lt;T&gt; T[] copyOf(T[] original, int newLength) { return (T[]) copyOf(original, newLength, original.getClass());}public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) { @SuppressWarnings(&quot;unchecked&quot;) T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;} copyOf方法内部调用的是另一个重载的copyOf方法，判断传入的集合数据elementData类型是不是Object[]数组类型，如果是Object类型则使用new关键字创建一个新的Object[]数组，否则创建其它类型的数组，最后调用System.arraycopy方法将传入的数组元素拷贝至新建的数组中返回。 返回了新的数组之后，将克隆出来的集合v的elementData域引用指向新的数组地址，然后设置修改次数modCount字段为0，得到一个全新的克隆集合返回。 总结Java中所有类都是从java.lang.Object类继承而来的，而Object类提供protected Object clone()方法对对象进行克隆，子类必须实现标记型接口java.lang.Cloneable才支持克隆，当然子类也可以重写Object#clone()方法来实现自己的克隆方式。 对象的克隆有一个基本问题：对象可能包含对其它对象的引用，当使用Object#clone()方法来克隆对象时，此对象对其它对象的引用也被克隆了一份（注意：这里克隆的是引用）。 java.lang.Cloneable接口只起一个作用，就是在运行期指示虚拟机在当前类使用Object#clone()方法是合法的。通过克隆可以得到一个对象的复制。但由于Object类并未实现java.lang.Cloneable接口，所以被克隆的类如果未实现java.lang.Cloneable接口，在调用java.lang.Object#clone()方法时会抛出java.lang.CloneNotSupportedException异常。","link":"/2020/04/26/javase/base/cloneable/"},{"title":"深入理解深浅拷贝","text":"无论是java.lang.Object#clone()方法还是自己实现的克隆方法，都存在着浅拷贝和深拷贝的问题。 那么什么是浅拷贝和深拷贝呢？ 举一个不太恰当的例子：大家都玩过英雄联盟这款游戏吧？英雄联盟中的孙悟空这个英雄的W技能是“真假猴王”：孙悟空进入隐形状态片刻，并留下一个替身，替身在片刻后会对其周围的敌人造成魔法伤害。如果玩家攻击替身，替身掉血但本身不掉血。这似乎可以理解成深拷贝。 浅拷贝和深拷贝简介 浅拷贝：只拷贝被克隆对象中按值传递的属性数据，不拷贝引用类型的属性数据。换言之，所有对其它对象的引用仍指向原来的对象，拷贝的是栈内的引用而不是堆内的对象。 深拷贝：除了浅拷贝需要克隆的值传递的属性数据之外，还会拷贝引用类型所指向的对象，即拷贝的引用会指向新的对象。换言之，深拷贝把待克隆的对象所引用的对象全都拷贝了一遍。 深拷贝要深入到多少层，这是一个需要根据实际情况来决定的问题。当拷贝至无引用对象的时候，就可称之为完全深拷贝。此外，深拷贝中还可能会出现循环引用的问题，需要仔细处理。 java.lang.Object#clone()浅拷贝为了证实该方法是浅拷贝，我们先来尝试设计一下英雄，首先创建一个LOL英雄接口，它包含两个方法：攻击和被攻击，攻击时法力值减少，被攻击时生命值减少。代码如下： 123456789101112131415161718192021package com.sunchaser.javase.base.cloneable;/** * LOL英雄接口 * @author sunchaser * @date 2020/4/7 * @since 1.0 */public interface LolHero { /** * 攻击 * @param lolSkill 使用的技能 */ void attack(LolSkill lolSkill); /** * 受到其它英雄攻击 */ void beAttacked();} 然后我们来定义技能类，技能包括按键key、技能名称和技能描述： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.sunchaser.javase.base.cloneable;/** * LOL英雄的技能类 * @author sunchaser * @date 2020/4/7 * @since 1.0 */public class LolSkill { private String key; private String name; private String desc; public LolSkill() { } public LolSkill(String key, String name, String desc) { this.key = key; this.name = name; this.desc = desc; } public String getKey() { return key; } public String getName() { return name; } public String getDesc() { return desc; } @Override public String toString() { final StringBuilder sb = new StringBuilder(&quot;LolSkill{&quot;); sb.append(&quot;key='&quot;).append(key).append('\\''); sb.append(&quot;, name='&quot;).append(name).append('\\''); sb.append(&quot;, desc='&quot;).append(desc).append('\\''); sb.append('}'); return sb.toString(); }} 接下来我们来定义生命值和法力值类。 生命值类： 1234567891011121314151617181920212223242526272829303132333435package com.sunchaser.javase.base.cloneable;/** * 英雄生命值类 * @author sunchaser * @date 2020/4/7 * @since 1.0 */public class LifeValue { private Integer lifeValue; public LifeValue() { } public LifeValue(Integer lifeValue) { this.lifeValue = lifeValue; } public Integer getLifeValue() { return lifeValue; } public LifeValue setLifeValue(Integer lifeValue) { this.lifeValue = lifeValue; return this; } @Override public String toString() { final StringBuilder sb = new StringBuilder(&quot;LifeValue{&quot;); sb.append(&quot;lifeValue=&quot;).append(lifeValue); sb.append('}'); return sb.toString(); }} 法力值类： 1234567891011121314151617181920212223242526272829303132333435package com.sunchaser.javase.base.cloneable;/** * 英雄法力值类 * @author sunchaser * @date 2020/4/7 * @since 1.0 */public class Mana { private Integer mana; public Mana() { } public Mana(Integer mana) { this.mana = mana; } public Integer getMana() { return mana; } public Mana setMana(Integer mana) { this.mana = mana; return this; } @Override public String toString() { final StringBuilder sb = new StringBuilder(&quot;Mana{&quot;); sb.append(&quot;mana=&quot;).append(mana); sb.append('}'); return sb.toString(); }} 最后我们来创建孙悟空英雄类，它实现了自定义的LOL英雄接口和java.lang.Cloneable接口，包含英雄名称、生命值、法力值和四个技能等属性，重写了java.lang.Cloneable#clone()方法，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.sunchaser.javase.base.cloneable;/** * 英雄：孙悟空 * @author sunchaser * @date 2020/4/7 * @since 1.0 */public class SunWuKong implements LolHero,Cloneable { /** * 名字 */ private String name = &quot;齐天大圣-孙悟空&quot;; /** * 生命值 */ private LifeValue sunWuKongLifeValue; /** * 法力值 */ private Mana sunWuKongMana; /* skill */ private LolSkill Q = new LolSkill(&quot;Q&quot;,&quot;粉碎打击&quot;,&quot;孙悟空的下次攻击造成额外物理伤害，获得距离加成，并暂时减少敌人的护甲。&quot;); private LolSkill W = new LolSkill(&quot;W&quot;,&quot;真假猴王&quot;,&quot;孙悟空进入隐形状态片刻，并留下一个替身，替身在片刻后会对其周围的敌人造成魔法伤害。&quot;); private LolSkill E = new LolSkill(&quot;E&quot;,&quot;腾云突击&quot;,&quot;孙悟空突进至目标敌人处，并变出最多2个分身，攻击附近目标。对每个击中的目标造成物理伤害。&quot;); private LolSkill R = new LolSkill(&quot;R&quot;,&quot;大闹天宫&quot;,&quot;孙悟空展开金箍棒，不停地旋转，对敌人造成伤害并将其击飞。在此期间，孙悟空速度持续增加。&quot;); @Override public Object clone() throws CloneNotSupportedException { return super.clone(); } @Override public void attack(LolSkill lolSkill) { System.out.println(&quot;使用了&quot; + lolSkill + &quot;进行了攻击&quot;); } @Override public void beAttacked() { Integer oldSunWuKongLifeValue = this.sunWuKongLifeValue.getLifeValue() - 1; this.sunWuKongLifeValue.setLifeValue(oldSunWuKongLifeValue); } public String getName() { return name; } public LifeValue getSunWuKongLifeValue() { return sunWuKongLifeValue; } public SunWuKong setSunWuKongLifeValue(LifeValue sunWuKongLifeValue) { this.sunWuKongLifeValue = sunWuKongLifeValue; return this; } public Mana getSunWuKongMana() { return sunWuKongMana; } public SunWuKong setSunWuKongMana(Mana sunWuKongMana) { this.sunWuKongMana = sunWuKongMana; return this; } @Override public String toString() { final StringBuilder sb = new StringBuilder(&quot;SunWuKong{&quot;); sb.append(&quot;name='&quot;).append(name).append('\\''); sb.append(&quot;, sunWuKongLifeValue=&quot;).append(sunWuKongLifeValue); sb.append(&quot;, sunWuKongMana=&quot;).append(sunWuKongMana); sb.append('}'); return sb.toString(); }} 一切准备就绪，我们来测试一下： 123456789101112131415161718192021222324252627package com.sunchaser.javase.base.cloneable;/** * 深浅拷贝测试 * @author sunchaser * @date 2020/4/7 * @since 1.0 */public class DepthCopyTest { public static void main(String[] args) throws CloneNotSupportedException { // 创建一个孙悟空英雄对象，并赋予生命值1000，法力值2000 SunWuKong sunWuKong = new SunWuKong(); sunWuKong.setSunWuKongLifeValue(new LifeValue(1000)) .setSunWuKongMana(new Mana(2000)); // 克隆一个替身 SunWuKong clone = (SunWuKong) sunWuKong.clone(); System.out.println(sunWuKong); System.out.println(clone); System.out.println(sunWuKong == clone); // 替身受到攻击 clone.beAttacked(); System.out.println(sunWuKong); System.out.println(clone); System.out.println(sunWuKong == clone); }} 观察控制台输出： 123456SunWuKong{name='齐天大圣-孙悟空', sunWuKongLifeValue=LifeValue{lifeValue=1000}, sunWuKongMana=Mana{mana=2000}}SunWuKong{name='齐天大圣-孙悟空', sunWuKongLifeValue=LifeValue{lifeValue=1000}, sunWuKongMana=Mana{mana=2000}}falseSunWuKong{name='齐天大圣-孙悟空', sunWuKongLifeValue=LifeValue{lifeValue=999}, sunWuKongMana=Mana{mana=2000}}SunWuKong{name='齐天大圣-孙悟空', sunWuKongLifeValue=LifeValue{lifeValue=999}, sunWuKongMana=Mana{mana=2000}}false 孙悟空“替身”受到攻击后，“真身”的生命值也减少了。可以看出真身和替身引用的是同一个生命值对象。足以证实java.lang.Cloneable#clone()方法是浅拷贝。 深拷贝的实现深拷贝则不能简单的在重写的clone方法内直接调用super.clone()，需要将当前类的每一个引用对象都进行拷贝，如果引用对象还包含引用对象，则需进行多层拷贝。 当前类的每一个引用对象均需实现java.lang.Cloneable接口并重写其clone方法。 我们来看下SunWuKong类的引用对象：LifeValue和Mana。 LifeValue代码实现为： 123456789101112131415161718package com.sunchaser.javase.base.cloneable;/** * 英雄生命值类 * @author sunchaser * @date 2020/4/7 * @since 1.0 */public class LifeValue implements Cloneable { private Integer lifeValue; @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } ......} Mana代码实现为： 123456789101112131415161718package com.sunchaser.javase.base.cloneable;/** * 英雄法力值类 * @author sunchaser * @date 2020/4/7 * @since 1.0 */public class Mana implements Cloneable { private Integer mana; @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } ......} 此时SunWuKong类的clone方法实现如下： 123456789101112131415161718192021222324252627282930313233343536373839package com.sunchaser.javase.base.cloneable;/** * 英雄：孙悟空 * @author sunchaser * @date 2020/4/7 * @since 1.0 */public class SunWuKong implements LolHero,Cloneable { /** * 名字 */ private String name = &quot;齐天大圣-孙悟空&quot;; /** * 生命值 */ private LifeValue sunWuKongLifeValue; /** * 法力值 */ private Mana sunWuKongMana; ...... @Override public Object clone() throws CloneNotSupportedException { SunWuKong clone = (SunWuKong) super.clone(); LifeValue lifeValueClone = (LifeValue) this.sunWuKongLifeValue.clone(); Mana manaClone = (Mana) this.sunWuKongMana.clone(); clone.setSunWuKongLifeValue(lifeValueClone); clone.setSunWuKongMana(manaClone); return clone; } ......} 我们再来看下输出结果： 123456SunWuKong{name='齐天大圣-孙悟空', sunWuKongLifeValue=LifeValue{lifeValue=1000}, sunWuKongMana=Mana{mana=2000}}SunWuKong{name='齐天大圣-孙悟空', sunWuKongLifeValue=LifeValue{lifeValue=1000}, sunWuKongMana=Mana{mana=2000}}falseSunWuKong{name='齐天大圣-孙悟空', sunWuKongLifeValue=LifeValue{lifeValue=1000}, sunWuKongMana=Mana{mana=2000}}SunWuKong{name='齐天大圣-孙悟空', sunWuKongLifeValue=LifeValue{lifeValue=999}, sunWuKongMana=Mana{mana=2000}}false 替身对象受到攻击后，原对象生命值不变，替身对象生命值减少。这就是深拷贝的实现。 总结深拷贝要求被拷贝的类的每一个引用对象都实现java.lang.Cloneable接口并实现clone方法，所以当需要实现深拷贝时，需要进行对象功能的全面考虑，特别是当引用对象还包含引用对象的多层嵌套时，需要结合对象的功能进行考虑。 本篇文章所有源代码地址：传送门","link":"/2020/04/26/javase/base/depth-shallow-copy/"},{"title":"JDK源码解析之RandomAccess","text":"简介该接口是List实现使用的标记型接口，表明它们支持快速（通常是恒定时间）随机访问。此接口的主要目的是允许通用算法更改其行为，以应用于随机访问列表或顺序访问列表时提供良好的性能。 当应用于顺序访问列表（例如LinkedList）时，用于操纵随机访问列表（例如ArrayList）的最佳算法会产生二次行为。鼓励使用通用列表算法，先检查给定列表是否为该接口的实例，然后再应用一种算法（如果将其应用于顺序访问列表则性能较差），并在必要时更改其行为以保证可接受的性能。 公认的是，随机访问和顺序访问之间的区别通常是模糊的。例如，某些List实现在变得庞大的情况下提供渐进线性的访问时间，但实际上却是恒定的访问时间。这样的List实现通常应该实现此接口。根据经验，如果满足以下条件，则List实现应实现此接口： 对于类的典型实例，此循环： 12for (int i=0, n=list.size(); i &lt; n; i++) list.get(i); 比这个循环运行更快： 12for (Iterator i=list.iterator(); i.hasNext(); ) i.next(); ArrayList效率比较ArrayList实现了RandomAccess接口，根据RandomAccess接口定义，使用fori循环遍历比迭代器遍历更快。下面我们来进行验证。 创建一个ArrayList集合并填充一千万个元素，分别使用fori循环和迭代器进行遍历，计算其运行时间。完整代码如下： 12345678910111213141516171819202122232425262728293031323334package com.sunchaser.javase.base.randomaccess;import java.util.*;/** * 随机访问和迭代器访问效率比较 * @author sunchaser * @date 2020/4/26 * @since 1.0 */public class RandomIteratorCompare { public static void main(String[] args) { // init list data List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10000000; i++) { list.add(String.valueOf(i)); } // random access long randomStartTime = System.currentTimeMillis(); for (int i = 0,size = list.size(); i &lt; size; i++) { list.get(i); } long randomEndTime = System.currentTimeMillis(); System.out.println(&quot;random access:&quot; + (randomEndTime - randomStartTime)); // sequential access long sequentialStartTime = System.currentTimeMillis(); Iterator&lt;String&gt; iterator = list.iterator(); while (iterator.hasNext()) { iterator.next(); } long sequentialEndTime = System.currentTimeMillis(); System.out.println(&quot;sequential access:&quot; + (sequentialEndTime - sequentialStartTime)); }} 运行输入： 12random access:6sequential access:11 结果显而易见，ArrayList使用迭代器遍历效率略低于fori遍历。 LinkedList效率比较当应用于LinkedList时，用于操纵ArrayList的最佳算法（fori循环遍历）会产生二次行为。ListedList未实现RandomAccess接口。 我们来创建一个LinkedList，对其填充元素并分别使用fori循环和迭代器进行遍历。代码如下： 1234567891011121314151617181920// init LinkedList dataList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();for (int i = 0; i &lt; 100000; i++) { linkedList.add(String.valueOf(i));}// random accesslong linkedListRandomStartTime = System.currentTimeMillis();for (int i = 0,size = linkedList.size(); i &lt; size; i++) { linkedList.get(i);}long linkedListRandomEndTime = System.currentTimeMillis();System.out.println(&quot;random access:&quot; + (linkedListRandomEndTime - linkedListRandomStartTime));// sequential accesslong linkedListSequentialStartTime = System.currentTimeMillis();Iterator&lt;String&gt; linkedListIterator = arrayList.iterator();while (linkedListIterator.hasNext()) { linkedListIterator.next();}long linkedListSequentialEndTime = System.currentTimeMillis();System.out.println(&quot;sequential access:&quot; + (linkedListSequentialEndTime - linkedListSequentialStartTime)); 运行后控制台输出： 12random access:11031sequential access:10 可以看到，fori循环遍历所耗费的时间已经远远超过了迭代器遍历，这说明适用于ArrayList的最佳算法不再适用于LinkedList，这与集合的内部数据结构和get方法实现有关。 总结实现了RandomAccess接口的ArrayList使用fori循环遍历效率更高，而LinkedList使用迭代器遍历效率极高。","link":"/2020/04/26/javase/base/randomaccess/"},{"title":"JDK源码解析之Serializable","text":"前言什么是序列化和反序列化？ 序列化：将对象的二进制数据流写入硬盘（或用于网络传输）； 反序列化：从硬盘（网络）中将对象的二进制数据流读取出来转化成对象。 简介实现了java.io.serializable标记性接口的类是可序列化的，可序列化类的所有子类型都是可序列化的。 源码12public interface Serializable {} 在Java中序列化接口是一个空接口，仅用于标记可序列化的语义。 序列化UID字段：serialVersionUID实现了java.io.Serializable接口的类，如果未显式进行声明，在编译期JVM将使用自己的算法生成默认的serialVersionUID字段。 默认的serialVersionUID生成算法对类的详细信息非常敏感，因不同的JVM实现而异，并且在反序列化过程中会可能会导致意外的java.io.InvalidClassException异常。 当进行序列化操作时，会将此serialVersionUID序列化进二进制流中； 当进行反序列化操作时，如果用来接收对象的类中的serialVersionUID字段值与序列化时的值不一致，会导致反序列化失败。 代码演示首先创建一个用来序列化测试的类SerializableClass，并实现序列化接口。 123456789101112131415161718192021222324252627282930313233343536373839404142package com.sunchaser.javase.base.serizlizable;import java.io.Serializable;/** * 序列化类 * @author sunchaser * @date 2020/3/19 * @since 1.0 */public class SerializableClass implements Serializable { private static final long serialVersionUID = 5135631042912401553L; private String name; private Integer age; public String getName() { return name; } public SerializableClass setName(String name) { this.name = name; return this; } public Integer getAge() { return age; } public SerializableClass setAge(Integer age) { this.age = age; return this; } @Override public String toString() { final StringBuilder sb = new StringBuilder(&quot;SerializableClass{&quot;); sb.append(&quot;name='&quot;).append(name).append('\\''); sb.append(&quot;, age=&quot;).append(age); sb.append('}'); return sb.toString(); }} 接下来创建测试类来进行序列化。首先在当前类所在包中创建serializableClass.txt文件。之后我们序列化写对象写入该文件中，反序列化从该文件中读对象。 使用以下代码即可获取txt文件的绝对路径： 123// 获取当前类所在包中的serializableClass.txt文件路径String path = SerializableTest.class.getResource(&quot;&quot;).getPath();path = path.replace(&quot;target/classes&quot;,&quot;src/main/java&quot;) + &quot;serializableClass.txt&quot;; 接下来创建用来序列化的对象： 1SerializableClass sc = new SerializableClass().setName(&quot;序列化&quot;).setAge(10); 然后我们创建序列化的方法writeObject，将对象和txt文件绝对路径传入进行写对象操作： 12345678910111213141516171819202122private static void writeObject(SerializableClass sc,String path) { FileOutputStream fos = null; ObjectOutputStream ops = null; try { fos = new FileOutputStream(path); ops = new ObjectOutputStream(fos); ops.writeObject(sc); } catch (Exception e) { e.printStackTrace(); } finally { try { if (ops != null) { ops.close(); } if (fos != null) { fos.close(); } } catch (IOException e) { e.printStackTrace(); } }} 在main方法中调用即可将对象写入文本文件中，可打开文本文件查看（有点乱码）。 下面我们来创建反序列化的方法readObject，将文本文件路径传入进行读对象操作： 1234567891011121314151617181920212223private static void readObject(String path) { FileInputStream fis = null; ObjectInputStream ois = null; try { fis = new FileInputStream(path); ois = new ObjectInputStream(fis); SerializableClass sc = (SerializableClass) ois.readObject(); System.out.println(sc); } catch (Exception e) { e.printStackTrace(); } finally { try { if (ois != null) { ois.close(); } if (fis != null) { fis.close(); } } catch (IOException e) { e.printStackTrace(); } }} 调用该方法后可在控制台看到对象打印： 1SerializableClass{name='序列化', age=10} 反序列化失败演示先调用writeObject方法将对象序列化写入文本文件，然后去修改SerializableClass的serialVersionUID字段的值，再去调用readObject方法从文本文件中反序列化读对象。这时反序列化就会失败，并抛出java.io.InvalidClassException异常。 主要异常堆栈信息如下： 123java.io.InvalidClassException: com.sunchaser.javase.base.serizlizable.SerializableClass; local class incompatible: stream classdesc serialVersionUID = 5135632042912401553, local class serialVersionUID = 5135631042912401553 IDEA中生成serialVersionUID打开IDEA，选择File-&gt;Settings-&gt;Editor-&gt;Inspections，在搜索框中输入serialVersionUID，找到Serializable class without 'serialVersionUID'，进行勾选，点击apply-&gt;OK进行保存。 设置之后如果实现了Serializable接口的类未定义serialVersionUID字段，则类名处会有黄色警告，输入光标移动至类名处按下快捷键alt+enter会有生成serialVersionUID的快捷方式。 总结本文完整代码地址：传送门 Serializable接口实际上就是一个标记，实现了该接口的类才允许被序列化和反序列化，而serialVersionUID字段则像是一个“版本号”，序列化时将该字段一起存至二进制流中，反序列化时用该字段来判断是否是存进去时的状态。它的作用其实就是判断反序列化出来的对象是不是原来序列化的对象。","link":"/2020/03/21/javase/base/serializable/"},{"title":"修炼xxl-job之调度中心—初始化失败任务管理中心","text":"调度中心启动时主要执行了XxlJobScheduler.init()方法，该方法中有六个初始化动作，这篇文章来分析第三个初始化动作：初始化失败任务管理中心。其关键调用代码为：JobFailMonitorHelper.getInstance().start(); 源码分析来看com.xxl.job.admin.core.thread.JobFailMonitorHelper类的源码。 成员变量先看类的主要成员变量： 私有slf4j日志对象； 私有静态JobFailMonitorHelper类实例对象：instance； 私有成员变量：Thread类对象monitorThread； 私有布尔变量toStop，初始化为false。 成员方法 实例instance的公有静态访问器getInstance()； 公有start()方法； 公有toStop()方法。 私有failAlarm()方法，用于失败告警。 其中公有静态访问器getInstance()和私有静态JobFailMonitorHelper类实例对象instance共同形成了饿汉式单例模式。 start()方法解析可以发现该类的主要实现是在start()方法中，先折叠一些实现我们来看下整体。 给私有成员变量Thread类对象monitorThread赋值，即创建一个子线程：实现Runnable接口并重写其run方法； 将其设置为守护线程； 设置线程名为：xxl-job, admin JobFailMonitorHelper； 调用线程的start()方法启动线程。 这其实是一个守护线程。 我们继续来看子线程重写的run方法的具体实现： 看起来实现有点长，我们逐渐将其拆解来分析。 1while (!toStop) { 循环，判断的条件为私有布尔变量toStop的非，而toStop被初始化为了false，所以这是一个死循环。 1List&lt;Long&gt; failLogIds = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().findFailJobLogIds(1000); 从配置“容器”com.xxl.job.admin.core.conf.XxlJobAdminConfig对象中拿到com.xxl.job.admin.dao.XxlJobLogDao对象，调用findFailJobLogIds(1000)方法。这是Mybatis持久层的方法，来看一下其实现： 123456789101112131415/* Mapper接口 */public List&lt;Long&gt; findFailJobLogIds(@Param(&quot;pagesize&quot;) int pagesize);/* xml实现 */&lt;select id=&quot;findFailJobLogIds&quot; resultType=&quot;long&quot; &gt; SELECT id FROM `xxl_job_log` WHERE !( (trigger_code in (0, 200) and handle_code = 0) OR (handle_code = 200) ) AND `alarm_status` = 0 ORDER BY id ASC LIMIT #{pagesize}&lt;/select&gt; 传入的参数pagesize为1000，SQL的查询条件：非（调度成功 或 执行成功）。 所以此处实际上就是分页查询1000条失败任务日志记录的failLogIds。 如果存在失败的日志记录则进行遍历处理，我们往下看处理逻辑： 123456int lockRet = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateAlarmStatus(failLogId, 0, -1);if (lockRet &lt; 1) { continue;}XxlJobLog log = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().load(failLogId);XxlJobInfo info = XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().loadById(log.getJobId()); 调用XxlJobLogDao的updateAlarmStatus方法，来看下其Mybatis的实现： 12345678910public int updateAlarmStatus(@Param(&quot;logId&quot;) long logId, @Param(&quot;oldAlarmStatus&quot;) int oldAlarmStatus, @Param(&quot;newAlarmStatus&quot;) int newAlarmStatus);&lt;update id=&quot;updateAlarmStatus&quot; &gt; UPDATE xxl_job_log SET `alarm_status` = #{newAlarmStatus} WHERE `id`= #{logId} AND `alarm_status` = #{oldAlarmStatus}&lt;/update&gt; CAS乐观锁的方式将alarm_status字段从0更新为-1。 思考：这里为什么使用乐观锁？有什么作用？ 猜想：支持调度集群部署，高可用。 如果乐观锁“加锁”成功，则根据失败任务failLogId加载任务日志信息和任务信息。 得到了任务必要信息后就可以进行处理了，包括重试或告警，我们继续往下看： 123456if (log.getExecutorFailRetryCount() &gt; 0) { JobTriggerPoolHelper.trigger(log.getJobId(), TriggerTypeEnum.RETRY, (log.getExecutorFailRetryCount()-1), log.getExecutorShardingParam(), log.getExecutorParam()); String retryMsg = &quot;&lt;br&gt;&lt;br&gt;&lt;span style=\\&quot;color:#F39C12;\\&quot; &gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;+ I18nUtil.getString(&quot;jobconf_trigger_type_retry&quot;) +&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; &lt;/span&gt;&lt;br&gt;&quot;; log.setTriggerMsg(log.getTriggerMsg() + retryMsg); XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateTriggerInfo(log);} 判断日志信息中执行器失败重试次数是否仍大于零，是则进行重试。 重试即重新进行调度，调用JobTriggerPoolHelper类的trigger()方法，传入了五个参数，我们来分别解释一下： log.getJobId()：任务信息表自增主键。 TriggerTypeEnum.RETRY：执行类型：重试。 (log.getExecutorFailRetryCount()-1)：当前重试次数减一，这里传入是为了执行时存入日志表，当再次失败时可确保重试次数。 log.getExecutorShardingParam()：执行器分片参数（分片任务用到）。 log.getExecutorParam()：执行器执行参数。 关于任务调度执行本篇文章不做详细介绍，只需知道这里触发了任务执行，并将减一后的重试次数存入了日志，若这次执行仍然失败，则可被重新查出并根据剩余重试次数进行处理。 重试完成后更新本条记录的调度日志trigger_msg字段。 然后进行告警处理，无论是否有重试都会进行告警处理。 我们来看告警的代码： 1234567891011121314int newAlarmStatus = 0; // 告警状态：0-默认、-1=锁定状态、1-无需告警、2-告警成功、3-告警失败if (info!=null &amp;&amp; info.getAlarmEmail()!=null &amp;&amp; info.getAlarmEmail().trim().length()&gt;0) { boolean alarmResult = true; try { alarmResult = failAlarm(info, log); } catch (Exception e) { alarmResult = false; logger.error(e.getMessage(), e); } newAlarmStatus = alarmResult?2:3;} else { newAlarmStatus = 1;}XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateAlarmStatus(failLogId, -1, newAlarmStatus); 只有配置了告警邮箱才进行告警，核心逻辑是调用了私有成员方法failAlarm，根据调用情况得到新的告警状态，最后使用CAS的方式更新日志记录表，将alarm_status字段从-1更新为新的告警状态。 最后阻塞当前子线程10秒，一次循环就结束了。 而私有成员方法failAlarm的主要逻辑是发送邮件，调度中心xxl-job-admin项目配置文件中可配置告警发件邮箱，Web管理后台界面添加任务时可填写告警收件人邮箱。该方法有一行代码如下： 1Set&lt;String&gt; emailSet = new HashSet&lt;String&gt;(Arrays.asList(info.getAlarmEmail().split(&quot;,&quot;))); 从而得知在管理后台界面添加任务时可填写多个告警收件人邮箱，用英文逗号分隔即可，会自动去重。 我们可在该方法中实现自定义的告警方式，例如钉钉机器人等。 总结用以下一张图来对失败任务管理中心进行归纳总结。","link":"/2020/03/03/middleware/xxl-job/job-fail-monitor/"},{"title":"修炼xxl-job之调度中心—初始化注册中心“心跳续约”服务","text":"调度中心启动时主要执行了XxlJobScheduler.init()方法，该方法中有六个初始化动作，这篇文章来分析第二个初始化动作：初始化注册中心“心跳续约”服务。其关键调用代码为：JobRegistryMonitorHelper.getInstance().start(); 源码分析来看com.xxl.job.admin.core.thread.JobRegistryMonitorHelper类的源码。 成员变量先看类的成员变量： 私有slf4j日志对象； 私有静态JobRegistryMonitorHelper类实例对象：instance； 私有成员变量：Thread类对象registryThread； 私有布尔变量toStop，初始化为false。 成员方法 实例instance的公有静态访问器getInstance()； 公有start()方法； 公有toStop()方法。 其中公有静态访问器getInstance()和私有静态JobRegistryMonitorHelper类实例对象instance共同形成了饿汉式单例模式。 start()方法解析可以发现该类的主要实现是在start()方法中，先折叠一些实现我们来看下整体。 给私有成员变量Thread类对象registryThread赋值，即创建一个子线程：实现Runnable接口并重写其run方法； 将其设置为守护线程； 设置线程名为：xxl-job, admin JobRegistryMonitorHelper； 调用线程的start()方法启动线程。 这其实是一个守护线程。 我们继续来看子线程重写的run方法的具体实现： 看起来实现有点长，我们逐渐将其拆解来分析。 1while (!toStop) { 循环，判断的条件为私有布尔变量toStop的非，而toStop被初始化为了false，所以这是一个死循环。 1List&lt;XxlJobGroup&gt; groupList = XxlJobAdminConfig.getAdminConfig().getXxlJobGroupDao().findByAddressType(0); 从配置“容器”com.xxl.job.admin.core.conf.XxlJobAdminConfig对象中拿到com.xxl.job.admin.dao.XxlJobGroupDao对象，调用findByAddressType(0)方法。这是Mybatis持久层的方法，来看一下其实现： 12345678910/* Mapper接口 */public List&lt;XxlJobGroup&gt; findByAddressType(@Param(&quot;addressType&quot;) int addressType);/* xml实现 */&lt;select id=&quot;findByAddressType&quot; parameterType=&quot;java.lang.Integer&quot; resultMap=&quot;XxlJobGroup&quot;&gt; SELECT &lt;include refid=&quot;Base_Column_List&quot; /&gt; FROM xxl_job_group AS t WHERE t.address_type = #{addressType} ORDER BY t.order ASC&lt;/select&gt; 传入的参数addressType为0，SQL的含义为：查询xxl_job_group表中address_type字段为0的数据并按order字段升序排序。 我们可以去初始化sql脚本中寻找该字段的含义：执行器地址类型：0=自动注册、1=手动录入。 所以此处代码的作用是：查询地址类型为自动注册的执行器信息列表。 如果查询出的执行器列表不为空则继续往下执行。 123456List&lt;Integer&gt; ids = XxlJobAdminConfig.getAdminConfig() .getXxlJobRegistryDao() .findDead(RegistryConfig.DEAD_TIMEOUT, new Date());if (ids!=null &amp;&amp; ids.size()&gt;0) { XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().removeDead(ids);} 调用XxlJobRegistryDao的findDead方法，传入的参数为： RegistryConfig.DEAD_TIMEOUT：超时时间，值为90； new Date()：当前时间对象。 来看一下Mybatis的实现： 12345678public List&lt;Integer&gt; findDead(@Param(&quot;timeout&quot;) int timeout, @Param(&quot;nowTime&quot;) Date nowTime); &lt;select id=&quot;findDead&quot; parameterType=&quot;java.util.HashMap&quot; resultType=&quot;java.lang.Integer&quot; &gt; SELECT t.id FROM xxl_job_registry AS t WHERE t.update_time &lt;![CDATA[ &lt; ]]&gt; DATE_ADD(#{nowTime},INTERVAL -#{timeout} SECOND)&lt;/select&gt; 查询的是主键id列表，关键的是where条件，xxl_job_registry表的update_time字段小于传入的当前时间减去传入的超时时间90秒。 其含义为：查询出90秒内未更新时间的任务id集合列表。 思考：这里查询时为什么选择传入Java时间而不是直接用MySQL的NOW()函数获取当前时间？ 解答：防止MySQL服务器和调度中心服务器的时钟不同步。 如果查到了记录，则调用XxlJobRegistryDao的removeDead方法。来看下其Mybatis实现： 123456789public int removeDead(@Param(&quot;ids&quot;) List&lt;Integer&gt; ids); &lt;delete id=&quot;removeDead&quot; parameterType=&quot;java.lang.Integer&quot; &gt; DELETE FROM xxl_job_registry WHERE id in &lt;foreach collection=&quot;ids&quot; item=&quot;item&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot; &gt; #{item} &lt;/foreach&gt;&lt;/delete&gt; 删除任务id列表对应的xxl_job_registry记录。 看到这里，我们应该理解到这实际上是“心跳”机制。“心跳”的最长时间间隔为90秒。 继续往下看，初始化了一个局部HashMap对象： 1234HashMap&lt;String, List&lt;String&gt;&gt; appAddressMap = new HashMap&lt;String, List&lt;String&gt;&gt;();List&lt;XxlJobRegistry&gt; list = XxlJobAdminConfig.getAdminConfig() .getXxlJobRegistryDao() .findAll(RegistryConfig.DEAD_TIMEOUT, new Date()); 随即调用XxlJobRegistryDao的findAll方法查询出了一个List&lt;XxlJobRegistry&gt;集合，我们来看下查询条件： 12345678public List&lt;XxlJobRegistry&gt; findAll(@Param(&quot;timeout&quot;) int timeout, @Param(&quot;nowTime&quot;) Date nowTime); &lt;select id=&quot;findAll&quot; parameterType=&quot;java.util.HashMap&quot; resultMap=&quot;XxlJobRegistry&quot;&gt; SELECT &lt;include refid=&quot;Base_Column_List&quot; /&gt; FROM xxl_job_registry AS t WHERE t.update_time &lt;![CDATA[ &gt; ]]&gt; DATE_ADD(#{nowTime},INTERVAL -#{timeout} SECOND)&lt;/select&gt; 重点是where条件：更新时间update_time大于当前时间减去“死亡”超时时间90秒。 即：查询上次“心跳”时间在90秒以内的注册列表。 实际上这是在做执行器“心跳”续约，类似于微服务中的服务续约。 我们继续往下看： 123456789101112131415if (list != null) { for (XxlJobRegistry item: list) { if (RegistryConfig.RegistType.EXECUTOR.name().equals(item.getRegistryGroup())) { String appName = item.getRegistryKey(); List&lt;String&gt; registryList = appAddressMap.get(appName); if (registryList == null) { registryList = new ArrayList&lt;String&gt;(); } if (!registryList.contains(item.getRegistryValue())) { registryList.add(item.getRegistryValue()); } appAddressMap.put(appName, registryList); } }} 如果查询到有未“死亡”的注册列表，则对其进行“续约”： 遍历查询出的注册列表。 如果注册组为执行器（这里注意到枚举RegistType有两个值：EXECUTOR（执行器）和ADMIN（调度中心））。 取出注册表的注册键（xxl_job_registry表中的registry_key字段）：即执行器名称appName。 先尝试从局部map变量中取出该执行器名称对应注册地址集合，若没有则新建一个空集合（懒加载思想）。 判断从map中取出的注册地址集合是否包含当前遍历的注册表的注册值（xxl_job_registry表中的registry_value字段），若不包含则添加至集合（去重）。 将执行器名称appName和注册地址集合映射至局部map变量。 映射至局部map变量后，开始执行真正的“续约”动作： 1234567891011121314for (XxlJobGroup group: groupList) { List&lt;String&gt; registryList = appAddressMap.get(group.getAppName()); String addressListStr = null; if (registryList!=null &amp;&amp; !registryList.isEmpty()) { Collections.sort(registryList); addressListStr = &quot;&quot;; for (String item:registryList) { addressListStr += item + &quot;,&quot;; } addressListStr = addressListStr.substring(0, addressListStr.length()-1); } group.setAddressList(addressListStr); XxlJobAdminConfig.getAdminConfig().getXxlJobGroupDao().update(group);} 遍历从xxl_job_group表中查询出的自动注册执行器的信息列表。 从局部map变量中取出当前遍历执行器对应的“心跳续约”注册地址集合。 组装执行器注册地址列表，多地址逗号分隔；如果“续约”的地址集合为空，则代表当前执行器已“死亡”。 更新执行器“续约”的地址信息至DB：更新xxl_job_group表的address_list字段。 至此，任务注册中心“心跳”机制就已完成。 到这里我们或许有了一个疑问？xxl_job_registry任务注册表的记录是何时存在的？即任务是何时被注册的？我们也许会在后面的文章中有所发现。 最后，阻塞当前子线程30秒。 1234567try { TimeUnit.SECONDS.sleep(RegistryConfig.BEAT_TIMEOUT);} catch (InterruptedException e) { if (!toStop) { logger.error(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job registry monitor thread error:{}&quot;, e); }} 这里调用java.util.concurrent包下的枚举TimeUnit类的sleep方法进行睡眠，先指定时间单位，再指定时间大小，代码可读性更高；如果直接使用传统Thread.sleep()方法，传给sleep方法的值的单位是毫秒，即需传入30*1000，代码可读性不高。 总结用以下一副图来对注册中心“心跳续约”服务进行归纳总结。","link":"/2020/02/29/middleware/xxl-job/registry-center-heartbeat-renewal/"},{"title":"修炼xxl-job之调度中心—初始化国际化组件","text":"调度中心启动时主要执行了XxlJobScheduler.init()方法，该方法中有六个初始化动作，这篇文章来分析第一个初始化动作：初始化国际化组件。其关键调用代码为：initI18n(); 国际化简介国际化又称为i18n，来源于国际化的英文单词internationalization从i到n之间有18个英文字母。 源码分析我们来看一下initI18n()方法的代码： 12345private void initI18n(){ for (ExecutorBlockStrategyEnum item:ExecutorBlockStrategyEnum.values()) { item.setTitle(I18nUtil.getString(&quot;jobconf_block_&quot;.concat(item.name()))); }} 循环迭代枚举com.xxl.job.core.enums.ExecutorBlockStrategyEnum，该枚举是执行器阻塞策略枚举。只有一个title属性，提供了三个枚举对象： 12345678910public enum ExecutorBlockStrategyEnum { SERIAL_EXECUTION(&quot;Serial execution&quot;), /*CONCURRENT_EXECUTION(&quot;并行&quot;),*/ DISCARD_LATER(&quot;Discard Later&quot;), COVER_EARLY(&quot;Cover Early&quot;); private String title;............ 循环中调用变异器setTitle()方法给每个枚举对象的title属性重新赋值。 工具类I18nUtil的getString()方法获取到以jobconf_block_开头，以枚举对象名结尾的属性值。 我们来看一下工具类getString()方法的实现： 123public static String getString(String key) { return loadI18nProp().getProperty(key);} 调用了静态成员方法loadI18nProp()得到一个Properties对象，再调用其getProperty()方法从资源文件中获取对应key的值。 来看一下loadI18nProp()方法的实现： 读取application.properties配置文件的xxl.job.i18n配置项的值; build组装，得到i18n文件路径。即resources\\i18n目录下的Resource Bundle 'message'资源包文件; 使用Spring提供的PropertiesLoaderUtils工具类加载对应资源文件。 我们可以从这里知道调度中心application.properties的配置项xxl.job.i18n有两种配置，一是缺省不填，为中文；二是设置为en，即英文。 去resources\\i18n目录看下资源包文件：message.properties和message_en.properties。搜索jobconf_block_，得到以下内容： message.properties： 1234## job confjobconf_block_SERIAL_EXECUTION=单机串行jobconf_block_DISCARD_LATER=丢弃后续调度jobconf_block_COVER_EARLY=覆盖之前调度 message_en.properties： 1234## job confjobconf_block_SERIAL_EXECUTION=Serial executionjobconf_block_DISCARD_LATER=Discard Laterjobconf_block_COVER_EARLY=Cover Early 可以发现键中jobconf_block_后接的内容即为ExecutorBlockStrategyEnum枚举的name值。一共有三个阻塞策略：单机串行、丢弃后续调度和覆盖之前调度。 initI18n()方法的迭代完成后，枚举的title属性值就变成了对应的国际化设置。 总结这篇文章主要是分析了调度中心国际化组件的初始化原理。接下来我们将继续分析调度中心启动的其它初始化动作。","link":"/2020/02/27/middleware/xxl-job/initI18n/"},{"title":"修炼xxl-job之调度中心启动流程解析","text":"这篇文章主要是解析调度中心xxl-job-admin启动流程。 准备我们先来看一下调度中心项目的maven依赖。依赖了Spring Boot的一些starter依赖：web、test、freemarker、mail、actuator和mybatis等，最后依赖了xxl-job-core包。 还记得我们在 修炼xxl-job之搭建本地调度平台 时启动调度中心过程中控制台输出的一句日志吗？ 113:01:40.001 logback [xxl-job, admin JobScheduleHelper#scheduleThread] INFO c.x.j.a.c.thread.JobScheduleHelper - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin scheduler success. JobScheduleHelper类打印了&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin scheduler success.。表示初始化任务调度器成功。 启动分析我们找到com.xxl.job.admin.core.thread.JobScheduleHelper类中打印启动日志的代码，发现其在该类的start方法中，start方法初始化了一个子线程，在子线程中打印了日志。 那么该start方法是何时被执行的呢？我们发现该类并未交由Spring管理，借助于IDEA的快捷键Ctrl+Alt+H查看该方法的调用处，发现其在XxlJobScheduler.init()方法中被调用了，来看一下init方法的代码： 123456789101112131415161718192021public void init() throws Exception { // init i18n initI18n(); // admin registry monitor run JobRegistryMonitorHelper.getInstance().start(); // admin monitor run JobFailMonitorHelper.getInstance().start(); // admin trigger pool start JobTriggerPoolHelper.toStart(); // admin log report start JobLogReportHelper.getInstance().start(); // start-schedule JobScheduleHelper.getInstance().start(); logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin success.&quot;);} JobScheduleHelper.getInstance().start();这一行代码使用“饿汉式”单例模式得到JobScheduleHelper类对象并随之调用了其start方法，然后打印了一行日志：&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin success.。 思考：既然JobScheduleHelper类中的子线程中的日志都进行了打印，那么在其之后的日志打印在了何处呢？ 我们复制代码中的日志信息，前往调度中心启动的控制台中按下Ctrl+F搜索相关信息，发现确实打印了，并且打印的位置非常靠前。 再来看一下init()方法的写法，几乎都是调用某个XxxxxHelper类的getInstance()方法然后再调用其start()方法。 猜想：这里所有的XxxxxHelper类的start()方法都是开启子线程执行相关任务，才导致init()方法中的日志打印位置非常靠前。 实际上这是全异步化设计思想的体现。 我们发现init()方法所在的类XxlJobScheduler也未交由Spring管理，继续借助IDEA的快捷键Ctrl+Alt+H查看init()方法的调用处，发现是在XxlJobAdminConfig.afterPropertiesSet()方法中被调用的。 XxlJobAdminConfig类使用@Component注解交由Spring进行管理，并实现了InitializingBean和DisposableBean这两个接口，重写的afterPropertiesSet()方法中只有简单的三行代码，第二行使用new关键字创建了XxlJobScheduler对象赋给私有成员变量xxlJobScheduler，随后第三行调用了其init()方法。 至此，我们找到了启动的起点，不妨先来分析一下这个“起点类”。 从类名来看，它是一个配置类。其第一个静态成员变量adminConfig是它本身，并在afterPropertiesSet()方法的第一行将this关键字赋给了该变量。 这是什么意思？“自身包含自身”吗？在该静态成员变量下还提供了一个静态方法getAdminConfig()用来获取该静态成员变量的引用。那我可以无限链式调用静态方法getAdminConfig()了： 1XxlJobAdminConfig.getAdminConfig().getAdminConfig().getAdminConfig().......getAdminConfig(); 只有第一次调用是通过类名.静态方法名，第一次调用返回了类的实例对象adminConfig，所以第二次以及之后的每次链式调用都是通过实例对象.静态方法名。这是不被建议和认可的，编译器也发出了黄色警告。所以每次使用时建议是只调用一次，调用一次就拿到了XxlJobAdminConfig类的对象，多次链式调用并无任何作用。 再来看一下XxlJobAdminConfig类的其它成员变量，发现是一些通过@Value注解获取的一些配置信息，还有一些是通过@Resource注解注入的XxxxxxDao类和其它业务类，同时提供了每个成员变量的访问器（getter方法）。 为什么这么做呢？为什么要将这些XxxxxxDao等类放到这里并提供访问器呢？ 简单猜想：实际上XxlJobAdminConfig可以看做是一个简单的“容器”，调度中心在启动时将整个系统需要用到的配置信息和XxxxxxDao类对象初始化到该“容器”中，在需要使用某个XxxxxxDao类时，不使用Spring的依赖注入，而是从该“容器”中拿，还记得前面分析过的静态方法getAdminConfig()，它返回了XxlJobAdminConfig类的对象，我们可以这样来使用： 1XxlJobAdminConfig.getAdminConfig().getXxxxxxDao() 这样做有什么好处呢？ 猜想：这样做对系统的配置信息和依赖信息进行了统一管理，有一种全局配置感。 总结这篇文章主要分析了调度中心项目xxl-job-admin的启动流程。发现主要执行了XxlJobScheduler.init()方法，该方法中有六个初始化动作，接下来我们会逐个进行分析。 初始化国际化组件","link":"/2020/02/26/middleware/xxl-job/dispatch-center-start-process-analysis/"},{"title":"Docker常用命令","text":"安装yum install -y yum-utils device-mapper-persistent-data lvm2 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo yum install docker-ce docker-ce-cli containerd.io 设为开机启动systemctl enable docker 非常重要！！！否则可能重启机器后再次启动docker时会出现以下错误信息： 1Failed to start docker: Unit docker is masked. 查看运行状态systemctl status docker 停止systemctl stop docker 启动systemctl start docker 重启systemctl restart docker 查看版本信息docker version 查看命令帮助docker --help 列出镜像docker images 拉取镜像docker pull [OPTIONS] NAME[:tag] 配置镜像加速器参考 阿里云容器镜像加速器服务 查找镜像docker search NAME 删除镜像docker rmi NAME1/ID1 NAME2/ID2 查看容器 查看正在运行的容器：docker ps 查看所有容器：docker ps -a 查看最后一次运行的容器：docker ps -l 退出容器exit 创建交互式容器docker run -i -t --name=[NAME] IMAGE /bin/bash -i：交互式操作 -t：分配一个可操作容器的终端 --name=[NAME]：指定容器名称（唯一） 可选参数可合并：docker run -it --name [NAME] IMAGE /bin/bash 交互式容器exit退出后容器自动关闭。 创建守护式容器docker run -itd --name NAME IMAGE /bin/bash -d：指定容器运行模式 进入守护式容器docker exec -it [CONTAINER ID] /bin/bash 守护式容器exit退出后容器继续运行。 启动已停止运行的容器docker start [CONTAINER ID] 停止容器docker stop [CONTAINER ID] 重启容器docker restart [CONTAINER ID] 删除容器docker rm -f [CONTAINER ID] 删除时容器必须是停止状态。 删除全部容器（先查询出所有容器再删除）： 1docker rm `docker ps -a -q` 查看容器详细信息docker inspect [CONTAINER NAME] 查看容器详细信息中某个属性的详细信息12345`docker inspect -f='{{.[属性名]}}' [CONTAINER NAME]`或`docker inspect --format='{{.[属性名]}}' [CONTAINER NAME]` 文件拷贝docker cp source target 可将宿主机的文件/目录拷贝至容器或将容器内的文件/目录拷贝至宿主机。 example： 从宿主机（source）拷贝至容器内（target）： 1docker cp ./1.txt container1:/root 从容器内（source）拷贝至宿主机（target）： 1docker cp container1:/root ./1.txt 端口映射创建容器时指定-p参数将容器内端口映射到宿主机的端口。 1docker run -itd --name=NAME -p 宿主机端口:容器端口 IMAGE /bin/bash 目录挂载创建容器时指定-v参数进行目录挂载。 1docker run -itd --name=NAME -v 宿主机目录:容器目录 IMAGE /bin/bash 镜像打包docker save -o [dir/NAME.tar] IMAGE_NAME 将打包的镜像上传至其它服务器scp ./NAME.tar ip:/root/dir 导入打包镜像docker load -i /root/dir/NAME.tar 容器打包docker export -o /root/CONTAINER_NAME.tar CONTAINER_NAME 导入打包容器docker import CONTAINER_NAME.tar CONTAINER_NAME","link":"/2020/02/19/ops/docker/docker-common-commands/"},{"title":"创建mysql5.7的Docker容器","text":"拉取镜像1docker pull mysql:5.7 创建挂载目录如果不创建挂载目录，一旦容器重启，则数据会全部丢失。 1mkdir -p /usr/local/software/mysql/data /usr/local/software/mysql/logs /usr/local/software/mysql/conf 创建mysql配置文件123cd /usr/local/software/mysqltouch my.cnfvim my.cnf 配置文件内容： 1234567891011121314[mysqld]user=mysqlcharacter-set-server=utf8default_authentication_plugin=mysql_native_passwordsecure_file_priv=/var/lib/mysqlexpire_logs_days=7sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTIONmax_connections=1000 [client]default-character-set=utf8 [mysql]default-character-set=utf8 创建容器1docker run --restart=always -p 3306:3306 --name mysql5.7 -v /usr/local/software/mysql/conf:/etc/mysql -v /usr/local/software/mysql/logs:/var/log/mysql -v /usr/local/software/mysql/data:/var/lib/mysql -v /usr/local/software/mysql/my.cnf:/etc/mysql/my.cnf -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 --restart=always：当docker重启时，容器也重启。 --name：容器名称。 -p 3306:3306：宿主机：容器端口映射。 -v source:target：目录挂载。 -e：设置环境变量（mysql密码）。 -d：后台启动。","link":"/2020/02/19/ops/docker/create-mysql-container/"},{"title":"修炼xxl-job之搭建本地调度平台","text":"下载源码xxl-job目前最新master分支的代码为v2.2.0，官网显示仍在迭代中（该版本目前发布的更新内容主要是调度中心升级SpringBoot版本为2.x），所以本次修炼我们采用最近稳定版v2.1.2，发布日期为2019-12-12。 源码地址：GitHub/Gitee 工程简介源码结构如下： 123456789xxl-job-admin：调度中心xxl-job-core：公共依赖xxl-job-executor-samples：执行器Sample示例（选择合适的版本执行器，可直接使用，也可以参考其并将现有项目改造成执行器） ：xxl-job-executor-sample-springboot：Springboot版本，通过Springboot管理执行器，推荐这种方式； ：xxl-job-executor-sample-spring：Spring版本，通过Spring容器管理执行器，比较通用； ：xxl-job-executor-sample-frameless：无框架版本； ：xxl-job-executor-sample-jfinal：JFinal版本，通过JFinal管理执行器； ：xxl-job-executor-sample-nutz：Nutz版本，通过Nutz管理执行器； ：xxl-job-executor-sample-jboot：jboot版本，通过jboot管理执行器； 环境搭建基础环境： Maven3+ JDK7+ MySQL5.7+ 搭建调度中心调度中心项目：xxl-job-admin。 作用：统一管理任务调度平台上调度任务，负责触发调度执行，并且提供任务管理平台。 初始化“调度数据库”源码下载后获取初始化数据库SQL脚本并在MySQL中执行。 调度数据库初始化SQL脚本地址为： 1/xxl-job/doc/db/tables_xxl_job.sql 修改调度中心配置将整个项目工程导入IDEA中，等待maven依赖下载完毕，修改调度中心配置。 调度中心配置文件地址： 1/xxl-job/xxl-job-admin/src/main/resources/application.properties 需要修改的配置项有以下三个： 123spring.datasource.url=spring.datasource.username=spring.datasource.password= 将数据源信息修改为上一步中导入脚本的数据库信息。 启动调度中心在IDEA中运行com.xxl.job.admin.XxlJobAdminApplication#main方法，启动调度中心。 如果一切配置正常，可在控制台看到以下三行关键日志信息： 12313:01:37.678 logback [main] INFO o.s.b.c.e.t.TomcatEmbeddedServletContainer - Tomcat started on port(s): 8080 (http)13:01:37.690 logback [main] INFO c.x.job.admin.XxlJobAdminApplication - Started XxlJobAdminApplication in 6.976 seconds (JVM running for 8.944)13:01:40.001 logback [xxl-job, admin JobScheduleHelper#scheduleThread] INFO c.x.j.a.c.thread.JobScheduleHelper - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin scheduler success. Tomcat容器监听8080端口启动； JVM启动； JobScheduleHelper这个类打印了&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin scheduler success.这句话。 访问调度中心地址如已正确进行前述步骤，则可访问调度中心。 调度中心访问地址：http://localhost:8080/xxl-job-admin 该地址执行器将会使用到，作为回调地址。 默认管理员账号密码为admin/123456。登录成功后可看到如下界面： 至此调度中心搭建完毕。 搭建执行器“执行器”示例项目：xxl-job-executor-sample，该模块下包含多个版本的执行器示例，我们选用xxl-job-executor-sample-springboot版本。 作用：负责接收“调度中心”的调度并执行；可直接部署执行器项目，也可以将执行器集成到现有业务项目中。 启动执行器在IDEA中运行com.xxl.job.executor.XxlJobExecutorApplication#main方法，启动示例执行器。 如果一切运行正常，可在控制台看到以下关键日志信息（这将作为我们后续解析源码的思路）： 1234567891011......16:47:51.370 logback [main] INFO c.x.j.e.core.config.XxlJobConfig - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.16:47:51.425 logback [main] INFO c.x.job.core.executor.XxlJobExecutor - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job register jobhandler success, name:httpJobHandler, jobHandler:com.xxl.job.core.handler.impl.MethodJobHandler@1c32886a[class com.xxl.job.executor.service.jobhandler.SampleXxlJob#httpJobHandler]16:47:51.426 logback [main] INFO c.x.job.core.executor.XxlJobExecutor - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job register jobhandler success, name:demoJobHandler, jobHandler:com.xxl.job.core.handler.impl.MethodJobHandler@3a4b0e5d[class com.xxl.job.executor.service.jobhandler.SampleXxlJob#demoJobHandler]16:47:51.426 logback [main] INFO c.x.job.core.executor.XxlJobExecutor - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job register jobhandler success, name:demoJobHandler2, jobHandler:com.xxl.job.core.handler.impl.MethodJobHandler@10b892d5[class com.xxl.job.executor.service.jobhandler.SampleXxlJob#demoJobHandler2]16:47:51.427 logback [main] INFO c.x.job.core.executor.XxlJobExecutor - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job register jobhandler success, name:commandJobHandler, jobHandler:com.xxl.job.core.handler.impl.MethodJobHandler@3d3f761a[class com.xxl.job.executor.service.jobhandler.SampleXxlJob#commandJobHandler]16:47:51.427 logback [main] INFO c.x.job.core.executor.XxlJobExecutor - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job register jobhandler success, name:shardingJobHandler, jobHandler:com.xxl.job.core.handler.impl.MethodJobHandler@3546d80f[class com.xxl.job.executor.service.jobhandler.SampleXxlJob#shardingJobHandler]......16:47:52.172 logback [main] INFO c.x.r.r.p.XxlRpcProviderFactory - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-rpc, provider factory add service success. serviceKey = com.xxl.job.core.biz.ExecutorBiz, serviceBean = class com.xxl.job.core.biz.impl.ExecutorBizImpl......16:48:02.189 logback [Thread-10] INFO com.xxl.rpc.remoting.net.Server - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-rpc remoting server start success, nettype = com.xxl.rpc.remoting.net.impl.netty_http.server.NettyHttpServer, port = 9999 启动成功后，点击任务调度中心后台导航-执行器管理菜单，可看到如下图所示：OnLine机器地址中已显示我们运行的执行器地址。 点击任务管理菜单可看到示例执行器的测试任务1； 点击右侧[操作]-&gt;[执行一次]，弹出的模态框中无需输入任务参数，直接点击[保存]即可执行任务； 点击[查询日志]，可进入调度日志列表页，点击右侧[执行日志]，可看到任务在执行器一侧运行输出的日志信息。 至此，我们已经完成了任务的调度和执行。","link":"/2020/02/13/middleware/xxl-job/build-local-dispatch-platform/"},{"title":"修炼xxl-job之执行器项目七大配置项解析","text":"这篇文章主要是解析执行器项目七大配置项作用和原理。我们以示例执行器xxl-job-executor-sample-springboot项目为例。 工程结构介绍12345678910111213141516171819202122├─java│ └─com│ └─xxl│ └─job│ └─executor│ │ XxlJobExecutorApplication.java ------启动类│ ││ ├─core│ │ └─config│ │ XxlJobConfig.java ------XxlJobSpringExecutor配置类│ ││ ├─mvc│ │ └─controller│ │ IndexController.java ------空文件│ ││ └─service│ └─jobhandler│ SampleXxlJob.java ------示例执行器类│└─resources application.properties ------项目配置文件 logback.xml ------日志配置文件 com.xxl.job.executor.core.config.XxlJobConfig配置类解读由于是SpringBoot项目，该类采用@Configuration注解添加配置。 成员变量简介该配置类一共包含八个成员变量。 日志对象1private Logger logger = LoggerFactory.getLogger(XxlJobConfig.class); slf4j的日志对象，用来打印关键日志。 七大核心属性变量1234567891011121314151617181920@Value(&quot;${xxl.job.admin.addresses}&quot;)private String adminAddresses;@Value(&quot;${xxl.job.executor.appname}&quot;)private String appName;@Value(&quot;${xxl.job.executor.ip}&quot;)private String ip;@Value(&quot;${xxl.job.executor.port}&quot;)private int port;@Value(&quot;${xxl.job.accessToken}&quot;)private String accessToken;@Value(&quot;${xxl.job.executor.logpath}&quot;)private String logPath;@Value(&quot;${xxl.job.executor.logretentiondays}&quot;)private int logRetentionDays; 使用Spring提供的@Value注解来注入配置文件application.properties中的配置信息。 我们打开resources目录下的application.properties文件查看，默认配置信息如下： 123456789101112131415### xxl-job admin address list, such as &quot;http://address&quot; or &quot;http://address01,http://address02&quot;xxl.job.admin.addresses=http://127.0.0.1:8080/xxl-job-admin### xxl-job executor addressxxl.job.executor.appname=xxl-job-executor-samplexxl.job.executor.ip=xxl.job.executor.port=9999### xxl-job, access tokenxxl.job.accessToken=### xxl-job log pathxxl.job.executor.logpath=/data/applogs/xxl-job/jobhandler### xxl-job log retention daysxxl.job.executor.logretentiondays=30 根据配置文件中的相关注释我们来解释七大核心属性的含义： adminAddresses： 配置项：xxl.job.admin.addresses，选填。 含义：调度中心部署根地址。 作用：执行器会使用该地址进行“执行器心跳注册”和任务结果回调。 注意事项：如调度中心集群部署，存在多个根地址，则用逗号分隔。为空不填则关闭自动注册功能。 appName： 配置项：xxl.job.executor.appname，选填。 含义：是每个执行器集群的唯一标示AppName。 作用：执行器心跳注册分组依据。 注意事项：为空不填表示关闭自动注册功能。 ip： 配置项：xxl.job.executor.ip，选填。 含义：执行器IP。 作用：适用于多网卡时手动设置指定IP，该IP不会绑定Host仅作为通讯使用；用于“执行器注册”和“调度中心请求并触发任务”。 注意事项：为空不填表示自动获取IP。 port： 配置项：xxl.job.executor.port，选填。 含义：执行器端口号。执行器实际是一个内嵌的Server，默认端口9999。 作用：用于“执行器注册”和“调度中心请求并触发任务”时通讯。 注意事项：小于等于0时自动获取。单机部署多个执行器时，不同执行器端口不能相同。 accessToken： 配置项：xxl.job.accessToken，选填。 含义：访问令牌。 作用：为提升系统安全性，调度中心和执行器进行安全性校验，双方accessToken匹配才允许通讯。 注意事项：正常通讯只有两种设置； 设置一：调度中心和执行器均不设置accessToken，关闭访问令牌校验。 设置二：调度中心和执行器设置相同的accessToken。 logPath： 配置项：xxl.job.executor.logpath，选填。 含义：执行器运行日志文件存储磁盘路径。 作用：设置执行器运行日志文件存储磁盘路径。 注意事项：需要对设置的路径拥有读写权限；为空则使用默认路径（/data/applogs/xxl-job/jobhandler）。 logRetentionDays： 配置项：xxl.job.executor.logretentiondays，选填。 含义：执行器日志文件保存天数。 作用：设置过期日志自动清理。 注意事项：设置的值大于等于3时生效；否则日志自动清理功能关闭。 com.xxl.job.executor.core.config.XxlJobConfig#xxlJobExecutor方法作用1234567891011121314@Beanpublic XxlJobSpringExecutor xxlJobExecutor() { logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;); XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor(); xxlJobSpringExecutor.setAdminAddresses(adminAddresses); xxlJobSpringExecutor.setAppName(appName); xxlJobSpringExecutor.setIp(ip); xxlJobSpringExecutor.setPort(port); xxlJobSpringExecutor.setAccessToken(accessToken); xxlJobSpringExecutor.setLogPath(logPath); xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays); return xxlJobSpringExecutor;} 上一部分列举出的七大属性最终设置给了com.xxl.job.core.executor.impl.XxlJobSpringExecutor这个类的对象，并使用@Bean注解交由Spring进行管理。该方法中打印的日志信息 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init. 我们在启动执行器时控制台有输出。 七大属性配置详解上一部分列举出了每个属性的注意事项等，这一部分我们去源码中验证上一部分的内容。 目标我们要找到上述七大属性在设置给com.xxl.job.core.executor.impl.XxlJobSpringExecutor这个类的对象时是如何以及怎样进行条件限制的。 思考从com.xxl.job.executor.core.config.XxlJobConfig#xxlJobExecutor方法来看，这些配置从配置文件中读到值后是直接使用变异器（setter方法）设置给xxlJobSpringExecutor这个对象，然后就把这个对象交给Spring进行管理了，所以只有两种可能，第一是在变异器中进行了逻辑处理，第二是在Spring加载bean的过程中进行了逻辑处理。 实践我们首先看一下com.xxl.job.core.executor.impl.XxlJobSpringExecutor这个类的定义： 12public class XxlJobSpringExecutor extends XxlJobExecutor implements ApplicationContextAware, InitializingBean, DisposableBean {...... 该类继承了com.xxl.job.core.executor.XxlJobExecutor父类并实现了Spring的三个接口；我们在该类中未找属性对应的变异器，所以我们几乎可以断定这些属性是定义在父类中。 我们来看父类的代码 变异器只是单纯的把传入的值设置给对象，所以排除了第一种可能，情况只能是第二种：在Spring加载bean的过程中进行了逻辑处理。 我们继续往下看父类XxlJobExecutor的代码，发现start方法中用到了这些属性，接下来我们来仔细阅读以下该方法的代码： 123456789101112131415161718192021// ---------------------- start + stop ----------------------public void start() throws Exception { // init logpath XxlJobFileAppender.initLogPath(logPath); // init invoker, admin-client initAdminBizList(adminAddresses, accessToken); // init JobLogFileCleanThread JobLogFileCleanThread.getInstance().start(logRetentionDays); // init TriggerCallbackThread TriggerCallbackThread.getInstance().start(); // init executor-server port = port&gt;0?port: NetUtil.findAvailablePort(9999); ip = (ip!=null&amp;&amp;ip.trim().length()&gt;0)?ip: IpUtil.getIp(); initRpcProvider(ip, port, appName, accessToken);} 一共有七行核心代码，我们一行一行的来解读： XxlJobFileAppender.initLogPath(logPath); 从方法名来看显然是初始化日志存储路径，我们进入XxlJobFileAppender类查看initLogPath(logPath)方法，代码如下： 我们可以看到静态成员变量logBasePath的值为/data/applogs/xxl-job/jobhandler，当logPath属性未配置时该路径即为日志存盘的默认路径。 该方法的实现思路如下： 如果配置的logPath不为空则覆盖静态成员变量logBasePath的值。 以静态成员变量logBasePath的值调用File类的mkdirs方法创建多级文件目录。 调用File类的getPath方法将创建好的文件夹的路径重新赋值给静态成员变量logBasePath。 以上就是属性logPath的配置方式。 initAdminBizList(adminAddresses, accessToken); 从方法名来看该方法的作用是初始化调度中心部署根地址集合，其参数是配置项adminAddresses和accessToken的值。我们来看该方法的具体实现： 该方法的实现思路如下： 判断传入的配置项adminAddresses的值是否为null并且去除两端空格后的长度是否大于零。 如果不满足第一步的条件则什么也不做，即关闭自动注册功能；如果满足第一步的条件，则去除两端空格后调用split方法以英文逗号,分割成字符串数组进行遍历，遍历的第一步是限制数组中的单个地址值不为null并且去除两端空格后的长度大于零，这一步是为了防止,http://127.0.0.1:8080/xxl-job-admin,等类似误配置。 一切限制条件通过后开始创建com.xxl.job.core.biz.client.AdminBizClient类的对象，并添加至静态成员变量adminBizList集合中。这里是在第一次循环时才使用new关键字创建ArrayList集合对象，其思想是“懒加载”，用时才去创建对象。由于Spring的bean的默认作用域是单例的，所以保证了该初始化方法只会执行一次。 我们来看一下com.xxl.job.core.biz.client.AdminBizClient类的构造方法： 构造方法中对传入的addressUrl进行了简单的valid校验，如果不是以/结尾则将/拼接至末尾。此处可看出我们的adminAddresses配置实际会变成类似http://127.0.0.1:8080/xxl-job-admin/这样的字符串。至于该类对象什么时候使用我们暂时没有线索，大可先不关注这个。 JobLogFileCleanThread.getInstance().start(logRetentionDays); 调用JobLogFileCleanThread类的getInstance方法取得该类对象再调用其start(final long logRetentionDays)方法。 从类名来看是清除日志文件的线程。 我们前往com.xxl.job.core.thread.JobLogFileCleanThread类看一下getInstance方法，会发现有如下两行关键代码： 1234private static JobLogFileCleanThread instance = new JobLogFileCleanThread();public static JobLogFileCleanThread getInstance() { return instance;} 这是“饿汉式”单例模式的写法，创建了单例的JobLogFileCleanThread对象。 接下来看一下start方法： 首先第一步检查设置的logRetentionDays属性是否小于3，小于则直接return；这里说明了配置文件中的值设置小于3时关闭日志自动清理功能。 该方法中实例化了成员变量private Thread localThread;，调用了setDaemon(true)方法将该线程设置为守护线程，并调用setName方法将线程名设为了xxl-job, executor JobLogFileCleanThread。 线程中运行的run方法逻辑大致如下： 调用XxlJobFileAppender.getLogPath()方法获取设置的日志存盘路径 遍历该路径下所有文件夹，判断当前时间与文件夹的创建时间之差是否大于等于设置的logRetentionDays天数，如果大于则调用工具类com.xxl.job.core.util.FileUtil的deleteRecursively方法递归删除文件夹下的所有文件。 删除逻辑完成后，有这样一行代码：TimeUnit.DAYS.sleep(1);，线程睡眠一天。这里调用并发包下的TimeUnit类的sleep方法让代码可读性更高，如果直接使用传统Thread.sleep()方法，传给sleep方法的值的单位是毫秒，即需传入24*60*60*1000，代码可读性不高。 TriggerCallbackThread.getInstance().start(); 从类名TriggerCallbackThread来看，这是执行器回调线程，由于未使用到配置参数，这篇文章不对其进行展开解读。 port = port&gt;0?port: NetUtil.findAvailablePort(9999); 初始化port端口号。 如果配置文件中设置的端口号大于零，则使用配置文件中的值； 否则执行代码NetUtil.findAvailablePort(9999);，我们进入NetUtil类查看findAvailablePort方法，发现这个类属于com.xxl.rpc.util包，可见，xxl-job依赖了xxl-rpc（这是作者许雪里开源的rpc框架）。 从方法名来看作用是“寻找可用端口”，我们来看一下findAvailablePort方法的具体实现逻辑： 传入的9999作为默认端口，首先循环9999到65534端口，逐个进行!isPortUsed(portTmp)判断，如果返回true则表示当前端口号未被使用，返回赋值给属性port。 如果上述循环未找到可使用的端口，则再循环9999到1端口，同样逐个进行!isPortUsed(portTmp)判断，如果还未找到可用端口，则抛出XxlRpcException异常，异常信息为no available port.。 我们来看一下isPortUsed方法是如何判断端口是否被使用的： 实际是尝试去创建一个ServerSocket客户端并与传入的端口号进行绑定，如端口被占用则绑定时会抛出IOException，由此来确定端口是否被使用，从而在未配置端口号时选出一个可用端口。最终finally代码块中调用了close方法关闭资源。 ip = (ip!=null&amp;&amp;ip.trim().length()&gt;0)?ip: IpUtil.getIp(); 作用：确定ip地址。示例执行器的配置中是未进行配置的，所以会执行IpUtil.getIp()方法，该方法中最后会调用java.net.InetAddress#getHostAddress方法，该方法返回null，所以属性ip会被设置成null。 initRpcProvider(ip, port, appName, accessToken); 传入了四个参数：ip、port、appName和accessToken用来初始化Rpc服务提供者。这部分属于xxl-rpc的内容，目前我们可以简单看看，大致内容是创建出XxlRpcProviderFactory类的对象，给该对象设置相关属性，添加com.xxl.job.core.biz.impl.ExecutorBizImpl服务至rpc服务提供者map容器中，最后调用start方法启动服务提供者（这里实际是一个NettyServer）。 现在我们大可不必去关注xxl-rpc是怎么实现的，这篇文章的目的是搞清楚七大核心配置的工作原理。 父类XxlJobExecutor的start方法我们看完了，那么它是什么时机执行的呢？ 我们注意到XxlJobSpringExecutor类实现了Spring的InitializingBean接口，该接口提供了afterPropertiesSet方法供子类实现，在bean加载过程中会执行该方法。 接下来我们来看一下XxlJobSpringExecutor类中重写的afterPropertiesSet方法： 12345678910111213141516// start@Overridepublic void afterPropertiesSet() throws Exception { // init JobHandler Repository initJobHandlerRepository(applicationContext); // init JobHandler Repository (for method) initJobHandlerMethodRepository(applicationContext); // refresh GlueFactory GlueFactory.refreshInstance(1); // super start super.start();} 前三行代码是初始化一些东西，暂时不去关注；最后一行super.start()是我们的关键，调用了父类的start方法。 总结至此，我们知道了七大配置项的基本原理，对我们使用xxl-job有了一些帮助。例如配置项logretentiondays不能小于3，否则日志文件不会自动清理等。","link":"/2020/02/13/middleware/xxl-job/demo-executor-xxljobconfig-sourcecode-analysis/"},{"title":"Windows 10下Git安装及SSH公私钥配置","text":"下载可从 Git官网 下载最新Windows安装文件（下载速度有点感人）。 这里我提供64位的Git 2.25.0版本的 百度网盘 供大家下载，提取码：uzs6。 安装双击安装包文件进行安装，自定义安装位置，其余保持默认一直next下去。 按下win+R键，输入cmd，回车，输入命令git --version，出现下图所示内容即表示安装成功。 全局配置全局配置用户名和邮箱，否则无法进行下一步的SSH公私钥配置。鼠标右击桌面空白处-&gt;选择Git Bash Here打开。分别输入如下命令： 12git config --global user.name &quot;你的用户名&quot;git config --global user.email &quot;你的邮箱&quot; 用户名可随意指定，一般是自己名字或简称，git提交代码到远程时会使用该名称。邮箱填自己喜欢的邮箱即可。 SSH公私钥配置 鼠标右击桌面空白处-&gt;选择Git Bash Here打开。 使用cd ~/.ssh切换到公私钥目录。 执行命令ssh-keygen -t rsa生成公私钥，回车3次（这里回车会让你输入一些配置，比如密码，如果设置了密码则每次使用git命令都会要求输入密码，不推荐），会在C:\\Users\\Administrator\\.ssh目录下生成一个私钥id_rsa和一个公钥id_rsa.pub。 Gitlab配置上述配置完成之后即可在全球最大的开源项目托管平台Github上进行代码版本控制。 但一般企业都会有自己的Gitlab代码托管平台，这时如果没有在Gitlab上配置公私钥则不能上传/下载代码。 登录企业的Gitlab平台-&gt;右上角个人头像-&gt;Settings-&gt;SSH Keys-&gt;粘贴.ssh文件夹下的id_rsa.pub公钥内容-&gt;确认添加。 配置完成后即可在企业的Gitlab平台上传/下载代码。","link":"/2020/02/07/installed/install-git/"},{"title":"Windows 10下IntelliJ IDEA 2019.3.2安装和常用配置","text":"以下教程基于windows 10和IntelliJ IDEA 2019.3.2。 下载可从 IntelliJ IDEA官网 下载最新安装包。 这里我提供 百度云盘 供大家下载，提取码：v9oj。 安装 双击.exe安装文件-&gt;Next-&gt;指定安装路径（可直接填写，不存在会自动创建）-&gt;Next-&gt;Next-&gt;Install；等待安装完成。 勾选Run IntelliJ IDEA-&gt;Finish Do not import settings-&gt;OK-&gt;勾选I confirm that...-&gt;Continue-&gt;Don't Send 选择界面主题-&gt;Next: Default plugins-&gt;Next: Featured plugins-&gt;Start using IntelliJ IDEA（这一系列推荐按默认配置） Evaluate for free-&gt;Evaluate-&gt;Continue 激活由于法律关系，请大家尽量支持正版。 常用配置点击File-&gt;Close Project，关闭主界面进入选择项目窗口（这样设置是全局设置，而不是单对于某个项目设置）。 点击右下角Configure-&gt;Settings，打开设置面板。 设置每次打开都是选择项目界面。Appearance &amp; Behavior-&gt;System Settings-&gt;取消勾选Reopen last project on startup 取消自动检查更新。Appearance &amp; Behavior-&gt;System Settings-&gt;Updates-&gt;取消勾选Automatically check updates for 设置鼠标放到类或方法上自动显示注释文档。Editor-&gt;General-&gt;勾选Show quick documentation on mouse move 可在下方设置显示的延迟毫秒数Tooltip delay 设置字体和字体大小Editor-&gt;Font 设置创建Java类时的头部注释模板。Editor-&gt;File and Code Templates-&gt;Includes-&gt;File Header 右侧输入注释模板，示例如下： 123456/** * @author sunchaser * @date ${DATE} * @description * @since 1.0 */ 设置文件编码字符集。Editor-&gt;File Encodings 统一选择UTF-8/with NO BOM。 设置Git及GitHub。Version Control-&gt;Git/GitHub 选择Git安装目录下的bin\\git.exe文件。有关Git的安装配置，可参考 这篇文章 输入用户名/密码登录GitHub。 设置Maven。Build,Execution,Deployment-&gt;Build Tools-&gt;Maven 选择Maven home directory为我们自己安装的Maven目录，点击Override覆盖默认的User settings file和Local repository。 有关Maven的安装和配置，可参考 这篇文章 。 Build,Execution,Deployment-&gt;Build Tools-&gt;Maven-&gt;Importing/Runner 选择JDK for importer/JRE为Use JAVA_HOME 设置序列化UID生成快捷键设置实现了Serializable序列化接口的类中未定义serialVersionUID属性时类名处报黄色警告，按快捷键alt+enter有快捷生成序列化UID的选项。 Editor-&gt;Inspections 搜索Serializable，找到Serializable class without 'serialVersionUID'，右侧进行勾选。 所有设置完成后点击右下角Apply-&gt;OK，完成设置。","link":"/2020/02/07/installed/install-idea/"},{"title":"Windows 10下JDK安装及环境变量配置","text":"由于JDK开始收费，现在大多数企业使用的Java版本是Java8或者以下，Java8的使用者居多。我们在学习或开发中，下载Java8就足够使用了。 下载JDK安装包可前往 Oracle官网 下载。 这里我分享 百度云盘 供大家下载，提取码：5mxh。 进行安装双击运行.exe后缀文件，运行安装程序，注意下图所示地方，去除公共JRE的安装，点击左侧的小图标选择此功能将不可用。点击开发工具更改安装路径，继续下一步直至完成安装即可。 配置环境变量右击我的电脑-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量 在系统变量处点击新建，输入变量名：JAVA_HOME，变量值为上述JDK安装步骤中更改的安装路径，点击确定。 选中系统Path变量，点击编辑-&gt;新建，输入%JAVA_HOME%\\bin\\，点击确定。 最后一直确定下去至窗口关闭即可。 检验按下win+R键，输入cmd，回车，输入命令java -version，出现下图所示内容即表示配置成功。 题外话网上很多老的教程还需要配置CLASSPATH变量，这个是JDK的历史原因，现在JDK目录下已包含专用的JRE，无需再进行额外配置。","link":"/2020/02/07/installed/install-jdk/"},{"title":"Windows 10下Maven安装及配置","text":"下载可从 Maven官网 下载Binary zip archive最新压缩包。 这里我提供 百度云盘 供大家下载，提取码：olx2。 安装maven为绿色安装，下载完成后解压至自定义目录即可。 注意：解压路径不要包含中文。 安装文件简介解压目录包含4个文件夹bin/boot/conf/lib，其存放的文件分别为： bin：maven的一些可执行程序。 boot：一些启动引导程序，例如类加载器等。 conf：配置文件。 lib：maven自身运行依赖的库。 配置maven配置环境变量右击我的电脑-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量 在系统变量处点击新建，输入变量名：MAVEN_HOME，变量值上述maven的解压目录，点击确定。 选中系统Path变量，点击编辑-&gt;新建，输入%MAVEN_HOME%\\bin\\，点击确定。 最后一直确定下去至窗口关闭即可。 按下win+R键，输入cmd，回车，输入命令mvn -v，出现下图所示内容即表示配置成功。 配置本地仓库新建一个自定义目录repository作为本地仓库，一般和Maven的解压目录在同级。 然后在Maven的安装目录下找到conf目录下的settings.xml配置文件，用文本编辑器打开，找到大概第55行的位置，输入以下标签指定本地仓库的位置： 1&lt;localRepository&gt;E:\\develop\\maven\\repository&lt;/localRepository&gt; 根据个人安装位置输入仓库路径。 配置阿里云镜像仓库 在settings.xml文件大约160行的地方，输入以下内容配置阿里云Maven镜像： 1234567&lt;!-- 这个是配置阿里Maven镜像 --&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt; 总结至此，Maven的配置就完成了。","link":"/2020/02/07/installed/install-maven/"},{"title":"Windows 10下Node.js安装与配置","text":"下载可从 Node.js中文官网 下载最新长期支持版安装包。 这里我提供12.15.0长期支持版 百度云盘 供大家下载，提取码：itoe。 安装双击安装包文件进行安装，自定义安装位置，其余保持默认一直next下去。 按下win+R键，输入cmd，回车，分别输入命令node -v和npm -v，出现下图所示内容即表示安装成功。 说明：新版本Node.js自带npm，安装Node.js时会一起安装，npm是Node.js的依赖包管理工具，可大致理解成maven/Composer等。 全局配置在执行类似：npm install express [-g] （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，默认会将安装的模块安装到C:\\Users\\用户名\\AppData\\Roaming\\npm路径中，占用C盘空间。 我们希望将全局模块路径和缓存路径放置在自定义目录（非C盘）中。这里我在Node.js安装目录下新建两个文件夹node_global和node_cache。如下图： 空文件夹创建完成后，按下win+R键，输入cmd，回车，分别输入以下命令： 123npm config set prefix &quot;E:\\develop\\nodejs\\node_global&quot;npm config set cache &quot;E:\\develop\\nodejs\\node_cache&quot; 配置环境变量鼠标右击我的电脑-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量 在系统变量处点击新建，输入变量名：NODE_HOME，变量值为E:\\develop\\nodejs\\node_global\\node_modules：上述全局配置中的node_global路径后再加一个node_modules文件夹（不用手动创建），点击确定。 选中用户变量Path，点击编辑，将默认的C:\\Users\\用户名\\AppData\\Roaming\\npm改为E:\\develop\\nodejs\\node_global：上述全局配置中的node_global，点击确定。 最后一直确定下去至所有窗口关闭即可。 总结最后，删除默认的C:\\Users\\lilu\\AppData\\Roaming\\npm文件夹。 至此Node.js的安装和配置就已完成，可使用npm install -g命令下载任意js依赖检验是否将包下载至了我们指定的路径下。","link":"/2020/02/07/installed/install-nodejs/"},{"title":"重装Windows10系统","text":"制作重装启动U盘，推荐 大白菜 U盘制作工具。 下载win10镜像文件，一般去 MSDN我告诉你 下载。大家都是64位的CPU，你应该下载64位版本的镜像。 百度搜索对应机型U盘启动快捷键，进行重装。 重装系统启动过程中有一些可选配置项，一般都不勾选，没有必要。在创建用户界面请使用脱机账户登录，脱机账户可手动设置用户名。不要使用outlook邮箱登录，原因是使用outlook邮箱登录的话，由于用户名设置规则，只会取邮箱的前五个字符，作为微软用户绑定的系统管理员用户名。可能会造成C:\\Users目录下的用户名不是你想要的。重装完成后再到设置中使用outlook邮箱登录即可。这样系统用户名就是我们自定义的名称。 重装完成后系统会自动进行一些基本设置，然后进入桌面会提示等待系统部署完成。这时等待一会即可。一般会安装一些第三方软件，例如360/爱奇艺/淘宝等，大可不必觉得“恶心”，稍后我们会进行清理。 一般win10系统安装完成后桌面上没有我的电脑/控制面板等图标，只有一个回收站。可以鼠标右键点击桌面空白处-&gt;个性化设置-&gt;主题-&gt;相关的设置（桌面图标设置），勾选计算机/控制面板等，点击确定即可。这时发现桌面图标排列顺序有点不好，可鼠标右键点击刷新桌面，如果还不行则鼠标右键点击桌面空白处-&gt;排序方式-&gt;名称，重复两遍即可。 激活Windows，建议在某宝购买支持重装的激活码，一次购买，多次使用。不推荐使用第三方激活工具激活。 开始清理系统初始第三方软件，可利用自动安装的360软件管家，卸载这些应用。最后在卸载360。在卸载应用时注意勾选删除在本机保存的个人配置数据等类似选项。 点击开始菜单，在左侧菜单和动态磁贴中一般会有一些没什么用的Windows应用，例如一些游戏等，如果不需要office等也可以进行卸载。点击鼠标右键即有卸载按钮。 这时系统基本清理完成，但还是会有一些残留文件夹存在，进入C:/Program Files (x86)目录，如果看到一些360/tencent等文件夹可直接删除，如果提示操作无法完成，因为其中的文件夹或文件已在另一程序中打开，则可先放着，等将其它类似文件夹删除后，稍后重启电脑即可删除。 打开我的电脑，点击上方查看，勾选文件扩展名/隐藏的项目。重启电脑，重启完成后即可删除上述所说无法删除的文件夹。 下面开始安装我们的个人软件，首先安装360。 为什么安装360？ 有些人觉得360是流氓软件，影响电脑运行速度，但我觉得360有些功能还是可以的，比如清理垃圾/禁止开机启动项等。 为什么卸载系统安装完成后自带的360？ 因为自带的360安装在C盘，不好。去 360官网 下载最新的安装包。双击安装包，选择自定义安装，选择安装路径为自定义盘（非C盘）。 进行清理优化 安装完成后打开360主界面，点击功能大全-&gt;我的工具，删除一些没用的自带工具。一般只留一个软件管家即可。点击电脑清理清理系统垃圾。勾选一些痕迹信息和Cookie信息等。点击优化加速禁用一些开机启动项。扫描完成后勾选一些需要优化的项，点击立即优化。 安装驱动大师更新驱动 在功能大全中搜索找到360驱动大师，点击安装，进行系统驱动更新。驱动大师会自动进行备份下载更新，备份的目录可在驱动大师的设置中指定，默认与360安装目录在同一盘符下。 驱动更新完成后重启电脑，重启后删除驱动大师。在360安全卫士中-&gt;功能大全-&gt;我的工具中删除驱动大师，可选择勾选删除已备份和下载的驱动。 安装其它软件（可选） 360压缩：解压缩软件有很多选择，比如WinR/7z等，这里由于安装了360，选择360压缩即可。进入360安全卫士主界面-&gt;功能大全-&gt;搜索选择360压缩-&gt;点击进行安装-&gt;安装完成后会弹出主界面-&gt;点击右上角工具-&gt;设置-&gt;取消勾选常规中的开启自动升级/改善计划中的参与“360用户体验改善计划”-&gt;确定。对于右下角可能出现的弹窗，请点击弹窗右上角的×进行关闭。 搜狗输入法：前往 搜狗输入法官网 下载最新安装包，下载完成后双击运行-&gt;选择自定义安装-&gt;选择安装目录-&gt;点击安装-&gt;取消勾选完成界面的一些捆绑安装的选项。安装完成后进行搜狗输入法的一些基本设置即可，搜狗输入法每天会在右下角弹出一个弹窗，不要点击不在提示，请点击右上角的×，不然会下载搜狗浏览器。 有道云笔记：前往 有道云笔记官网 下载最新安装包-&gt;双击运行-&gt;自定义安装-&gt;指定安装目录-&gt;取消勾选有道翻译安装。安装完成后进行登录，登录后点击右上角-&gt;设置，取消勾选启动windows时启动有道云笔记/自动检查客户端更新。默认情况下本地文件会保存在C:\\Users\\用户名\\AppData\\Local\\YNote相关目录下，在安装时指定可能没有效果。如果想让本地文件不保存在C盘可在设置中进行指定，有道云笔记会自动进行数据迁移。 百度网盘：前往 百度云网盘官网 下载最新安装包-&gt;双击运行-&gt;自定义安装-&gt;指定安装目录-&gt;完成后登录-&gt;进入主界面后点击右上角设置-&gt;取消勾选开机时启动百度网盘(推荐)。 至此，电脑重装系统基本完成，接下来就可以进行应用软件安装了。","link":"/2020/02/07/installed/install-windows10/"},{"title":"基本数据类型char为什么不会被隐式转换成byte或short类型？","text":"Java的基本数据类型中的数值类型包括：byte/char/short/int/float/double/long 其数值范围如下表所示： 基本类型 大小 范围 byte 8 bits [-128, +127] char 16 bits [‘\\u0000’, ‘\\uFFFF’] 即 [0, 2^16 - 1] short 16 bits [-2^15, +2^15 - 1] int 32 bits [-2^31, +2^31 - 1] float 32 bits IEEE754范围 double 64 bits IEEE754范围 long 64 bits [-2^63, +2^63 - 1] 注：表格中的 ‘[‘ 和 ‘]’ 表示闭区间；IEEE754范围参考wiki char类型的表示范围可通过以下代码查看：0-65535 12System.out.println(Character.MIN_VALUE + 1 - 1);System.out.println(Character.MAX_VALUE + 1 - 1); byte类型只占一个字节（8比特），而char和short都占两个字节。char转成byte会出现装不下的情况，精度丢失，所以编译器不会自动进行隐式转换； short类型虽然占两个字节，但其最大值是2^15-1，char的最大值是2^16-1，会出现转换不了的情况，所以编译器也不会进行隐式转换。 int类型是第一个数值范围比char大的类型，所以在涉及到隐式转换时，Java默认将char隐式转换成int。","link":"/2020/01/09/javase/base/why-char-cannot-be-converted-to-byte-or-short/"},{"title":"方法重载Overload","text":"在日常生活中，相同的词可以表达多种不同的含义——它们被“重载了”。例如：“冬天能穿多少穿多少。夏天能穿多少穿多少。”、“中国足球谁也打不过。中国乒乓球谁也打不过。”。相同的名字但表达出了不同的含义，这就是方法重载。 构造器重载我们知道类的构造器名字必须与类名完全相同，不接受任何参数的构造器叫做默认构造器，同其它方法一样，构造器也能带有形式参数，以便指定如何创建对象。这里就体现了方法重载，它们都有相同的名字，即类名，但形式参数不同。 区分方法重载如果有几个名字相同的方法，Java如何进行区分呢？ 请记住方法重载的概念：方法名相同，但形参列表不同。 即使形参顺序不同也足以区分两个方法。但是最好别这样做，细想一下，如果只是参数顺序不同，有什么实际的意义呢？这样的重载也会让代码难以琢磨。 基本数据类型的重载传入的实际参数范围小于重载方法声明的形式参数范围我们知道Java中有自动类型转换（隐式转换）的概念，基本数据类型能从一个范围“较小”的类型自动转换至一个范围“较大”的类型，此过程一旦涉及到方法重载，可能会造成一些混淆。 我们来进行一些测试。 foo1方法包含char/byte/short/int/long/float/double这7种基本数据类型的重载； foo2方法包含byte/short/int/long/float/double这6种基本数据类型的重载； foo3方法包含short/int/long/float/double这5种基本数据类型的重载； foo4方法包含int/long/float/double这4种基本数据类型的重载； foo5方法包含long/float/double这3种基本数据类型的重载； foo6方法包含float/double这2种基本数据类型的重载； foo7方法只有一个double类型参数的方法； 分别使用常量值6、char类型的’x’、byte类型的1、short类型的1、int类型的1、long类型的1、float类型的1和double类型的1分别调用foo系列的方法，观察输出结果。完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337package com.sunchaser.javase.base.overload;import org.junit.Test;/** * @author sunchaser * @date 2020/1/8 * @description * 基本数据类型重载的测试：基本数据类型范围较小的会被自动类型转换（隐式转换）成范围较大的类型。 * * 基本数据类型（除去boolean）范围如下： * '[' 和 ']' 表示闭区间。 * * byte | 8 bits | [-128, +127] * char | 16 bits | ['\\u0000', '\\uFFFF'] * short | 16 bits | [-2^15, +2^15 - 1] * int | 32 bits | [-2^31, +2^31 - 1] * float | 32 bits | IEEE754范围 * double | 64 bits | IEEE754范围 * long | 64 bits | [-2^63, +2^63 - 1] * * @since 1.0 */public class SmallToBigDataTypeOverloadTest { /** * print: * * const: 6 * foo1(int x) * foo2(int x) * foo3(int x) * foo4(int x) * foo5(long x) * foo6(float x) * foo7(double x) * * 常量值6被当做int值进行处理。如果没有int类型的重载方法，则自动类型转换成“较大”的类型。 */ @Test public void testConstValue() { System.out.println(&quot;const: 6&quot;); foo1(6); foo2(6); foo3(6); foo4(6); foo5(6); foo6(6); foo7(6); } /** * print: * * char: x * foo1(char x) * foo2(int x) * foo3(int x) * foo4(int x) * foo5(long x) * foo6(float x) * foo7(double x) * * 除foo1外，char类型的'x'被自动类型转换成了“较大”的类型。 * 在foo2、foo3和foo4中，char类型被直接转换成了int类型。 */ @Test public void testChar() { char c = 'x'; System.out.println(&quot;char: &quot; + c); foo1(c); foo2(c); foo3(c); foo4(c); foo5(c); foo6(c); foo7(c); } /** * print: * * byte: 1 * foo1(byte x) * foo2(byte x) * foo3(short x) * foo4(int x) * foo5(long x) * foo6(float x) * foo7(double x) * * 除foo1和foo2外，byte类型的1被自动类型转换成了“较大”的类型。 */ @Test public void testByte() { byte b = 1; System.out.println(&quot;byte: &quot; + b); foo1(b); foo2(b); foo3(b); foo4(b); foo5(b); foo6(b); foo7(b); } /** * print: * * short: 1 * foo1(short x) * foo2(short x) * foo3(short x) * foo4(int x) * foo5(long x) * foo6(float x) * foo7(double x) * * 除foo1、foo2和foo3外，short类型的1被自动类型转换成了“较大”的类型。 */ @Test public void testShort() { short s = 1; System.out.println(&quot;short: &quot; + s); foo1(s); foo2(s); foo3(s); foo4(s); foo5(s); foo6(s); foo7(s); } /** * print: * * int: 1 * foo1(int x) * foo2(int x) * foo3(int x) * foo4(int x) * foo5(long x) * foo6(float x) * foo7(double x) * * foo5、foo6和foo7方法，int类型的1都被自动类型转换成了“较大”的类型。 */ @Test public void testInt() { int i = 1; System.out.println(&quot;int: &quot; + i); foo1(i); foo2(i); foo3(i); foo4(i); foo5(i); foo6(i); foo7(i); } /** * print: * * long: 1 * foo1(long x) * foo2(long x) * foo3(long x) * foo4(long x) * foo5(long x) * foo6(float x) * foo7(double x) * * foo6和foo7方法，long类型的1L被自动类型转换成了“较大”的类型。 */ @Test public void testLong() { long l = 1L; System.out.println(&quot;long: &quot; + l); foo1(l); foo2(l); foo3(l); foo4(l); foo5(l); foo6(l); foo7(l); } /** * print: * * float: 1.0 * foo1(float x) * foo2(float x) * foo3(float x) * foo4(float x) * foo5(float x) * foo6(float x) * foo7(double x) * * foo7方法中，float类型的1F被自动类型转换成了“较大”的类型。 */ @Test public void testFloat() { float f = 1F; System.out.println(&quot;float: &quot; + f); foo1(f); foo2(f); foo3(f); foo4(f); foo5(f); foo6(f); foo7(f); } /** * print: * * double: 1.0 * foo1(double x) * foo2(double x) * foo3(double x) * foo4(double x) * foo5(double x) * foo6(double x) * foo7(double x) */ @Test public void testDouble() { double d = 1D; System.out.println(&quot;double: &quot; + d); foo1(d); foo2(d); foo3(d); foo4(d); foo5(d); foo6(d); foo7(d); } /*==========================foo1 Overload===========================*/ void foo1(char x) { System.out.println(&quot;foo1(char x)&quot;); } void foo1(byte x) { System.out.println(&quot;foo1(byte x)&quot;); } void foo1(short x) { System.out.println(&quot;foo1(short x)&quot;); } void foo1(int x) { System.out.println(&quot;foo1(int x)&quot;); } void foo1(long x) { System.out.println(&quot;foo1(long x)&quot;); } void foo1(float x) { System.out.println(&quot;foo1(float x)&quot;); } void foo1(double x) { System.out.println(&quot;foo1(double x)&quot;); } /*==========================foo2 Overload===========================*/ void foo2(byte x) { System.out.println(&quot;foo2(byte x)&quot;); } void foo2(short x) { System.out.println(&quot;foo2(short x)&quot;); } void foo2(int x) { System.out.println(&quot;foo2(int x)&quot;); } void foo2(long x) { System.out.println(&quot;foo2(long x)&quot;); } void foo2(float x) { System.out.println(&quot;foo2(float x)&quot;); } void foo2(double x) { System.out.println(&quot;foo2(double x)&quot;); } /*==========================foo3 Overload===========================*/ void foo3(short x) { System.out.println(&quot;foo3(short x)&quot;); } void foo3(int x) { System.out.println(&quot;foo3(int x)&quot;); } void foo3(long x) { System.out.println(&quot;foo3(long x)&quot;); } void foo3(float x) { System.out.println(&quot;foo3(float x)&quot;); } void foo3(double x) { System.out.println(&quot;foo3(double x)&quot;); } /*==========================foo4 Overload===========================*/ void foo4(int x) { System.out.println(&quot;foo4(int x)&quot;); } void foo4(long x) { System.out.println(&quot;foo4(long x)&quot;); } void foo4(float x) { System.out.println(&quot;foo4(float x)&quot;); } void foo4(double x) { System.out.println(&quot;foo4(double x)&quot;); } /*==========================foo5 Overload===========================*/ void foo5(long x) { System.out.println(&quot;foo5(long x)&quot;); } void foo5(float x) { System.out.println(&quot;foo5(float x)&quot;); } void foo5(double x) { System.out.println(&quot;foo5(double x)&quot;); } /*==========================foo6 Overload===========================*/ void foo6(float x) { System.out.println(&quot;foo6(float x)&quot;); } void foo6(double x) { System.out.println(&quot;foo6(double x)&quot;); } /*==========================foo7 Overload===========================*/ void foo7(double x) { System.out.println(&quot;foo7(double x)&quot;); }} 我们会发现常量值6被foo1/foo2/foo3/foo4方法当做int值进行处理，foo5/foo6/foo7没有int类型的重载方法，被自动类型转换成了“较大”的类型（long/float/double）。 对于char类型的’x’，foo1方法包含对应类型的重载，剩余6种方法不包含char类型的重载，但foo2/foo3/foo4直接将char类型自动类型转换成了int类型。foo5/foo6/foo7分别将char类型隐式转换成了long/float/double类型。 char类型是不会被自动类型转换成byte/short类型的。其原因可查看这篇文章：传送门 对于byte类型的1，foo1/foo2方法包含对应类型的重载；剩余5种方法不包含char类型的重载，被分别隐式转换成了short/int/long/float/double类型。 对于short类型的1，foo1/foo2/foo3方法包含对应类型的重载；剩余4种方法不包含short类型的重载，被分别隐式转换成了int/long/float/double类型。 对于int类型的1，foo1/foo2/foo3/foo4方法包含对应类型的重载；foo5/foo6/foo7不包含int类型的重载，被分别隐式转换成了long/float/double类型。 对于long类型的1，foo1/foo2/foo3/foo4/foo5方法包含对应类型的重载；foo6/foo7不包含long类型的重载，被分别隐式转换成了float/double类型。 对应float类型的1，foo7不包含float类型的重载，被隐式转换成了double类型；而其它6种方法包含对应类型的重载。 对于double类型的1,7种方法都有对应类型的重载。 数值基本类型隐式转换图如下： 实线箭头无精度丢失，虚线箭头可能丢失精度。 传入的实际参数范围大于重载方法声明的形式参数范围反过来，如果传入的实际参数范围大于重载方法声明的形式参数，会是什么情况呢？我们再来测试一下。 foo1方法包含char/byte/short/int/long/float/double这7种基本数据类型的重载； foo2方法包含char/byte/short/int/long/float这6种基本数据类型的重载； foo3方法包含char/byte/short/int/long这5种基本数据类型的重载； foo4方法包含char/byte/short/int这4种基本数据类型的重载； foo5方法包含char/byte/short这3种基本数据类型的重载； foo6方法包含char/byte这2种基本数据类型的重载； foo7方法只有一个char类型参数的方法； 使用double类型的3.1415926分别调用foo系列的方法。我们可以看到编译器提示了错误：Cannot resolve method 'foo2(double)'等。除了foo1方法外，其余foo系列的方法都不包含double类型的重载，编译器也不会隐式将double类型自动转换成其它基本类型，其原因在于double类型的取值范围（二进制位数）是最大的，如果将double类型的数据隐式转换成其它基本类型，可能会出现精度丢失的问题，这是有风险的，编译器不会自动帮我们做。 我们需要强制类型转换（显式转换）进行窄化处理，这样做可能会丢失精度。但如果不这样做，我们无法正常进行方法的调用。 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165package com.sunchaser.javase.base.overload;import org.junit.Test;/** * @author sunchaser * @date 2020/1/8 * @description * 基本数据类型重载的测试：基本数据类型范围较大的需要强制类型转换（显式转换）进行窄化处理，转换成范围较小的类型。 * * 基本数据类型（除去boolean）范围如下： * '[' 和 ']' 表示闭区间。 * * byte | 8 bits | [-128, +127] * char | 16 bits | ['\\u0000', '\\uFFFF'] * short | 16 bits | [-2^15, +2^15 - 1] * int | 32 bits | [-2^31, +2^31 - 1] * float | 32 bits | IEEE754范围 * double | 64 bits | IEEE754范围 * long | 64 bits | [-2^63, +2^63 - 1] * @since 1.0 */public class BigToSmallDataTypeOverloadTest { /** * print: * * double: 3.1415926 * foo1(double x) * foo2(float x) * foo3(long x) * foo4(int x) * foo5(short x) * foo6(byte x) * foo7(char x) * (float) d：3.1415925 // 可看到精度已经丢失 * (long) d：3 * (int) d：3 * (short) d：3 * (byte) d：3 * (char) d：3 */ @Test public void testDouble() { double d = 3.1415926; System.out.println(&quot;double: &quot; + d); foo1(d); foo2((float) d); foo3((long) d); foo4((int) d); foo5((short) d); foo6((byte) d); foo7((char) d); float f = (float) d; System.out.println(&quot;(float) d：&quot; + f); long l = (long) d; System.out.println(&quot;(long) d：&quot; + l); int i = (int) d; System.out.println(&quot;(int) d：&quot; + i); short s = (short) d; System.out.println(&quot;(short) d：&quot; + s); byte b = (byte) d; System.out.println(&quot;(byte) d：&quot; + b); char c = (char) d; System.out.println(&quot;(char) d：&quot; + (c + 1 - 1)); // 查看char表示的数值 } /*==========================foo1 Overload===========================*/ void foo1(char x) { System.out.println(&quot;foo1(char x)&quot;); } void foo1(byte x) { System.out.println(&quot;foo1(byte x)&quot;); } void foo1(short x) { System.out.println(&quot;foo1(short x)&quot;); } void foo1(int x) { System.out.println(&quot;foo1(int x)&quot;); } void foo1(long x) { System.out.println(&quot;foo1(long x)&quot;); } void foo1(float x) { System.out.println(&quot;foo1(float x)&quot;); } void foo1(double x) { System.out.println(&quot;foo1(double x)&quot;); } /*==========================foo2 Overload===========================*/ void foo2(char x) { System.out.println(&quot;foo2(char x)&quot;); } void foo2(byte x) { System.out.println(&quot;foo2(byte x)&quot;); } void foo2(short x) { System.out.println(&quot;foo2(short x)&quot;); } void foo2(int x) { System.out.println(&quot;foo2(int x)&quot;); } void foo2(long x) { System.out.println(&quot;foo2(long x)&quot;); } void foo2(float x) { System.out.println(&quot;foo2(float x)&quot;); } /*==========================foo3 Overload===========================*/ void foo3(char x) { System.out.println(&quot;foo3(char x)&quot;); } void foo3(byte x) { System.out.println(&quot;foo3(byte x)&quot;); } void foo3(short x) { System.out.println(&quot;foo3(short x)&quot;); } void foo3(int x) { System.out.println(&quot;foo3(int x)&quot;); } void foo3(long x) { System.out.println(&quot;foo3(long x)&quot;); } /*==========================foo4 Overload===========================*/ void foo4(char x) { System.out.println(&quot;foo4(char x)&quot;); } void foo4(byte x) { System.out.println(&quot;foo4(byte x)&quot;); } void foo4(short x) { System.out.println(&quot;foo4(short x)&quot;); } void foo4(int x) { System.out.println(&quot;foo4(int x)&quot;); } /*==========================foo5 Overload===========================*/ void foo5(char x) { System.out.println(&quot;foo5(char x)&quot;); } void foo5(byte x) { System.out.println(&quot;foo5(byte x)&quot;); } void foo5(short x) { System.out.println(&quot;foo5(short x)&quot;); } /*==========================foo6 Overload===========================*/ void foo6(char x) { System.out.println(&quot;foo6(char x)&quot;); } void foo6(byte x) { System.out.println(&quot;foo6(byte x)&quot;); } /*==========================foo7 Overload===========================*/ void foo7(char x) { System.out.println(&quot;foo7(char x)&quot;); }} 从输出结果中可看到：double类型的3.1415926强制转换成float时变成了3.1415925，精度已经丢失；而强制转换成long/int/short/byte/char时浮点部分直接被舍弃。 返回值能区分重载方法吗？例如有下面两个方法： 123void foo() {}int foo() {return -1;} 我们人用肉眼去看方法的声明很容易分辨这两个同名方法的不同之处。但是当我们去调用foo方法时，如果我们的调用方式是：int x = foo()，那么的确可以明确我们调用的是int foo() {return -1;}；但有时候我们并不在意返回值（只是调用方法去执行某个操作），调用方式为：foo()，这时候Java如何才能判断调用的是哪一个foo()呢？程序员又该如何理解这种代码呢？因此，返回值是不能区分方法重载的。 int和Integer的形参是重载方法吗？例如有下面两个方法： 1234567void foo(int x) { System.out.println(&quot;int&quot;);}void foo(Integer y) { System.out.println(&quot;Integer&quot;);} 它们是重载方法吗？ 即使int和Integer之间存在自动装箱/拆箱操作，但它们仍是重载的方法。 我们传递int类型的变量给foo，编译器并不会进行装箱操作，因为有对应的int类型重载方法；相应地，我们传递Integer类型的变量给foo，编译器不会进行拆箱操作，而是调用对应Integer类型的重载方法。 我们传递字面量1给foo方法，编译器会默认当成基本类型int调用foo。 测试代码如下： 12345678910111213141516171819/** * print: * * int * int * Integer * * 字面量值1是int基本数据类型 * * 是重载方法 */@Testpublic void testIntInteger() { foo(1); int x = 1; foo(x); Integer y = 1; foo(y);} 以上就是方法重载Overload的全部内容，完整示例代码地址见：传送门","link":"/2020/01/09/javase/base/method-overload/"},{"title":"2019年度总结","text":"2019是日无暇晷的一年。 从年初的大四准毕业生到现在半年经验的职场少年，一路走来，从技术菜鸟到小有成就，从稚嫩到沉稳，这是成长的印记。 2019前3个月是艰难的。犹记得2018年9月秋招经历过的恐惧，大三时“听信了”大学老师的谗言：PHP是世界上最好的语言。大三一整年都在学习PHP，某马程序员官网放出的PHP视频教程看了80%多。但现实终究是残酷的，国内大部分企业后端都还是以Java语言为主（别跟我讲百度用PHP）。秋招的PHP岗位实在是太少了，加上我只是一个双非普通一本学历，又没有什么拿得出手的获奖证书，根本就没有一点竞争力。于是修改了简历，项目经验写上了大学Java Web课程设计写的JSP+Servlet项目，就开始转向投递Java岗。 终于过了一家深圳互联网公司的笔试，来到面试阶段，跟面试官聊了一下大三学PHP的事情，然后开始问技术方面的问题，现在回想起来，当时的问题算得上是非常基础的知识点了。例如：int和Integer的区别？int和Integer作为同名方法的参数，算不算重载？ 这是我的第一次Java面试，面试过程中满怀信心觉得自己都答对了，面试出来后查了下百度，发现好像一个都没答对。“电子竞技，菜是原罪”。 当时深刻认识到凭当时的自身技术能力想找Java开发的岗位几乎是不可能的，于是做了一个很果断的决定，停止投递简历，系统学习Java知识体系，等待春招。 某北大学计算机学院的学生宿舍在校外（俗称“三期”公寓），没有独卫，没有空调，六人间。自学是很考验人的，那个时候刚转向Java，疯狂的找学习资料，某马程序员，某硅谷，某学堂，某客网，某宝…几乎所有的免费视频教程我都下载了。面对几十个G的资源，我陷入了迷茫，该从何学起呢？ 那个时候我的知识体系基本是一片空白，只有大学的Java基础课程和J2EE课程学的一点知识储备。听了同学的建议后，决定从某客网高级项目课开始学起，跟随项目需求，对项目中用到的知识点，技术框架进行细致学习。然而一切都是艰难的，这个项目用的技术栈主要是Spring Boot、Mybatis等，对于当时连Spring都不知道的我，实在是太难了。 于是我打开了某马程序员的Spring入门到精通视频，从传统的Java Web到引入DI/IOC，大概能听懂一点，我开始打开IDE对着视频敲代码，经常一个视频重复播放三遍甚至更多，第一遍是听大概的内容，第二遍是细听，然后跟着敲代码，第三遍是总结性的听，做一些笔记。 但是我发现，我对Java语言的一些基础性的语法和概念还不是太熟悉，于是我打开了2018年双十一买的《Java编程思想》，开始了解Java语言的一些特性。同时还看了某马程序员创始人张老师的《Java高新技术》视频课程，对我影响甚大，视频内容基本是JDK5的新特性，包括静态导包、可变参数、增强for循环、自动拆/装箱、享元设计模式、枚举、反射、类加载器、双亲委派模型、注解、泛型和动态代理等。这套视频算得上是彻底改变了我，真正的让我入了Java的门。 此后，还看了张老师的《Java多线程与并发库》这套视频，这套视频奠定了我的Java基础，视频主要讲解了传统线程同步与互斥技术、ThreadLocal类、Callable和Future类、Timer定时器类、线程池、读写锁、闭锁、栅栏、计数器、阻塞队列、原子操作类和同步集合等内容。 再之后，我接触到了Spring，Spring MVC，Mybatis，Maven，Spring Boot，Redis…等一些技术栈。 基本熟悉这些框架之后，我继续了某客网高级项目课，春节在家的一个月，跟着视频把代码写的差不多了。然后把这个项目当做项目经验填充在自己的简历上。 对于这个项目，我并不是完全照搬视频中所讲，而是采用标准前后端分离开发模式，前端选择了Vue全家桶技术栈，后端则是视频中的Spring Boot技术栈，这对于我的项目经验来说是一个加分项。 经过为期五个月的学习，我开始春招的步伐，经过二月底三月初一个多月的跑宣讲会，参加笔试面试，最终收获了一家武汉的Offer，一切都挺幸运的，这家公司的薪资，技术栈都比较满意。终于是功夫不负有心人。 7月，入职。 进入新公司，新环境，成为了社会人，很激动。 9月，参与的第一个需求上线。老总请喝酒，喝吐了一片人，我也吐倒在门外。 10月，开始了今年最大的一个项目，加班通宵了两次。很累。 12月，出差来到了北京，看了天安门，看了紫禁城，看了恭王府，看了水立方，看了鸟巢。不虚此行。 末了，12月的最后一天进行了转正答辩，应该是转正了。 且行且珍惜。 2020年，希望可以遇见更好的自己，提高时间规划能力与自控力，形成自己的知识体系，并深入到技术中。","link":"/2019/12/31/annual-summary/2019/"},{"title":"软件设计模式的概念与意义","text":"软件设计模式的概念与意义设计模式的概念设计模式，是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。在很多开源框架中都有设计模式思想的体现，尽管有些设计模式逐渐被编程语言的新语法特性给颠覆，但其设计思想依旧是值得我们学习的。 设计模式的意义设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。 学习设计模式有以下意义： 可以提高思维能力、编程能力和设计能力。 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。 有利于阅读一些开源框架源码。","link":"/2019/12/12/design-patterns/gof/Design-pattern-overview/"},{"title":"GoF的23种设计模式","text":"GoF设计模式简介GoF是设计模式的经典名著Design Patterns: Elements of Reusable Object-Oriented Software（中译本名为《设计模式——可复用面向对象软件的基础》）的四位作者，他们分为是：Elich Gamma、Richard Helm、Ralph Johnson、以及John Vlissides。这四个人常被称为Gang of Four， 即四人组，简称GoF。这本书中总结的23种设计模式称为GoF设计模式。 设计模式分类设计模式有两种分类方法：根据模式的目的划分和根据模式的作用范围划分。 根据目的划分根据模式是用来完成什么工作来划分，可分为创建型模式、结构型模式和行为型模式。 创建型模式：用于描述“如何创建对象”，主要特点是“将对象的创建和使用分离”。GoF的创建型模式包括单例模式、原型模式、工厂方法模式、抽象工厂模式和建造者模式。 结构型模式：用于描述如何将类或对象按某种布局组成更大的结构。GoF的结构型模式包括代理模式、适配器模式、桥接模式、装饰器模式、外观模式、享元模式和组合模式。 行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF的行为型模式包括责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式和访问者模式。 根据作用范围划分根据模式是主要作用于类上还是主要作用于对象上来划分，可分为类模式和对象模式。 类模式：用于处理类和子类之间的关系，这些关系通过继承来建立，是静态的，在编译时期就确定了。GoF的类模式包括工厂方法模式、适配器模式（类）、模板方法模式和解释器模式。 对象模式：用于处理对象之间的关系，这些关系可以通过组合和聚合来实现，在运行时期是可以动态改变的。GoF中除了类模式，其余都是对象模式。 下表描述了设计模式的分类： 范围\\目的 创建型 结构型 行为型 类模式 工厂方法模式 适配器模式（类） 模板方法模式解释器模式 对象模式 单例模式原型模式抽象工厂模式建造者模式 代理模式适配器模式（对象）桥接模式装饰器模式外观模式享元模式组合模式 策略模式命令模式责任链模式状态模式观察者模式中介者模式迭代器模式访问者模式备忘录模式 GoF的23种设计模式 单例模式（Singleton）：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。 原型模式（Prototype）：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。 工厂方法模式（Factory Method）：定义一个用于创建产品的接口，由子类决定生产什么产品。 抽象工厂模式（AbstractFactory）：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。 建造者模式（Builder）：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。 代理模式（Proxy）：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。 适配器模式（Adapter）：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 桥接模式（Bridge）：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 装饰模式（Decorator）：动态的给对象增加一些职责，即增加其额外的功能。 外观模式（Facade）：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。 享元模式（Flyweight）：运用共享技术来有效地支持大量细粒度对象的复用。 组合模式（Composite）：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。 模板方法模式（TemplateMethod）：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。 策略模式（Strategy）：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。 命令模式（Command）：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。 职责链模式（Chain of Responsibility）：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。 状态模式（State）：允许一个对象在其内部状态发生改变时改变其行为能力。 观察者模式（Observer）：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。 中介者模式（Mediator）：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。 迭代器模式（Iterator）：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 访问者模式（Visitor）：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。 备忘录模式（Memento）：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复。 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。 值得注意的是，这23种设计模式不是孤立存在的，很多模式之间存在一定的关联关系。","link":"/2019/12/12/design-patterns/gof/GoF's-23-design-patterns/"},{"title":"《Java 8实战》读书笔记系列——第一部分：基础知识","text":"第一章：为什么要关心Java 8第一章主要需要了解Java语言的发展历史。 Java 8的前世今生从第一个Java版本诞生到现在已经有23年的时间了。沧海桑田一瞬间，转眼24年过去了，如今JDK 8以上的版本也开始收费了，JDK 11成为目前长期支持的版本。版本不断变更的这几年，很多企业项目还是在用JDK 8或更低的版本进行维护。但是对于我们开发者来说，始终要不断地学习了解新特性和新技术，否则大浪淘沙，终有一日将成为沙滩上的一条咸鱼。 时间在变，但我们对技术的那份初心永不会变。作为一个Java开发工程师，很有必要来了解一下Java语言发展史。 1995年5月23日，从Oak（橡树）到Java，Java语言第一次提出了”Write Once, Run Anywhere”的口号。 1996年1月23日，Java语言的第一个正式版本的运行环境JDK 1.0发布。 1998年12月4日，JDK的第一个里程碑式的版本JDK 1.2发布，工程代号为Playground（竞技场）。sun公司在这个版本中把Java技术体系拆分为三个方向，分别是面向桌面应用开发的J2SE（Java 2 Platform，Standard Edition）、面向企业级开发的J2EE（Java 2 Platform，Enterprise Edition）和面向手机等移动终端开发的J2ME（Java 2 Platform，Micro Edition）。 2000年5月8日，工程代号为Kestrel（美洲红隼 [sǔn] ）的JDK 1.3发布，它还有一个修正版本JDK 1.3.1，工程代号为Ladybird（瓢虫），于2001年5月17日发布。从这个版本开始，Sun公司维持了一个习惯：大约每隔两年发布一个JDK的主版本，以动物命名，期间发布的各个修正版本则以昆虫作为工程名称。 2002年2月13日，工程代号为Merlin（灰背隼）的JDK 1.4发布。后续还有两个修正版本：2002年9月16日发布的工程代号为Grasshopper（蚱蜢）的JDK 1.4.1和2003年6月26日发布的工程代号为Mantis（螳螂）的JDK 1.4.2。 2004年9月30日，工程代号为Tiger（老虎）的JDK 1.5发布。这个版本的JDK在我看来是Java语言能发展到今天的基石。它提供了自动装箱、泛型、动态注解、枚举、可变长参数、foreach循环和java.util.concurrent并发包等新特性，这些新特性都是Java语言的生命之所在。官方从这个版本开始，在正式文档与宣传上都不再使用类似JDK 1.5的命名，而是使用JDK 5，JDK 6，JDK 7…。只有在程序员内部使用的开发版本号（例如java-version的输出）中才继续沿用1.5，1.6，1.7的版本号。 2006年12月11日，工程代号为Mustang（野马）的JDK 6发布。在这个版本中，Sun公司终结了从JDK 1.2开始已经有8年历史的J2EE、J2SE、J2ME的命名方式，启用Java SE、Java EE、Java ME的命名方式。同年11月13日的JavaOne大会上，Sun公司宣布将Java开源，并建立OpenJDK组织对开源代码进行管理。 2009年2月19日，工程代号为Dolphin（海豚）的JDK 7的第一个版本发布。JDK 7本应是一个包含许多重要改进的版本，JDK 8中的Lambda项目原本计划安排在JDK 7中发布，但由于各种商业原因，Sun公司无力进行JDK 7的研发工作。同年4月20日，Oracle公司收购Sun公司，将很多未实现的改进进行裁剪延期，以保证JDK 7的正式版能够在2011年7月28日准时发布。 2011年7月28日，Oracle公司发布工程代号为Dolphin（海豚）的JDK 7正式版。 2014年3月18日，Oracle公司发布工程代号为Spider（蜘蛛）的JDK 8。 2017年9月21日，Oracle公司发布JDK 9。 Java 8的新特性列表 Lambda表达式和方法引用 流处理StreamAPI 默认方法 Optional类 CompletableFuture接口 新的日期时间API 第二章：通过行为参数化传递代码 行为参数化，就是一个方法接受多个不同的行为作为参数，并在内部使用它们，完成不同行为的能力。 行为参数化可让代码更好地适应不断变化的要求，减轻未来的工作量。 传递代码，就是将新行为作为参数传递给方法。但在Java 8之前这实现起来很啰嗦。为接口声明许多只用一次的实体类而造成的啰嗦代码，在Java 8之前可以用匿名类来减少。 Java API包含很多可以用不同行为进行参数化的方法，包括排序、线程和GUI处理。 第三章：Lambda表达式函数式接口函数式接口就是只定义一个抽象方法的接口。接口现在还可以拥有默认方法（即在类没有对方法进行实现时，其主体为方法提供默认实现的方法）。哪怕有很多默认方法，只要接口只定义了一个抽象方法，它就仍然是一个函数式接口。 函数式接口的抽象方法的签名称为函数描述符。 Java8 内置四大核心函数式接口java.util.function包下： 消费型接口：Consumer&lt;T&gt; {void accept(T t);} 供给型接口：Supplier&lt;T&gt; {T get();} 函数型接口：Function&lt;T,R&gt; {R apply(T t);} 断言型接口：Predicate&lt;T&gt; {boolean test(T t);} 原始类型特化函数式接口为了避免装箱操作，对Predicate&lt;T&gt;和Function&lt;T, R&gt;等通用函数式接口的原始类型特化：IntPredicate、IntToLongFunction等。 方法引用如果一个Lambda代表的只是“直接调用这个方法”，那好还是用名称来调用它，而不是去描述如何调用它。 如何构建方法引用方法引用主要有三类。 (1) 指向静态方法的方法引用（例如Integer的parseInt方法，写作Integer::parseInt）。 (2) 指向任意类型实例方法的方法引用（例如String 的 length 方法，写作String::length）。 (3) 指向现有对象的实例方法的方法引用（假设你有一个局部变量expensiveTransaction用于存放Transaction类型的对象，它支持实例方法getValue，那么你就可以写expensive- Transaction::getValue）。 将Lambda表达式重构为等价的方法引用(1) Lambda：(args) -&gt; ClassName.staticMethod(args) 等价的方法引用为：ClassName::staticMethod。 (2) Lambda：(arg0,test) -&gt; arg0.instanceMethod(test) 等价的方法引用为：ClassName::instanceMethod，其中arg0的类型是ClassName。 (3) Lambda：(args) -&gt; expr.instanceMethod(args) 等价的方法引用为：expr::instanceMethod。","link":"/2019/12/12/reading-notes/java8-in-action/Part-I-Basics/"},{"title":"《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（一）：接口重构和新特性","text":"第八章：重构、测试和调试1. 为改善可读性和灵活性重构代码如果方向错了，停下来就是前进。 看完老员工留下来的代码，无力吐槽。如果以系统稳定可用为原则，不去改善代码可维护性，那等到将来需求变动需要修改时，对我们这些底层码农来说简直是一种折磨。欠下的技术债迟早是要还的。 1.1 从匿名类到Lambda表达式的转换匿名类和Lambda表达式中的this含义是不同的。在匿名类中，this指代的是匿名类本身。但是在Lambda中，this指代的是包含Lambda表达式的类。 匿名类可以屏蔽包含类的变量，而Lambda表达式不能（编译都不能通过），例如： 123456789101112131415public void testAnonymityToLambda() { int a = 10; Runnable r1 = () -&gt; { // 再次定义a变量会报错 // int a = 1; System.out.println(a); }; Runnable r2 = new Runnable() { @Override public void run() { int a = 2; System.out.println(a); } };} 1.2 使用Lambda重构设计模式Lambda表达式为解决传统设计模式所面对的问题提供了新的解决方案。使用Lambda表达式后， 很多现存的略显臃肿的面向对象设计模式能够用更精简的方式实现了。例如： 策略模式 模板方法设计模式 责任链模式 工厂模式 2. 测试Lambda表达式使用Stream接口提供的peek方法可查看流水线中每个操作的中间状态，方便调试排错。 12345678910111213public static void testPeek() { List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4, 5, 6, 7); nums.stream() .peek(x -&gt; System.out.println(&quot;before map&quot; + x)) .map(x -&gt; x + 17) .peek(x -&gt; System.out.println(&quot;before filter&quot; + x)) .filter(x -&gt; x % 2 == 0) .peek(x -&gt; System.out.println(&quot;before limit&quot; + x)) .limit(3) .peek(x -&gt; System.out.println(&quot;before collect&quot; + x)) .collect(Collectors.toList()) .forEach(System.out::println);} 第九章：默认方法先来回顾一下接口的相关知识。 接口使用interface关键字声明，访问修饰符可以为public和默认（不写）；同时可以使用abstract关键字修饰，因为接口可以理解成一种完全抽象。使用abstract关键字编译器会让你通过编译，但一般没有人这样做。 Java 8 前 接口中的成员变量的修饰符全部默认为public static final，也可以不是静态static的，但一般没有人这样做。 接口中的方法只能是抽象方法。 接口中方法的修饰符全部默认为public abstract。 Java 8 后 接口中新增默认方法–使用default关键字声明。 接口中可以声明静态方法。 为什么要有默认方法？如果原来的接口已经被很多人使用了，现在要在原来的接口中新增一个方法，在Java 8之前，所有的实现类都需要去显式实现这个方法，会造成很多不必要的麻烦，也许有些实现类根本就不需要用到新增的这个方法，反而需要强制在代码中写一个显式的空实现。正是由于这个原因，Java 8提供了默认方法，接口中新增的方法使用default关键字修饰，就可以在接口中提供一个默认实现，实现类不再需要强制显式实现这个新增方法。这个新特性主要是面向类库开发者。 默认方法引发的多实现冲突问题一个类只能继承一个父类，但是可以实现多个接口。由于出现了默认方法，当一个类有多个实现时可能会出现方法继承冲突的问题。 解决问题的三个原则 类中的方法优先级最高。类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。 如果无法依据第一条进行判断，那么子接口的优先级更高：函数签名相同时，优先选择拥有最具体实现的默认方法的接口，即如果B继承了A，那么B就比A更加具体。 最后，如果还是无法判断，继承了多个接口的类必须通过显式覆盖和调用期望的方法，显式地选择使用哪一个默认方法的实现。 冲突情况分析情形一 接口InterfaceA中定义了默认方法hello。 接口InterfaceB继承了接口InterfaceA，同时提供自己的默认hello方法。 实现类ImplClassC实现InterfaceA接口和InterfaceB接口，没有显式实现hello方法。 接口InterfaceB继承了InterfaceA，接口InterfaceB中的hello方法更具体，所以实现类ImplClassC拥有的是InterfaceB接口中的hello方法。 情形二 接口InterfaceA中定义了默认方法hello。 接口InterfaceB继承了接口InterfaceA，同时提供自己的默认hello方法。 实现类ImplClassD实现InterfaceA接口，未显式重写接口的hello方法。 实现类ImplClassC继承ImplClassD类，同时实现InterfaceA和InterfaceB接口，没有显式实现hello方法。 ImplClassC和ImplClassD类中都未实现hello方法，InterfaceB继承InterfaceA接口，所以InterfaceB接口中的方法更具体，所以ImplClassC类具有的是InterfaceB中的hello方法。 情形三 接口InterfaceA中定义了默认方法hello。 接口InterfaceB继承了接口InterfaceA，同时提供自己的默认hello方法。 实现类ImplClassD实现了InterfaceA接口，并显式重写了接口的hello方法。 实现类ImplClassC继承了ImplClassD实现类，并实现了InterfaceA和InterfaceB接口，没有显式实现hello方法。 ImplClassC和ImplClassD类中都未实现hello方法，InterfaceB继承InterfaceA接口，所以InterfaceB接口中的方法更具体，所以ImplClassC类具有的是InterfaceB中的hello方法。 情形四 接口InterfaceA中定义了默认方法hello。 接口InterfaceB中定义了默认方法hello，未继承。 实现类ImplClassC实现InterfaceA和InterfaceB接口。 如果实现类ImplClassC不重写hello方法，编译器会抛出编译错误：ImplClassC inherits unrelated defaults for hello() from types InterfaceA and InterfaceB。 可以直接在实现类中重新写一个hello方法的实现，也可以使用super关键字调用父接口的默认实现。 情形五 接口InterfaceA中定义了默认方法hello。 接口InterfaceB继承了接口InterfaceA，未提供任何方法。 接口InterfaceC继承了接口InterfaceA，未提供任何方法。 实现类ImplClassD实现InterfaceB和InterfaceC接口。 InterfaceB和InterfaceC接口中都没有hello实现，它们的父接口InterfaceA中才有hello的默认实现，所以实现类ImplClassD拥有接口InterfaceA中hello方法。 情形五扩展如果InterfaceB中也提供hello默认实现，根据规则第二点，编译器会选择InterfaceB中声明的默认方法。 如果InterfaceB和InterfaceC都提供hello默认实现，就会出现冲突，ImplClassD实现类必须实现hello方法。 如果InterfaceC接口中添加非默认抽象方法hello，那么它比继承InterfaceA接口而来的hello优先级高，此时实现类ImplClassD必须显式实现InterfaceC的hello抽象方法。","link":"/2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(1)/"},{"title":"《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（二）：优雅的解决NPE问题","text":"第十章：用Optional取代nullnull引用的想法最初由一位英国计算机科学家提出。他认为这是为”不存在的值“建模最容易的方式。设计初衷是通过编译器的自动检测机制，确保所有使用引用的地方都是绝对安全的。近些年出现的现代程序设计语言包括Java在内，都采用了相同的设计方式。 null 引用带来的问题 错误之源：程序员对对象的字段进行检查，判断字段的值是否为期望的格式，最终却发现访问的并不是一个对象，而是一个null引用–空指针，于是抛出一个NullPointerException异常。 代码膨胀：为了防止null，我们经常会写出这样类似的代码：if (xxx != null) { // dosomething}。这样你的代码就会充斥着深度嵌套的null检查，代码可读性极差。 毫无意义：null自身没有任何的语义，尤其是，它代表的是在静态类型语言中以一种错误的方式对缺失变量值的建模。 破坏哲学：Java一直试图避免让程序员意识到指针的存在，唯一的例外是：null指针。 使用防御式编程思想减少NPE问题NullPointerException简称NPE。 采用防御式编程–快速失败的思想可以有效减少NPE问题。 如下的代码是推荐的方式： 1234567if (param1 == null) { return false;}if (param2 == null) { return false;}// do service 不要使用try-catch的方式来处理。例如： 12345try { param.function();} catch (NullPointerException e) { ...} 使用这种防御式编程的方法能有效解决问题，但仍然极易出错，一旦忘记检查那个可能为null的属性就会埋下一个隐藏的bug。 优雅的解决方式Java 8中引入了一个新的类java.util.Optional&lt;T&gt;来优雅的解决NPE问题。 假设现在有一个Person类，有一个成员变量：汽车Car类；汽车Car类中又有一个成员变量：保险公司Insurance类；保险公司Insurance类中有一个成员变量：String类型的公司名。你可能会按下面的方式设计。Person类： 123456public class Person { private Car car; public Car getCar() { return car; }} Car类： 123456public class Car { private Insurance insurance; public Insurance getInsurance() { return insurance; }} Insurance类： 123456public class Insurance { private String name; public String getName() { return name; }} 但是我们知道一个人可能有车也可能没有车，当一个人没车时需要将null引用赋值给car变量，于是我们应该将car变量声明为Optional&lt;Car&gt;类型；一辆车可能买了保险也可能没买保险，于是Car类中的insurance字段也应该声明为Optional&lt;Insurance&gt;类型；保险公司一定有一个公司名称，所以Insurance类中的name字段不用声明成Optional类型。新的类定义如下：Person类： 12345678import java.util.Optional;public class Person { private Optional&lt;Car&gt; car; public Optional&lt;Car&gt; getCar() { return car; }} Car类： 12345678import java.util.Optional;public class Car { private Optional&lt;Insurance&gt; insurance; public Optional&lt;Insurance&gt; getInsurance() { return insurance; }} Insurance类： 123456public class Insurance { private String name; public String getName() { return name; }} 当car变量存在时，Optional类只是对Car类简单封装。当变量不存在时，缺失的值会被建模成一个“空” 的Optional对象，由方法Optional.empty()返回。Optional.empty()方法是一个静态工厂 方法，它返回Optional类的特定单一实例，与null完全不一样。 何时使用Optional类？在实际业务编码中，我们只能靠自己对业务模型的理解进行判断，需要判断出一个null是否属于某个变量的有效范围。 值得注意的是：如果一个类包含了Optional成员变量，则该类无法进行序列化和反序列化。 原因是Optional类未实现序列化Serializable接口。所以如果你的类是类似Dubbo服务提供者返回的模型对象，则不能将类成员设计成Optional类型。 Java语言的架构师Brian Goetz曾经非常明确地陈述过，Optional的设计初衷仅仅是要支持能返回Optional对象的语法。由于Optional类设计时就没特别考虑将其作为类的字段使用，所以它并未实现Serializable接口。 应用Optional的几种模式1. 创建Optional对象 声明一个空的Optional：通过静态工厂方法Optional.empty，创建一个空的Optional对象：1Optional&lt;Car&gt; optCar = Optional.empty(); 依据一个非空值创建Optional：使用静态工厂方法Optional.of，依据一个非空值创建一个Optional对象： 1Optional&lt;Car&gt; optCar = Optional.of(car); 如果car变量是一个null值，则这段代码会立即抛出NullPointerException，而不是等到试图访问car的属性时才返回一个错误。 可接受null的Optional：使用静态工厂方法Optional.ofNullalbe，创建一个允许null值的Optional对象：1Optional&lt;Car&gt; optCar = Optional.ofNullable(car); 如果car变量是一个null值，那么得到的Optional对象就是个空对象。 2. 使用map从Optional对象中提取和转换值Optional类的map方法和Stream类的map方法相差无几。map方法会将流中的每个元素通过提供的函数进行映射。可以把Optional对象看成一个特殊的集合，它最多包含一个元素。如果Optional包含一个值，那map方法就会把该值通过提供的函数映射成其它值，否则什么也不做。 3. 使用flatMap链接Optional对象同样的，Optional类的flatMap方法和流的用法也类似。flatMap方法接收一个函数作为参数，这个函数的返回值是另一个流。这个函数会应用到流中的每一个元素上，于是每个元素被映射成一个小流，每个小流又形成一个大流作为flatMap方法的返回值。但是flatMap会将这个大流中的小流扁平化成一个单一的流。即流中不包含流，只包含各个元素。 4. 默认行为及解引用Optional对象Optional类提供了多种方法读取Optional实例中的变量值。 get()：如果变量存在，直接返回封装的变量值，否则抛出一个NoSuchElementException异常。 orElse(T other)：允许在Optional对象不包含值时提供一个默认值。 orElseGet(Supplier&lt;? extends T&gt; other)：是orElse方法的延时调用版，Supplier方法只有在Optional对象不含值时才执行调用。如果创建默认值是件耗时操作，考虑使用该方法；或者非常确定某个方法仅在Optional为空时才执行调用，也考虑使用该方法。 orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)：和get方法类似，如果取出的值为空都会抛出一个异常，使用orElseThrow可以定制希望抛出的异常类型。 ifPresent(Consumer&lt;? extends T&gt;)：在变量值存在时执行一个传入的Consumer方法，否则不做任何处理。 5. 使用filter剔除特定的值我们经常需要调用某个对象的方法，查看它的某些属性。比如，我们可能需要检查保险公司的名称是否为CambridgeInsurance，为了以一种安全的方式进行这些操作，我们首先需要确定引用指向的Insurance对象是否为null，之后再调用它的getName方法。示例如下： 1234Insurance insurance = ...;if (insurance != null &amp;&amp; &quot;CambridgeInsurance&quot;.equals(insurance.getName())) { System.out.println(&quot;ok&quot;);} 如果使用Optional对象的filter方法，这段代码可以重构如下： 123Optional&lt;Insurance&gt; optInsurance = ...;optInsurance.filter(ins -&gt; &quot;CambridgeInsurance&quot;.equals(ins.getName())) .ifPresent(x -&gt; System.out.println(&quot;ok&quot;)); 如果Optional对象包含的值为空，它不做任何操作；反之，它对Optional对象包含的值添加谓词操作，如果该操作的结果为true，它不做任何改变，直接返回该Optional对象，否则就将该值过滤掉，将Optional的值置为空。 Optional类的方法 方法名 描述 empty 返回一个空的 Optional 实例 filter 如果值存在并且满足提供的谓词，就返回包含该值的 Optional 对象；否则返回一个空的 Optional 对象 flatMap 如果值存在，就对该值执行提供的mapping映射函数调用，返回一个 Optional 类型的值，否则就返回一个空的 Optional 对象 get 如果该值存在，将该值用 Optional 封装返回，否则抛出一个 NoSuchElementException 异常 ifPresent 如果值存在，就执行使用该值的方法调用，否则什么也不做 isPresent 如果值存在就返回 true，否则返回 false map 如果值存在，就对该值执行提供的 mapping映射函数调用 of 将指定值用 Optional 封装之后返回，如果该值为 null，则抛出一个 NullPointerException 异常 ofNullable 将指定值用 Optional 封装之后返回，如果该值为 null，则返回一个空的 Optional 对象 orElse 如果有值则将其返回，否则返回一个默认值 orElseGet 如果有值则将其返回，否则返回一个由指定的 Supplier 接口生成的值 orElseThrow 如果有值则将其返回，否则抛出一个由指定的 Supplier 接口生成的异常 基础类型的Optional对象，以及为什么应该避免使用它们与Stream对象一样，Optional也提供了类似的基础类型：OptionalInt、OptionalLong以及OptionalDouble。 如果Stream对象包含了大量元素，出于性能的考量， 使用基础类型是不错的选择，但对于Optional对象而言，这个理由就不成立了，因为Optional对象多只包含一个值。 不推荐大家使用基础类型的Optional对象，因为基础类型的Optional不支持map、flatMap和filter等方法。而这些却是Optional类最有用的方法。","link":"/2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(2)/"},{"title":"“煮熟的鸭子也会飞？”- 使用策略模式让你的“鸭子”飞起来","text":"模拟鸭子的问题问题描述：用代码模拟现实中的鸭子，鸭子有很多种类，会发出各种叫声，有的会游泳。 传统设计方案传统方案：使用标准的面向对象设计。设计一个Duck超类，让不同种类的鸭子继承该超类。 传统方案的类图设计如下： 代码示例如下： Duck超类： 12345678910111213141516171819202122232425262728293031323334353637383940package cn.org.lilu.strategy.traditional;/** * @Auther: Java成魔之路 * @Date: 2019/9/15 * @Description: 传统鸭子问题 * * 1. 其它鸭子都继承了Duck类，所以fly方法让所有的子类鸭子都会飞，但并不是所有鸭子都会飞。 * 2. 实际上这是继承带来的问题，对父类的局部改动，会影响所有子类。称为溢出效应。 * 3. 为了解决继承带来的问题，我们可以在子类中重写对应的方法来解决。 * 4. 但是如果有一个玩具鸭类，它需要重写父类所有的方法，这样做的代价有点大。 */public abstract class Duck { /** * 显示鸭子信息的方法 */ public abstract void display(); /** * 鸭子叫的方法 */ public void quack() { System.out.println(&quot;鸭子嘎嘎叫&quot;); } /** * 鸭子游泳的方法 */ public void swim() { System.out.println(&quot;鸭子会游泳&quot;); } /** * 鸭子飞翔的方法 */ public void fly() { System.out.println(&quot;鸭子会飞翔&quot;); }} 野鸭WildDuck类： 12345678910111213package cn.org.lilu.strategy.traditional;/** * @Auther: Java成魔之路 * @Date: 2019/9/15 * @Description: 野鸭：嘎嘎叫、会游泳和飞翔 */public class WildDuck extends Duck { @Override public void display() { System.out.println(&quot;这是一只野鸭&quot;); }} 北京鸭PekingDuck类： 123456789101112131415161718package cn.org.lilu.strategy.traditional;/** * @Auther: Java成魔之路 * @Date: 2019/9/15 * @Description: 北京鸭：不会飞翔 */public class PekingDuck extends Duck { @Override public void display() { System.out.println(&quot;这是一只北京鸭&quot;); } @Override public void fly() { System.out.println(&quot;北京鸭不会飞翔&quot;); }} 玩具鸭ToyDuck类： 12345678910111213141516171819202122232425262728package cn.org.lilu.strategy.traditional;/** * @Auther: Java成魔之路 * @Date: 2019/9/15 * @Description: 玩具鸭：不会嘎嘎叫、不会游泳和飞翔。 */public class ToyDuck extends Duck { @Override public void display() { System.out.println(&quot;这是一只玩具鸭&quot;); } @Override public void quack() { System.out.println(&quot;玩具鸭不能叫&quot;); } @Override public void swim() { System.out.println(&quot;玩具鸭不会游泳&quot;); } @Override public void fly() { System.out.println(&quot;玩具鸭不会飞翔&quot;); }} 超类Duck中定义了3个实现方法，一个抽象方法。 子类野鸭WildDuck类会“嘎嘎叫”、“游泳”和“飞翔”。所以野鸭类只需实现抽象方法display即可。 子类北京鸭PekingDuck类不会飞翔，除了实现抽象方法之外还需重写父类的fly方法。 子类玩具鸭ToyDuck类不会叫、不会游泳也不会飞翔。所以玩具鸭类除了实现抽象方法，还要重写父类的三个方法。 这种继承的设计思路似乎没有任何问题。但事实上子类重写父类方法的代价是很高的，一旦出现一个新品种的鸭子，就要去继承Duck类，子类默认就有了父类定义好的行为，例如“嘎嘎叫”、“游泳”和“飞翔”。如果子类不满足这些行为就要去重写父类中对应的方法。同时，一旦对父类进行某些局部改动，所有子类都会受到影响。 我们知道Duck类内的fly()和quack()会随着鸭子的不同而改变。事实上每次继承都是在改动这两个方法。 不妨使用策略模式来改造Duck类。 策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 策略模式中有以下三条设计原则： 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 针对接口编程，而不是针对实现编程。 多用组合，少用继承。 分离行为 — 让“煮熟的鸭子”飞起来是时候将行为从Duck类中分离出来了。将鸭子的行为封装到新的类中，该类专门提供某行为的实现。这样，Duck类就不再需要知道行为的具体实现。 那么如何设计实现“飞翔”和“嘎嘎叫”的行为的类呢？我们希望“煮熟的鸭子飞起来”，鸭子需要经历从生到熟这个过程，我们要做的是在Duck类中增加设定行为的方法，这样就能在“运行时期”动态改变鸭子的行为。 使用了策略模式的类图设计如下： 代码示例如下： “飞翔”行为接口FlyBehavior： 12345678910111213package cn.org.lilu.strategy;/** * @Auther: Java成魔之路 * @Date: 2019/9/12 * @Description: 飞翔行为接口 */public interface FlyBehavior { /** * 飞翔的方法 */ void fly();} 随风飞翔的行为FlyWithWings： 123456789101112131415package cn.org.lilu.strategy.impl;import cn.org.lilu.strategy.FlyBehavior;/** * @Auther: Java成魔之路 * @Date: 2019/9/12 * @Description: 可以飞的行为 */public class FlyWithWings implements FlyBehavior { @Override public void fly() { System.out.println(&quot;fly with wings&quot;); }} 不能飞的行为FlyNoWay： 123456789101112131415package cn.org.lilu.strategy.impl;import cn.org.lilu.strategy.FlyBehavior;/** * @Auther: Java成魔之路 * @Date: 2019/9/12 * @Description: 不能飞的行为 */public class FlyNoWay implements FlyBehavior { @Override public void fly() { System.out.println(&quot;can't fly&quot;); }} 利用火箭动力飞翔的行为FlyRocketPowered： 123456789101112131415package cn.org.lilu.strategy.impl;import cn.org.lilu.strategy.FlyBehavior;/** * @Auther: Java成魔之路 * @Date: 2019/9/12 * @Description: 利用火箭动力的飞翔行为 */public class FlyRocketPowered implements FlyBehavior { @Override public void fly() { System.out.println(&quot;fly with rocket&quot;); }} “叫”的行为接口QuackBehavior： 12345678910111213package cn.org.lilu.strategy;/** * @Auther: Java成魔之路 * @Date: 2019/9/12 * @Description: 鸭子叫行为接口 */public interface QuackBehavior { /** * 鸭子叫的方法 */ void quack();} 嘎嘎叫的行为Quack： 123456789101112131415package cn.org.lilu.strategy.impl;import cn.org.lilu.strategy.QuackBehavior;/** * @Auther: Java成魔之路 * @Date: 2019/9/12 * @Description: 嘎嘎叫的行为 */public class Quack implements QuackBehavior { @Override public void quack() { System.out.println(&quot;Quack 嘎嘎叫&quot;); }} 吱吱叫的行为Squeak： 123456789101112131415package cn.org.lilu.strategy.impl;import cn.org.lilu.strategy.QuackBehavior;/** * @Auther: Java成魔之路 * @Date: 2019/9/12 * @Description: 吱吱叫的行为 */public class Squeak implements QuackBehavior { @Override public void quack() { System.out.println(&quot;Squeak 吱吱叫&quot;); }} 不会叫的行为MuteQuack： 123456789101112131415package cn.org.lilu.strategy.impl;import cn.org.lilu.strategy.QuackBehavior;/** * @Auther: Java成魔之路 * @Date: 2019/9/12 * @Description: 不会叫的行为 */public class MuteQuack implements QuackBehavior { @Override public void quack() { System.out.println(&quot;Silence 不会叫&quot;); }} 分离行为后的Duck类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package cn.org.lilu.strategy;/** * @Auther: Java成魔之路 * @Date: 2019/9/12 * @Description: 使用策略模式的鸭子类 */public abstract class Duck { /** * 飞翔的行为 */ FlyBehavior flyBehavior; /** * 叫的行为 */ QuackBehavior quackBehavior; /** * 设置飞行行为 * @param flyBehavior 飞行行为 */ public void setFlyBehavior(FlyBehavior flyBehavior) { this.flyBehavior = flyBehavior; } /** * 设置叫的行为 * @param quackBehavior 叫行为 */ public void setQuackBehavior(QuackBehavior quackBehavior) { this.quackBehavior = quackBehavior; } /** * 使鸭子飞 */ public void performFly() { if (flyBehavior != null) { flyBehavior.fly(); } } /** * 使鸭子叫 */ public void performQuack() { if (quackBehavior != null) { quackBehavior.quack(); } } /** * 鸭子游泳的方法 */ public void swim() { System.out.println(&quot;鸭子会游泳&quot;); } /** * 显示鸭子信息的方法 */ public abstract void display();} 野鸭WildDuck类： 123456789101112131415161718192021222324package cn.org.lilu.strategy;import cn.org.lilu.strategy.impl.FlyWithWings;import cn.org.lilu.strategy.impl.Quack;/** * @Auther: Java成魔之路 * @Date: 2019/9/15 * @Description: 野鸭：具有可以飞的行为和嘎嘎叫的行为。 */public class WildDuck extends Duck { public WildDuck() { // 随风飞翔行为 flyBehavior = new FlyWithWings(); // 嘎嘎叫行为 quackBehavior = new Quack(); } @Override public void display() { System.out.println(&quot;这是一只使用策略模式的野鸭&quot;); }} 北京鸭PekingDuck类： 123456789101112131415161718192021222324package cn.org.lilu.strategy;import cn.org.lilu.strategy.impl.FlyNoWay;import cn.org.lilu.strategy.impl.Squeak;/** * @Auther: Java成魔之路 * @Date: 2019/9/15 * @Description: 北京鸭：不能飞翔，吱吱叫 */public class PekingDuck extends Duck { public PekingDuck() { // 不能飞的行为 flyBehavior = new FlyNoWay(); // 吱吱叫的行为 quackBehavior = new Squeak(); } @Override public void display() { System.out.println(&quot;这是一只使用策略模式的北京鸭&quot;); }} 玩具鸭ToyDuck类： 123456789101112131415161718192021222324package cn.org.lilu.strategy;import cn.org.lilu.strategy.impl.FlyNoWay;import cn.org.lilu.strategy.impl.MuteQuack;/** * @Auther: Java成魔之路 * @Date: 2019/9/15 * @Description: 玩具鸭：不会飞也不会叫 */public class ToyDuck extends Duck { public ToyDuck() { // 不会飞的行为 flyBehavior = new FlyNoWay(); // 不会叫的行为 quackBehavior = new MuteQuack(); } @Override public void display() { System.out.println(&quot;这是一只使用策略模式的玩具鸭&quot;); }} 一切都准备就绪！让我们来见证“煮熟的鸭子”的飞翔吧！ 1234567891011121314151617181920212223242526package cn.org.lilu.strategy;import cn.org.lilu.strategy.impl.FlyRocketPowered;/** * @Auther: Java成魔之路 * @Date: 2019/9/12 * @Description: for test */public class TestStrategy { public static void main(String[] args) { // 生产一只北京鸭 Duck duck = new PekingDuck(); // 让鸭子飞 duck.performFly(); // 让鸭子叫 duck.performQuack(); // 生产一只玩具鸭 Duck toyDuck = new ToyDuck(); // 让鸭子飞：发现不能飞 toyDuck.performFly(); // 动态改变行为：让“煮熟的鸭子”飞起来 toyDuck.setFlyBehavior(new FlyRocketPowered()); toyDuck.performFly(); }} 结果： 1234can't flySqueak 吱吱叫can't flyfly with rocket 不管怎样，我们的玩具鸭飞起来了，这里玩具鸭和“煮熟的鸭子”性质上是一样的。 现在我们的Duck类不再担心出现新的鸭子种类了。一旦有一个不同行为的新种类鸭，只需要写一个新的行为接口的实现。而不需要对Duck类进行修改。这体现了“对修改关闭，对扩展开放”原则，客户端增加行为不用修改原有代码，只要添加一种策略即可，避免了使用多重转移语句(if-else…if-else)。同时策略模式的缺点也由此暴露，每添加一个策略就会产生一个新的类，当策略过多时，类的数量会随之过多。但这至少比使用继承时重写父类方法要好的多。","link":"/2019/12/12/design-patterns/gof/behavior/strategy/"},{"title":"分库分表中间件之ShardingSphere-入门案例","text":"ShardingSphere的前尘往事ShardingSphere的前身是Sharding-JDBC，起源于当当网内部应用框架，于2016年初开源。 2017年，Sharding-JDBC进入2.x阶段，核心功能是数据库治理。 2018年春节前夕，Sharding-JDBC团队于京东数科重新组建，并将其定位为面向云原生的数据库中间件，正式更名为ShardingSphere。Sharding-JDBC进入了3.x时代，功能重心转向了Sharding-proxy及分布式事务上。 美国时间2018年11月10日，分布式数据库中间件生态圈 ShardingSphere正式进入Apache基金会孵化器。 预祝ShardingSphere项目早日成功毕业。 Apache ShardingSphere简介Apache ShardingSphere (Incubator) 是一套开源的分布式数据库中间件解决方案组成的生态圈，它由Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar（规划中）这3款相互独立，却又能够混合部署配合使用的产品组成。它们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如Java同构、异构语言、云原生等各种多样化的应用场景。 Apache官方发布从4.0.0版本开始。 Apache ShardingSphere官方文档 Sharding-JDBC简介定位为轻量级Java框架，在Java的JDBC层提供的额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。 Sharding-JDBC快速入门我们以一库两表的案例来快速入门。 建立数据表这里我们以简单的订单表为例，作为入门学习使用。 首先建立一库两表的数据库结构。数据库名为sharding_jdbc_db，建立t_order_1和t_order_2两张表。 建表sql语句如下： 123456789101112131415161718-- 分表结构DROP TABLE IF EXISTS t_order_1;DROP TABLE IF EXISTS t_order_2;CREATE TABLE `sharding_jdbc_db`.`t_order_1` ( `order_id` varchar(32) NOT NULL COMMENT '主键：订单id', `price` decimal(10, 2) NOT NULL COMMENT '订单金额', `user_id` varchar(32) NOT NULL COMMENT '用户id', `status` varchar(16) NOT NULL COMMENT '订单状态', PRIMARY KEY (`order_id`)) ENGINE = InnoDB CHARACTER SET = utf8;CREATE TABLE `sharding_jdbc_db`.`t_order_2` ( `order_id` varchar(32) NOT NULL COMMENT '主键：订单id', `price` decimal(10, 2) NOT NULL COMMENT '订单金额', `user_id` varchar(32) NOT NULL COMMENT '用户id', `status` varchar(16) NOT NULL COMMENT '订单状态', PRIMARY KEY (`order_id`)) ENGINE = InnoDB CHARACTER SET = utf8; 创建sharding-jdbc-simple项目使用IDEA创建一个maven的空模板项目，项目名为sharding-jdbc-simple。 在pom.xml文件中需添加的sharding-jdbc-spring-boot-starter依赖如下： 123456&lt;!-- apache sharding-jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;4.0.0-RC1&lt;/version&gt;&lt;/dependency&gt; 由于我的项目使用了自己定义的统一依赖管理，所以没有指定各个jar包的版本号。 读者可以参考 sunchaser-boot-dependencies 进行实现，或者单独指定对应版本号。 完整的pom.xml内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;中间件&lt;/artifactId&gt; &lt;groupId&gt;com.sunchaser&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;sharding-jdbc-simple&lt;/artifactId&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.sunchaser.boot&lt;/groupId&gt; &lt;artifactId&gt;sunchaser-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- sharding-jdbc依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- test依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- web依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- druid连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 编写配置文件springboot项目可使用properties配置或yaml配置。二选一即可。 基本配置配置tomcat端口号、应用名和允许重复定义的bean进行覆盖。 properties配置： 1234server.port=520spring.application.name=sharding-jdbc-simple-demo# 重复的bean定义进行覆盖spring.main.allow-bean-definition-overriding=true yaml配置： 12345678server: port: 520spring: application: name: sharding-jdbc-simple-demo main: # 重复的bean会进行覆盖 allow-bean-definition-overriding: true 配置mybatis主要配置xml文件映射路径和下划线自动转驼峰。 properties配置： 123456789########################################################################## mybatis配置########################################################################### xml映射文件路径mybatis.mapper-locations=classpath:mapper/**/*.xml# 下划线自动转驼峰mybatis.configuration.map-underscore-to-camel-case=true yaml配置： 123456mybatis: # xml映射文件路径 mapper-locations: classpath:mapper/**/*.xml configuration: # 自动转驼峰 map-underscore-to-camel-case: true 配置数据源此入门案例是一库两表，只有一个数据源需要配置。 properties配置： 12345678910111213########################################################################## 数据源配置########################################################################### 数据源名称，多数据源以逗号分隔spring.shardingsphere.datasource.names=ds1# 数据源ds1详情配置spring.shardingsphere.datasource.ds1.type=com.alibaba.druid.pool.DruidDataSourcespring.shardingsphere.datasource.ds1.driver-class-name=com.mysql.cj.jdbc.Driverspring.shardingsphere.datasource.ds1.url=jdbc:mysql://127.0.0.1:3306/sharding_jdbc_db?useUnicode=true&amp;serverTimezone=Asia/Shanghaispring.shardingsphere.datasource.ds1.username=rootspring.shardingsphere.datasource.ds1.password=ll970722 yaml配置： 12345678910111213spring: # 数据源配置 shardingsphere: datasource: # 数据源名称，多数据源以逗号分隔 names: ds1 # 数据源ds1详情配置 ds1: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/sharding_jdbc_db?useUnicode=true&amp;serverTimezone=Asia/Shanghai username: root password: ll970722 配置分片规则使用默认的inline表达式配置分片策略，分片策略包含分片键和分片算法，需符合groovy语法。 properties配置： 1234567891011121314# 分片规则配置# 真实数据节点，由数据源名 + 表名组成，以小数点分隔spring.shardingsphere.sharding.tables.t_order.actual-data-nodes=ds1.t_order_$-&gt;{1..2}# 主键列名称，缺省表示不使用自增主键生成器spring.shardingsphere.sharding.tables.t_order.key-generator.column=order_id# 自增列值生成器类型，缺省表示使用默认自增列值生成器。# 可使用自定义的列值生成器或选择内置类型：SNOWFLAKE/UUID/LEAF_SEGMENT# 这里使用SNOWFLAKE雪花算法spring.shardingsphere.sharding.tables.t_order.key-generator.type=SNOWFLAKE# 分片策略（分片键和分片算法）# 分片键spring.shardingsphere.sharding.tables.t_order.table-strategy.inline.sharding-column=order_id# 分片算法 生成的ID为奇数，插入到t_order_2中，偶数则插入到t_order_1中spring.shardingsphere.sharding.tables.t_order.table-strategy.inline.algorithm-expression=t_order_$-&gt;{order_id % 2 + 1} yaml配置： 12345678910111213141516171819spring: shardingsphere: # sharding-jdbc分片规则配置 sharding: tables: t_order: # 数据节点 actual-data-nodes: ds1.t_order_$-&gt;{1..2} # 主键列和主键生成策略：雪花算法 key-generator: column: order_id type: SNOWFLAKE # 分片策略 table-strategy: inline: # 分片键 sharding-column: order_id # 分片算法：生成的ID为奇数，插入到t_order_2中，偶数则插入到t_order_1中 algorithm-expression: t_order_$-&gt;{order_id % 2 + 1} 配置日志相关配置打印执行的真实sql与日志级别。 properties配置： 1234567# 打印sharding-jdbc的真实执行sql日志spring.shardingsphere.props.sql.show=true# 日志级别配置logging.level.root=infologging.level.org.springframework.web=infologging.level.com.sunchaser.shardingjdbc=debuglogging.level.druid.sql=debug yaml配置： 12345678910111213141516171819spring: shardingsphere: props: sql: # 打印sharding-jdbc的真实执行sql日志 show: true # 日志级别logging: level: root: info org: springframework: web: info com: sunchaser: shardingjdbc: debug druid: sql: debug 至此，配置部分完成，开始编写后端代码。 后端测试代码编写项目包结构如下： 1234567891011121314151617└─src ├─main │ ├─java │ │ └─com │ │ └─sunchaser │ │ └─shardingjdbc ------ 存放启动类 │ │ ├─entity -------- 存放实体类 │ │ └─mapper -------- 存放mapper接口 │ └─resources │ ├─db ----------------------- 存放建表语句 │ └─mapper ------------------- 存放xml映射文件 └─test └─java └─com └─sunchaser └─shardingjdbc └─mapper ------ 存放单元测试类 入门案例主要是使用Sharding-JDBC进行新增和查询，mybatis的mapper接口和xml映射文件编写方式保持不变。 编写启动类1234567891011121314151617181920package com.sunchaser.shardingjdbc;import org.springframework.boot.WebApplicationType;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.builder.SpringApplicationBuilder;/** * @author sunchaser * @date 2019/11/26 * @description * @since 1.0 */@SpringBootApplicationpublic class ShardingJdbcSimpleApplication { public static void main(String[] args) { new SpringApplicationBuilder(ShardingJdbcSimpleApplication.class) .web(WebApplicationType.SERVLET) .run(args); }} 编写订单实体类使用lombok工具包的@Data和@Builder注解生成getter、setter和建造者模式代码。 12345678910111213141516171819202122232425262728293031323334353637package com.sunchaser.shardingjdbc.entity;import lombok.Builder;import lombok.Data;import java.math.BigDecimal;/** * @author sunchaser * @date 2019/11/29 * @description * @since 1.0 */@Data@Builderpublic class OrderEntity { /** * 订单id：雪花算法生成的分布式唯一ID */ private Long orderId; /** * 订单价格 */ private BigDecimal price; /** * 用户id */ private String userId; /** * 订单状态 */ private String status;} 编写mapper接口 插入订单（注解实现） 根据订单ID的集合查询订单信息集合（注解实现） 根据订单ID的集合查询订单信息集合（XML实现） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.sunchaser.shardingjdbc.mapper;import com.sunchaser.shardingjdbc.entity.OrderEntity;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Param;import org.apache.ibatis.annotations.Select;import java.util.List;/** * @author sunchaser * @date 2019/11/28 * @description * @since 1.0 */@Mapperpublic interface OrderMapper { /** * 插入 * @param orderEntity 订单实体 * @return 影响记录行数 */ @Insert(&quot;insert into t_order(price,user_id,status) values(#{price},#{userId},#{status})&quot;) Integer insert(OrderEntity orderEntity); /** * 注解实现 * 根据订单id集合查询订单集合 * @param orderIds 订单ID集合 * @return 订单集合 */ @Select(&quot; &lt;script&gt; &quot; + &quot; select * from t_order t where t.order_id in &quot; + &quot; &lt;foreach collection='orderIds' open='(' separator=',' close=')' item='orderId'&gt; &quot; + &quot; #{orderId} &quot; + &quot; &lt;/foreach&gt; &quot; + &quot; &lt;/script&gt; &quot;) List&lt;OrderEntity&gt; selectByAnnotation(@Param(&quot;orderIds&quot;) List&lt;Long&gt; orderIds); /** * xml 实现 * @param orderIds * @return */ List&lt;OrderEntity&gt; selectByXml(@Param(&quot;orderIds&quot;) List&lt;Long&gt; orderIds);} OrderMapper的selectByXml方法对应的XML配置如下： 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.sunchaser.shardingjdbc.mapper.OrderMapper&quot;&gt; &lt;select id=&quot;selectByXml&quot; resultType=&quot;com.sunchaser.shardingjdbc.entity.OrderEntity&quot;&gt; select * from t_order where order_id in &lt;foreach collection='orderIds' item='orderId' open='(' separator=',' close=')'&gt; #{orderId} &lt;/foreach&gt; &lt;/select&gt;&lt;/mapper&gt; 编写单元测试代码首先循环调用OrderMapper的insert方法插入20条订单数据，然后分别选择同一个订单表的两个订单orderId和选择不同订单表的两个orderId进行in查询。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.sunchaser.shardingjdbc.mapper;import com.google.common.collect.Lists;import com.sunchaser.shardingjdbc.entity.OrderEntity;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import javax.annotation.Resource;import java.math.BigDecimal;import java.util.List;/** * @author sunchaser * @date 2019/11/28 * @description * @since 1.0 */@SpringBootTest@RunWith(SpringRunner.class)public class OrderMapperTest { @Resource private OrderMapper orderMapper; @Test public void insert() { for (int i = 0; i &lt; 20; i++) { OrderEntity orderEntity = OrderEntity.builder() .price(new BigDecimal(&quot;1.11&quot;)) .userId(&quot;2019xxxxxxxx&quot;) .status(&quot;SUCCESS&quot;) .build(); Integer success = orderMapper.insert(orderEntity); System.out.println(success); } } @Test public void selectByAnnotation() { List&lt;Long&gt; orderIds = Lists.newArrayList(406907714078244865L,407114454203891712L); List&lt;OrderEntity&gt; orderEntities = orderMapper.selectByAnnotation(orderIds); System.out.println(orderEntities); } @Test public void selectByXml() { List&lt;Long&gt; orderIds = Lists.newArrayList(406907714078244865L,407114454203891712L); List&lt;OrderEntity&gt; orderEntities = orderMapper.selectByXml(orderIds); System.out.println(orderEntities); }} 由于前面配置了sql日志打印，我们可在控制台看到执行的逻辑SQL和真实SQL。 以查询方法selectByAnnotation为例，执行日志如下： 1234567892019-12-12 11:05:36.399 DEBUG 17328 --- [ main] c.s.s.m.OrderMapper.selectByAnnotation : ==&gt; Preparing: select * from t_order t where t.order_id in ( ? , ? ) 2019-12-12 11:05:36.459 DEBUG 17328 --- [ main] c.s.s.m.OrderMapper.selectByAnnotation : ==&gt; Parameters: 406907714078244865(Long), 407114454203891712(Long)2019-12-12 11:05:37.778 INFO 17328 --- [ main] ShardingSphere-SQL : Rule Type: sharding2019-12-12 11:05:37.783 INFO 17328 --- [ main] ShardingSphere-SQL : Logic SQL: select * from t_order t where t.order_id in ( ? , ? )2019-12-12 11:05:37.784 INFO 17328 --- [ main] ShardingSphere-SQL : SQLStatement: SelectStatement(super=DQLStatement(super=AbstractSQLStatement(type=DQL, tables=Tables(tables=[Table(name=t_order, alias=Optional.of(t))]), routeConditions=Conditions(orCondition=OrCondition(andConditions=[AndCondition(conditions=[Condition(column=Column(name=order_id, tableName=t_order), operator=IN, compareOperator=null, positionValueMap={}, positionIndexMap={0=0, 1=1})])])), encryptConditions=Conditions(orCondition=OrCondition(andConditions=[])), sqlTokens=[TableToken(tableName=t_order, quoteCharacter=NONE, schemaNameLength=0)], parametersIndex=2, logicSQL=select * from t_order t where t.order_id in ( ? , ? ))), containStar=true, firstSelectItemStartIndex=7, selectListStopIndex=7, groupByLastIndex=0, items=[StarSelectItem(owner=Optional.absent())], groupByItems=[], orderByItems=[], limit=null, subqueryStatement=null, subqueryStatements=[], subqueryConditions=[])2019-12-12 11:05:37.786 INFO 17328 --- [ main] ShardingSphere-SQL : Actual SQL: ds1 ::: select * from t_order_1 t where t.order_id in ( ? , ? ) ::: [406907714078244865, 407114454203891712]2019-12-12 11:05:37.786 INFO 17328 --- [ main] ShardingSphere-SQL : Actual SQL: ds1 ::: select * from t_order_2 t where t.order_id in ( ? , ? ) ::: [406907714078244865, 407114454203891712]2019-12-12 11:05:38.062 DEBUG 17328 --- [ main] c.s.s.m.OrderMapper.selectByAnnotation : &lt;== Total: 2[OrderEntity(orderId=407114454203891712, price=1.11, userId=2019xxxxxxxx, status=SUCCESS), OrderEntity(orderId=406907714078244865, price=1.11, userId=2019xxxxxxxxxxxxxxx, status=SUCCESS)] 可看到执行的Logic SQL为： 1select * from t_order t where t.order_id in ( ? , ? ) Sharding-JDBC的路由引擎根据解析上下文匹配数据库和表的分片策略，路由到具体的库和表。再经过改写引擎，将逻辑SQL改写为真正执行的SQL。 从日志中可看到改写后的Actual SQL为： 12select * from t_order_1 t where t.order_id in ( ? , ? ) ::: [406907714078244865, 407114454203891712]select * from t_order_2 t where t.order_id in ( ? , ? ) ::: [406907714078244865, 407114454203891712] 结果归并，真实的SQL执行后会返回多个结果集，归并引擎从各个数据节点拿到结果集后组合成一个结果集并返回给客户端。 至此，入门案例就演示结束。源码地址：传送门 下一篇文章将对Sharding-JDBC中的一些核心概念进行具体的解释。 小结这篇文章主要是对Apache ShardingSphere 4.x与Spring Boot 2.1.x进行整合，使用了内置的SNOWFLAKE雪花算法生成分布式全局唯一ID和使用默认的inline表达式配置分片策略，完成了最简单的一库两表的分库分表，并对新增和查询操作进行了测试。","link":"/2019/12/12/middleware/sharding-sphere/sharding-jdbc-introduction/"},{"title":"《Java 8实战》读书笔记系列——第二部分：函数式数据处理","text":"第四章：引入流流的定义从支持数据处理操作的源生成的元素序列。 元素序列就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。 因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元素（如ArrayList 与 LinkedList）。 但流的目的在于表达计算，比如前面见到的filter、sorted和map。 集合讲的是数据，流讲的是计算。 源流会使用一个提供数据的源，如集合、数组或输入/输出资源。 请注意，从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。 数据处理操作流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作， 如filter、map、reduce、find、match、sort等。流操作可以顺序执行，也可并行执行。 流操作的特点1. 流水线很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。 这让之后章节中的一些优化成为可能，如延迟和短路。 流水线的操作可以看作对数据源进行数据库式（链式）查询。 2. 内部迭代与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的（内部迭代）。 3. 流只能被消费一次终止操作只能有一次，重复消费会抛出java.lang.IllegalStateException异常。 4. 对流的操作分为两类：中间操作和终止操作 中间操作总是会惰性执行：执行一个中间操作不会在原流上做任何处理，而是创建一个标记了该操作的新流返回。 终止操作才会进行真实的计算：计算发生时会把所有中间操作积攒的操作以Pipeline的方式执行，这样可以减少迭代次数，计算完成后流即失效。 集合与流的不同点： 无存储：Stream不是一种数据结构，它只是某种数据源的一个视图。数据源可以是一个数组、Java容器或I/O资源等。 为函数式编程而生：对Stream的任何修改都不会修改背后的数据源，比如对一个流执行filter过滤操作并不会删除被过滤的元素，而是会产生一个新的不包含被过滤元素的新流。 惰性执行：对流的中间操作并不会立即执行，只有等一个终止操作来临时才会一次性全部执行。 可消费性：一个流只能被消费一次，一旦产生终止操作，流即被消费。 第五章：使用流1. 筛选和切片选择流中的元素：用谓词筛选，筛选出各不相同的元素，忽略流 中的头几个元素，或将流截短至指定长度。 1.1 用谓词筛选Streams接口支持filter方法。该操作会接受一个谓词（一个返回 boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流。 1.2 筛选各异的元素流支持一个叫作distinct的方法，它会返回一个元素各异（根据流所生成元素的 hashCode和equals方法实现）的流。 1.3 截短流流支持limit(n)方法，该方法会返回一个不超过给定长度的流。 所需的长度作为参数传递给limit。如果流是有序的，则多会返回前n个元素。 1.4 跳过元素流还支持skip(n)方法，返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一个空流。 请注意，limit(n)和skip(n)是互补的。 2. 映射一个非常常见的数据处理套路就是从某些对象中选择信息。 比如在SQL里，你可以从表中选择一列。Stream API也通过map和flatMap方法提供了类似的工具。 2.1 对流中每一个元素应用函数流支持map方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上， 并将其映射成一个新的元素（使用映射一词，是因为它和转换类似，但其中的细微差别在于它是“创建一个新版本”而不是去“修改”）。 2.2 流的扁平化流支持flatMap方法，将各个单独的流合并起来，扁平化成一个流。 flatMap方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。 3. 查找和匹配另一个常见的数据处理套路是看看数据集中的某些元素是否匹配一个给定的属性。 Stream API通过anyMatch、allMatch、noneMatch、findAny和findFirst方法提供了这样的工具。 3.1 检查谓词是否至少匹配一个元素anyMatch()：流中是否有一个元素能匹配给定的谓词。 返回一个boolean，因此是一个终端操作。 3.2 检查谓词是否匹配所有元素allMatch()：流中的元素是否都能匹配给定的谓词。是一个终端操作。 3.3 检查谓词是否不匹配所有元素noneMatch()：流中没有任何元素与给定的谓词匹配。 3.4 查找元素findAny()：将返回当前流中的任意元素。如果流中没有元素，返回值可能为空，于是Java 8引入了Optional&lt;T&gt;类。 Optional简介Optional&lt;T&gt;类（java.util.Optional）是一个容器类，代表一个值存在或不存在。 方法简介： 1、isPresent()：将在Optional包含值的时候返回true, 否则返回false。 2、ifPresent(Consumer&lt;T&gt; block)：会在值存在的时候执行给定的代码块。 3、T get()：会在值存在时返回值，否则抛出一个NoSuchElement异常。 4、T orElse(T other)：会在值存在时返回值，否则返回一个默认值。 3.5 查找第一个元素findFirst()：返回流中的第一个元素。同样地，如果流中没有元素，返回值可能为空，返回类型为Optional&lt;T&gt;类。 有些流有一个出现顺序（encounter order）来指定流中项目出现的逻辑顺序（比如由List或排序好的数据列生成的流）。对于这种流，可能想要找到第一个元素。 4. 归约reduce()：将流中所有元素反复结合起来，得到一个值。 reduce()方法有两个重载的方法： 1234567891011/** * @param identity 归约的初始值 * @param accumulator 归约操作 */T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);/** * @param accumulator 归约操作 * @return Optional&lt;T&gt;对象，由于没有初始值，流中元素可能为空，故返回值会存在空的情况。 */Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator); map和reduce的连接通常称为map-reduce模式，因Google用它来进行网络搜索而出名，因为它很容易并行化。 5. 数值流流中的元素是数值型的，例如int，long，double。尽管可以把这些数值型元素放入流中，但实际上是暗含了装箱操作，将数值型元素转换成对应的包装类型，从而形成对象流。 Stream API提供了原始类型流特化，专门支持处理数值流的方法。减去装箱操作的损耗。 5.1 原始类型流特化Java 8引入了三个原始类型特化流接口：IntStream、DoubleStream和LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的装箱成本。 每个接口都带来了进行常用数值归约的新方法，比如对数值流求和的sum，找到大元素的max。此外还有在必要时再把它们转换回对象流的方法。 5.1.1 映射到数值流将流转换为特化版本的常用方法是mapToInt、mapToDouble和mapToLong。这些方法map方法的工作方式一样，只是它们返回的是一个特化流，而不是Stream&lt;T&gt;。 5.1.2 转换回对象流一旦有了数值流，可能需要将其转换回非特化流。 5.1.3 默认值OptionalInt对于原始类型特化流接口中的max，min，average等方法的返回值。如果流是空的，这些方法的返回值为空，但不能默认为0。因为可能真实计算的结果恰好为0。 可以使用Optional类来解决返回值为空的情况。但Optional&lt;T&gt;只能接收包装类型。传递原始类型会触发自动装箱操作，产生损耗。 Java 8同样引入了Optional原始类型特化版本：OptionalInt、OptionalDouble和OptionalLong，用这些Optional类来解决传递原始类型时自动装箱的问题。 5.2 数值范围和数字打交道时，有一个常用的东西就是数值范围。比如生成1和100之间的所有数字。 Java 8引入了两个可以用于IntStream和LongStream的静态方法，帮助生成这种范围： range和rangeClosed。 12345678910111213/** * range方法表示的范围为：[startInclusive,endExclusive) * @param startInclusive 数值范围开始 * @param endExclusive 数值范围结束（不包含该值） */IntStream range(int startInclusive, int endExclusive);/** * rangeClosed方法表示的范围为：[startInclusive,endExclusive] * @param startInclusive 数值范围开始 * @param endExclusive 数值范围结束（包含该值） */IntStream rangeClosed(int startInclusive, int endInclusive); 这两个方法都是第一个参数接受起始值，第二个参数接受结束值。但range是不包含结束值的，而rangeClosed则包含结束值。 6. 构建流介绍如何从值序列、数组、文件来创建流，甚至由生成函数来创建无限流。 6.1 由值创建流使用静态方法Stream.of(T...values)，通过显式值创建一个流。它可以接受任意数量的参数。 使用静态方法Stream.empty()，创建一个空流。 6.2 由数组创建流使用静态方法Arrays.stream从数组创建一个流。它接受一个数组作为参数。 6.3、由文件生成流Java中用于处理文件等I/O操作的NIO API（非阻塞 I/O）已更新，以便利用Stream API。 java.nio.file.Files中的很多静态方法都会返回一个流。 例如，Files.lines，它会返回一个由指定文件中的各行构成的字符串流。 6.4 由函数生成流：创建无限流Stream API提供了两个静态方法来从函数生成流：Stream.iterate和Stream.generate。 这两个操作可以创建所谓的无限流：不像从固定集合创建的流那样有固定大小的流。 由iterate和generate产生的流会用给定的函数按需创建值，因此可以无穷无尽地计算下去！ 一般来说，应该使用limit(n)来对这种流加以限制，以避免打印无穷多个值。 第六章：用流收集数据1. 汇总Collectors类专门为汇总提供了一个工厂方法：Collectors.summingInt。 1Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? super T&gt; mapper); 它可接受一个把对象映射为求和所需int的函数，并返回一个收集器，该收集器在传递给普通的collect方法后即执行我们需要的汇总操作。 类似的还有Collectors.summingDouble方法和Collectors.summingLong方法，汇总为double和long类型。 12Collector&lt;T, ?, Long&gt; summingLong(ToLongFunction&lt;? super T&gt; mapper);Collector&lt;T, ?, Double&gt; summingDouble(ToDoubleFunction&lt;? super T&gt; mapper); 汇总不仅仅只有求和。 平均数： 123Collector&lt;T, ?, Double&gt; averagingInt(ToIntFunction&lt;? super T&gt; mapper);Collector&lt;T, ?, Double&gt; averagingDouble(ToDoubleFunction&lt;? super T&gt; mapper);Collector&lt;T, ?, Double&gt; averagingLong(ToLongFunction&lt;? super T&gt; mapper); 一次操作取得多个汇总结果： 123Collector&lt;T, ?, IntSummaryStatistics&gt; summarizingInt(ToIntFunction&lt;? super T&gt; mapper);Collector&lt;T, ?, LongSummaryStatistics&gt; summarizingLong(ToLongFunction&lt;? super T&gt; mapper);Collector&lt;T, ?, DoubleSummaryStatistics&gt; summarizingDouble(ToDoubleFunction&lt;? super T&gt; mapper); 可以通过对用getter方法取得汇总结果。 2. 连接字符串joining工厂方法返回的收集器会把对流中每一个对象应用toString方法得到的所有字符串连接成一个字符串。 joining方法有3个重载： 12345678910111213141516/** * 内部使用StringBuilder拼接 */Collector&lt;CharSequence, ?, String&gt; joining();/** * @param delimiter 表示每个字符串连接时的分隔符 */Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter);/** * @param delimiter 分隔符 * @param prefix 字符串前缀 * @param suffix 字符串后缀 */Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,CharSequence prefix,CharSequence suffix); 3. 分组groupingBy：跟数据库中的group by分组操作一样。同时支持多级分组。 groupingBy方法有多个重载： 1234567891011121314151617/** * 内部调用的是带两个参数的groupingBy方法，第二个参数传递的是Collectors.toList()。 * @param classifier 一个Function函数型接口。 */groupingBy(Function&lt;? super T, ? extends K&gt; classifier);/** * 内部调用的是三个参数的groupingBy方法。 * @param classifier 一个Function函数型接口 * @param downstream 一个收集器对象 */groupingBy(Function&lt;? super T, ? extends K&gt; classifier,Collector&lt;? super T, A, D&gt; downstream);/** * 有三个参数，groupingBy分组的具体实现。 */groupingBy(Function&lt;? super T, ? extends K&gt; classifier,Supplier&lt;M&gt; mapFactory,Collector&lt;? super T, A, D&gt; downstream); 可以把第二个groupingBy收集器传递给外层收集器来实现多级分组。 但进一步说，传递给第一个groupingBy的第二个收集器可以是任何类型，而不一定是另一个groupingBy。 收集器返回的结果可能是Optional包装后的对象，对于多级分组来说，第二个收集器对象参数返回的Optional对象可能没什么用。第一层groupingBy已经把为空的情况给排除掉了。 Collectors收集器提供了collectingAndThen方法将收集器进行转换。 123456/** * 返回转换后的另一个收集器 * @param downstream 需要转换的收集器 * @param finisher 转换函数 */Collector&lt;T,A,RR&gt; Collectors.collectingAndThen(Collector&lt;T,A,R&gt; downstream,Function&lt;R,RR&gt; finisher); groupingBy可以联合其它收集器使用，经常使用的是mapping方法。它可以让接受特定类型元素的收集器适应不同类型的对象。 12345/** * @param mapper 一个函数型接口,对流中的元素做映射 * @param downstream 一个收集器，将映射后的元素收集起来 */Collector&lt;T, ?, R&gt; mapping(Function&lt;? super T, ? extends U&gt; mapper,Collector&lt;? super U, A, R&gt; downstream); 4. 分区partitioningBy分区是分组的特殊情况：由一个谓词（返回一个布尔值的函数）作为分类函数，它称分区函数。 分区函数返回一个布尔值，这意味着得到的分组Map的键类型是Boolean，于是它多可以分为两组——true是一组，false是一组。 partitioningBy收集器有两个重载的方法: 1234567891011/** * 内部调用了两个参数的重载方法，第二个参数传递的是一个Collectors.toList()收集器。 * @param predicate 断言型接口 */Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate);/** * @param predicate 断言型接口 * @param downstream 收集器 */Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate,Collector&lt;? super T, A, D&gt; downstream); 分区也可用相同的谓词使用filter筛选来实现。 分区的好处： 保留了分区函数返回true或false的两套流元素列表。 使用filter筛选需要操作两次，一次利用谓词，一次利用谓词的非。 第七章：并行数据处理与性能并行处理数据一定比串行处理快吗？答案是不一定。 假设你现在要进行数字累加的操作，例如计算1至100万之间所有数字的和。 现在有三种方案可供选择。 方案一：原始迭代方式。 1234567public static long iterateSum(long n) { long result = 0; for (int i = 0; i &lt;= n; i++) { result += i; } return result;} 方案二：使用Stream串行流处理。 123456public static long streamSum(long n) { Long result = Stream.iterate(0L, i -&gt; i + 1) .limit(n) .reduce(0L, Long::sum); return result;} 方案三：使用ParallelStream并行流处理。 1234567public static long parallelSum(long n) { Long result = Stream.iterate(0L, i -&gt; i + 1) .limit(n) .parallel() .reduce(0L, Long::sum); return result;} 原始迭代方案中不需要对原始类型的数字进行装箱操作。 串行流方案中利用Stream接口的iterate方法生成0到n的自然数流，默认是串行流，然后归约求和。 并行流方案中利用Stream接口的iterate方法生成0到n的自然数流，使用parallel方法将流转换成并行流，然后归约求和。 测试方法：运行10次，取最短时间。 12345678910111213141516171819202122232425public static long measureSumPerf(Function&lt;Long,Long&gt; adder,long n) { long fastest = Integer.MAX_VALUE; for (int i = 0; i &lt; 10; i++) { long start = System.nanoTime(); long sum = adder.apply(n); long duration = (System.nanoTime() - start) / 1_100_100; if (duration &lt; fastest) { fastest = duration; } } return fastest;}// testpublic static void main(String[] args) { // 原始迭代方式更快，它不需要对原始类型进行装箱/拆箱操作 System.out.println(&quot;iterate sum min time:&quot; + measureSumPerf( StreamPerformanceTest::iterateSum, 100000000)); // iterate生成的是装箱的对象，必须拆箱成数字才能求和。 System.out.println(&quot;stream sum min time:&quot; + measureSumPerf( StreamPerformanceTest::streamSum, 100000000)); // 整个数字在过程开始时并没有准备好，无法有效的把流划分为小块来并行处理。 System.out.println(&quot;parallel stream sum min time:&quot; + measureSumPerf( StreamPerformanceTest::parallelSum, 100000000));} 测试结果： 123原始迭代方案最快：iterate sum min time:11串行流方案第二快：stream sum min time:198并行流方案最慢：parallel stream sum min time:267 可见并行执行并不比串行执行快。但实际上这次试验的很大一部分时间消耗在对原始数据类型进行装箱的操作上。因为Stream接口的iterate方法生成的是包装对象，求和时需要拆箱成数字。同时使用iterate方法在程序开始时并没有把整个数字序列准备好，无法有效的把流划分为小块来并行处理。 接下来使用原始类型特化流来生成数字流。 原始类型特化流串行处理： 1234public static long longStreamSum(long n) { long result = LongStream.rangeClosed(1, n).reduce(0L, Long::sum); return result;} 原始类型特化流并行处理： 1234public static long longParallelSum(long n) { long result = LongStream.rangeClosed(1, n).parallel().reduce(0L, Long::sum); return result;} 测试代码： 12345// LongStream.rangeClosed直接产生原始类型的long数字，没有装箱拆箱的开销。System.out.println(&quot;long stream sum min time:&quot; + measureSumPerf( StreamPerformanceTest::longStreamSum,100000000));// LongStream.rangeClosed在过程开始时就会生成数字范围，很容易拆分为独立的小块进行并行处理。System.out.println(&quot;long parallel stream sum min time:&quot; + measureSumPerf(StreamPerformanceTest::longParallelSum,100000000)); 测试结果： 12原始类型特化流串行处理：long stream sum min time:7原始类型特化流并行处理：long parallel stream sum min time:1 LongStream.rangeClosed直接产生原始类型的long数字，没有装箱拆箱的开销。 LongStream.rangeClosed在过程开始时就会生成数字范围，很容易拆分为独立的小块进行并行处理。 并行流有时候比串行流慢的原因并行流有时候比串行流慢的原因： 没有使用合理的使用数据结构，导致时间浪费在其它非流处理的操作上。 并行流的底层实现是Fork/Join框架。它是基于多线程的，线程之间进行上下文切换需要耗时。同时线程是操作系统进行调度的。线程自己无法控制时间。 Fork/Join框架Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。体现了分治法的思想。Fork的意思是拆分，Join的意思是合并。比如计算1+2+…+10000，可以分割成10个子任务，每个子任务分别对1000个数进行求和， 最终汇总这10个子任务的结果。Fork/Join框架的运行流程图如下： Fork/Join的拆分重点在于任务什么时候足够小或不可分，不可再拆分的任务顺序执行，不同的任务之间并行执行。所有不可拆分的子任务分配到多个任务队列中等待线程去执行，每个队列都有一个单独的线程去执行任务。理想情况下，划分并行任务时，应该让每个任务都用相同的时间完成，让所有的CPU都同样繁忙，充分的利用CPU。但实际中，由于线程是由操作系统根据时间片进行调度的，每个子任务所花的时间可能天差地别。于是会出现一个任务队列的任务全部执行完了，另一个队列中还有很多任务的情况。这个时候CPU的利用率没有最大化。Java 8采用工作窃取算法来解决这一问题。 工作窃取（work-stealing）算法工作窃取算法是指某个线程从其它队列中窃取任务来执行。某个线程，自己队列中的任务执行完了，就去别的还有任务的队列中窃取一个任务来执行。这个时候会存在线程竞争关系，窃取线程和被窃取线程之间同时访问同一个队列。通常使用双端队列来解决。被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。 工作窃取算法的优点：充分利用线程进行并行计算，减少了线程间的竞争。 工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。 Fork/Join框架的设计思路 首先需要一个Fork类去把大任务进行递归Fork拆分，直至拆分成不可再分的小任务。 拆分出来的子任务均匀地分配到n个双端队列中，启动n个线程分别从双端队列中获取任务执行。每个子任务执行完的结果统一放在一个结果队列中，启动一个线程从结果队列中取结果，然后Join合并成最终结果。","link":"/2019/12/12/reading-notes/java8-in-action/Part-II-Functional-Data-Processing/"},{"title":"《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（三）：从一个生产环境的事故到异步编程思想","text":"第十一章：CompletableFuture组合式异步编程在介绍这部分内容之前，先介绍一下由于我和另外一位开发人员的考虑不周造成的一次线上事故场景（考虑企业隐私，屏蔽了一些关键词）。 需求背景卡劵系统的后台管理系统，用于处理用户投诉补偿以及发错券补偿的场景。 需求说明两种情况会使用到这次我们开发的功能。 可能会出现用户投诉未领取到优惠券的情况，这个时候直接给用户补发一张。避免浪费人力去查线上日志找原因。 运营人员操作失误发错劵，需要手动给用户补发劵。 由于功能急需上线，产品经理想尽量简化开发，设计的轻量化一些，不将补发记录入库。每次补发完成页面就显示成功多少个，失败多少个，失败的UIDs是哪些。 业务流程 一个补发劵页面，运营人员首先输入劵ID查询劵信息，包含劵名称和可用库存。 上传需要进行补发的UIDs到后台进行解析（解析的过程就是去数据库中查是否存在该UID对应的用户）。 给有效的UIDs对应的用户进行劵补发操作，调用发劵接口。 等待所有用户全部调用发劵接口完毕，记录失败的UIDs，响应给前端。 事故分析 事故描述：运营人员上传了250个用户UID进行补发劵，点击补发按钮，等待了约2分钟页面显示失败了215个UID。 排查情况：线上环境将应用部署到了2台服务器。我们在A和B两台服务器的日志上都查到了补发请求相关日志。服务器A上的日志显示补发失败35条，服务器B上的日志显示补发失败215条。 原因分析： A服务器上的日志显示控制器层接收到请求的时刻是：2019-09-06 10:51:19.075，响应请求的时刻是：2019-09-06 10:52:40.171； B服务器上的日志显示控制器层接收到请求的时刻是：2019-09-06 10:52:19.061，响应请求的时刻是：2019-09-06 10:52:40.022。 A服务器上记录的失败的35个UIDs在B服务器上发劵成功；B服务器上记录的失败的215个UIDs在A服务器上发劵成功。另外从日志中可看出发劵接口做了幂等校验。 初步排查：由于后端服务器接收到了两个请求，判断是否运营人员点了两次补发按钮？经过对前端页面的测试，点了一次补发按钮后，页面出现loading遮罩层，不能第二次点击补发按钮。排除运营人员操作的问题。 进一步分析：A和B两台服务器接收到请求的时间间隔恰好是1分钟左右，是否是前端Ajax请求的响应超时会自动重试？由于前端页面是使用jQuery发送Ajax请求，并且请求类型是POST，浏览器并不会自动重试。 最终得出结论：在向指导人请教后，推测是线上环境有Nginx进行负载均衡，当ajax请求得到响应的时间超过Nginx默认的60秒时，请求会自动重发到另一台服务器。向部门经理确认系统架构后，线上环境确实存在负载均衡，使用的是阿里的SLB。（由于我们刚接手该项目，对线上环境还不太熟悉）阿里的SLB开启了超时自动重发机制，超时时间是60秒。 事故结论一个补发劵的请求经过SLB负载均衡到后端服务器，后端服务器执行业务代码时间超过了一分钟，过了60秒后，SLB认为该请求超时，触发重试机制，将同样的请求负载到另外一台后端服务器上，两台服务器上的线程开始并发调用发劵接口，由于发劵接口做了接口幂等性校验，所以并未出现发劵重复的情况。最终250个UIDs都成功的完成了补发。 解决方案： 运营人员每次上传少量UIDs，保证响应时间小于60秒。 产品经理提出迭代需求，版本升级。 值得思考的问题产品经理提出需求时，说要简化开发，设计轻量化等。但我们作为Java开发工程师，我们不能和产品经理想的一样，将系统想的过于简化。仍然要从一个程序的角度出发来考虑问题。 代码升级方案我们知道，在原生安卓项目开发中，所有的网络请求都必须在子线程中执行。 安卓为什么要这样限制呢？我想，安卓一定是考虑到所有的网络请求都是有可能出现超时的，即使网络请求只是去简单的获取一个资源，但仍可能会出现网络延迟的情况。如果在主线程中执行，一旦出现延迟或者超时，给用户的感觉就是界面卡住。于是安卓进行了异步化设计。限制网络请求只能在子线程中执行。 对于Web应用系统，如果有执行时间较长的请求，我们也要尽量将其放在子线程中执行。避免因为等待远程服务的返回，或者对数据库的查询，而阻塞主线程的执行，浪费宝贵的计算资源，影响用户体验。 这次线上事故的根本原因就是开发经验不足，考虑不周，不了解线上情况，未进行异步化设计。由于一次请求需要补发较多的用户，导致一次HTTP请求迟迟未完成三次握手四次挥手过程，SLB服务器认为请求超时，触发了重试机制，将同样的请求打到另外一台服务器上。 在Java语言中，Future接口，尤其是它在Java 8中的新版实现CompletableFuture，是进行异步化设计的利器。 Future接口Future接口在Java 5中被引入，设计初衷是对将来某个时刻会发生的结果进行建模。它建模了一种异步计算，返回一个执行运算结果的引用，当运算结束后，这个引用被返回给调用方。在Future中触发那些潜在耗时的操作把调用线程解放出来，让它能及时响应客户端或者继续执行其它有价值的工作，不再需要呆呆的等到耗时的操作完成。 上述补发劵业务最初的同步代码大致如下（考虑企业隐私，屏蔽关键词）： 业务Service层代码： 12345678910111213141516171819202122232425262728293031323334353637/** * 同步 劵补发操作 * @param uIds 用户UID集合 * @param couponId 优惠券ID * @return 失败的用户UID集合 */@Overridepublic List&lt;String&gt; syncReSupplyCoupon(List&lt;String&gt; uIds, String couponId) { List&lt;String&gt; result = new ArrayList&lt;&gt;(); List&lt;UserInfoModel&gt; userInfoModelList = new ArrayList&lt;&gt;(); // 循环验证UID有效性 for (String uId : uIds) { // 查询UID对应用户信息 UserInfoModel userInfoModel = reSupplyCouponService.queryUserInfo(uId); if (userInfoModel != null) { // UID存在，放入待进行补发用户集合 userInfoModelList.add(userInfoModel); } else { // UID不存在，放入返回结果集合 result.add(uId); } } // 循环进行劵补发 for (UserInfoModel userInfoModel : userInfoModelList) { Boolean flag = false; try { flag = reSupplyCouponService.reSupplyCoupon(couponId,userInfoModel.getUid()); } catch (Exception e) { // 异常处理 } if (!flag) { // 补发劵失败，放入返回结果集合 result.add(userInfoModel.getUid()); } } return result;} 基础Service层代码： 1234567891011121314151617181920/** * 查询用户信息 * @param uId 用户UID * @return 用户信息model */@Overridepublic UserInfoModel queryUserInfo(String uId) { return reSupplyCouponIntegration.queryUserInfo(uId);}/** * 补发劵操作 * @param couponId 优惠券ID * @param uId 用户ID * @return 补发结果：成功或失败 */@Overridepublic Boolean reSupplyCoupon(String couponId, String uId) { return reSupplyCouponIntegration.reSupplyCoupon(couponId,uId);} Integration防腐层代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344private static List&lt;UserInfoModel&gt; users = new ArrayList&lt;&gt;();/** * 初始化操作，模拟远程用户数据 */static { for (int i = 0; i &lt; 250; i++) { users.add(new UserInfoModel(String.valueOf(i))); }}/** * 模拟查找用户操作，不存在则UID则新增一个。 * @param uId 用户UID * @return 用户信息model */@Overridepublic UserInfoModel queryUserInfo(String uId) { try { // 模拟调用远程服务耗时 Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } return users.get(Integer.valueOf(uId));}/** * 模拟补发劵操作 * @param couponId 优惠券ID * @param uId 用户id * @return 补发劵结果：成功或失败 */@Overridepublic Boolean reSupplyCoupon(String couponId, String uId) { try { // 模拟调用远程服务耗时 Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } // 模拟成功或失败概率 return new Random().nextInt(100) &lt; 90;} 这段同步执行的代码中存在的问题：包含2个for循环中通过RPC调用远程服务提供方进行数据库操作，如果UID集合数据量较大，这个方法的执行时间是非常长的，例如这次事故中运营人员上传了250个UID，执行时间就花了2分钟左右。耗时过长，SLB负载均衡服务器认为请求超时，进行重试。 使用Future接口进行代码异步化改造：将耗时的操作封装到一个Callable对象中，再将它提交给ExecutorService线程池。 业务Service层代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 初始化线程池 */private static ExecutorService executorService = Executors.newCachedThreadPool();/** * 声明Future */private static Future&lt;List&lt;String&gt;&gt; future;/** * 使用Callable封装耗时操作 */class AsyncReSupplyCouponCallable implements Callable&lt;List&lt;String&gt;&gt; { // 通过构造函数间接传递参数给call方法 private List&lt;String&gt; uIds; private String couponId; public AsyncReSupplyCouponCallable(List&lt;String&gt; uIds, String couponId) { this.uIds = uIds; this.couponId = couponId; } @Override public List&lt;String&gt; call() throws Exception { // 调用同步的补发劵方法 return syncReSupplyCoupon(uIds,couponId); }}/** * 异步 劵补发操作 基于JDK 5的Future接口 * @param uIds 用户UID集合 * @param couponId 优惠券ID */@Overridepublic void asyncFutureReSupplyCoupon(List&lt;String&gt; uIds, String couponId) { future = executorService.submit(new AsyncReSupplyCouponCallable(uIds,couponId)); executorService.shutdown();} /** * 获取补发劵失败的UIDs在前端显示 * 由前端控制调用该方法的时机 * 根据上传的UIDs数量做轮询，时间可以设置久一点。 * @return 补发失败的UID集合 */@Overridepublic List&lt;String&gt; getFailedUIDs() { List&lt;String&gt; result = new ArrayList&lt;&gt;(); try { if (future != null) { // 如果调用get方法时，Callable中的任务还未执行完，则线程阻塞在这里。 // 使用重载的get方法设置超时时间为50秒。如果发生阻塞，则最多等待50秒后退出。 result = future.get(50, TimeUnit.SECONDS); } } catch (InterruptedException e) { // 线程等待过程中被中断 } catch (ExecutionException e) { // 计算抛出一个异常 } catch (TimeoutException e) { // 在Future对象完成之前超时已过期 } return result;} 异步化改造基本已经完成。以上代码已经能够有效避免这次线上事故再次发生了。 接口性能提升基于Future接口的异步改造已经能够避免事故再次发生，但是耗时的补发劵操作在子线程执行仍然是同步的。子线程中验证同步执行验证250个UIDs是否合法，给250个用户补发劵。耗时仍然很长。如何提升接口的性能呢？如果让不同的UID之间的操作并行，则可显著提升性能。 方案一：使用Java 8的并行流利用Java 8的并行流避免每个UID的顺序执行。 业务Service层代码： 123456789101112131415161718192021222324252627282930/** * 使用并行流 补发劵 * @param uIds 用户UID集合 * @param couponId 优惠券ID * @return 补发失败的用户UIDs集合 */@Overridepublic List&lt;String&gt; parallelReSupplyCoupon(List&lt;String&gt; uIds, String couponId) { List&lt;String&gt; failUidList = new ArrayList&lt;&gt;(); // 使用并行流验证UID是否合法，按是否合法进行分区：不存在的为true区 Map&lt;Boolean, List&lt;UserInfoModel&gt;&gt; userInfoModelMap = uIds.parallelStream() .map(uId -&gt; reSupplyCouponService.queryUserInfo(uId)) .collect(Collectors.partitioningBy(Objects::isNull)); // 取出不合法的UID加入补发失败的集合中 userInfoModelMap.get(true) .parallelStream() .map(userInfoModel -&gt; failUidList.add(userInfoModel.getUid())) .collect(Collectors.toList()); // 触发中间操作 // 取出合法的UID进行补发劵操作 List&lt;Map&lt;String, Object&gt;&gt; reSupplyCouponResult = userInfoModelMap.get(false) .parallelStream() .map(userInfoModel -&gt; reSupplyCouponService.reSupplyCouponWithUid(couponId, userInfoModel.getUid())) .collect(Collectors.toList()); // 从补发劵结果中取出补发失败的加入补发失败的集合中 reSupplyCouponResult.parallelStream() .filter(map -&gt; !(Boolean) map.get(&quot;result&quot;)) .map(map -&gt; failUidList.add(String.valueOf(map.get(&quot;uId&quot;)))) .collect(Collectors.toList()); return failUidList;} 基础Service层中新增接口： 1234567891011121314/** * 补发劵操作 * @param couponId 优惠券ID * @param uId 用户ID * @return [UID,&quot;成功或失败&quot;]，返回对应UID。 */@Overridepublic Map&lt;String, Object&gt; reSupplyCouponWithUid(String couponId, String uId) { Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;uId&quot;,uId); Boolean result = reSupplyCouponIntegration.reSupplyCoupon(couponId,uId); map.put(&quot;result&quot;,result); return map;} 方案二：使用Java 8的CompletableFuture接口利用Java 8的CompletableFuture接口异步化。每一个UID的操作之间都是异步的。 需要对所有的CompletableFuture对象执行join操作，一个一个等待它们执行完毕。CompletableFuture类中的join方法和Future接口中的get方法有相同的含义，并且也声明在Future接口中，唯一的不同是join方法不会抛出任何检测到的异常。所以不会显得Lambda表达式过于臃肿。 业务Service层代码： 12345678910111213141516171819202122232425262728293031323334353637/** * 异步 劵补发操作 每一个UID之间都是异步的 基于JDK 8的CompletableFuture接口 * @param uIds * @param couponId * @return */@Overridepublic List&lt;String&gt; asyncCompletableFutureReSupplyCoupon(List&lt;String&gt; uIds, String couponId) { List&lt;String&gt; failUidList = new ArrayList&lt;&gt;(); // 使用CompletableFuture异步操作：验证UID是否存在系统中 List&lt;CompletableFuture&lt;UserInfoModel&gt;&gt; list = uIds.stream() .map(uId -&gt; CompletableFuture.supplyAsync( () -&gt; reSupplyCouponService.queryUserInfo(uId)) ).collect(Collectors.toList()); // 等待所有异步操作执行结束，分区筛选出存在的UIDs和不存在的UIDs Map&lt;Boolean, List&lt;UserInfoModel&gt;&gt; joinMap = list.stream() .map(CompletableFuture::join) .collect(Collectors.partitioningBy(Objects::isNull)); // 将不存在的UIDs加入补发失败的集合中 joinMap.get(true) .stream() .map(userInfoModel -&gt; failUidList.add(userInfoModel.getUid())) .collect(Collectors.toList()); // 使用CompletableFuture异步给存在的UIDs补发劵 List&lt;CompletableFuture&lt;Map&lt;String, Object&gt;&gt;&gt; reSupplyCouponResult = joinMap.get(false) .stream() .map(userInfoModel -&gt; CompletableFuture.supplyAsync( () -&gt; reSupplyCouponService.reSupplyCouponWithUid(couponId, userInfoModel.getUid())) ).collect(Collectors.toList()); // 等待所有异步操作执行结束，筛选出补发劵失败的UIDs存入返回结果集合中 reSupplyCouponResult.stream() .map(CompletableFuture::join) .filter(r -&gt; !(Boolean) r.get(&quot;result&quot;)) .map(r -&gt; failUidList.add(String.valueOf(r.get(&quot;uId&quot;)))) .collect(Collectors.toList()); return failUidList;} 比较并行流和异步接口的快慢初始化8个UID进行测试。 测试代码： 12345678910111213141516171819202122232425262728293031323334353637383940private static List&lt;String&gt; uIds = new ArrayList&lt;&gt;();/** * 初始化8个UIDs，模拟待补发用户 */static { for (int i = 0; i &lt; 8; i++) { uIds.add(String.valueOf(i)); }}/** * 测试使用Java 8的并行流进行的补发劵操作 * * 8个UID * done in 312msecs */@Testpublic void testParallelReSupplyCoupon() { long start = System.nanoTime(); List&lt;String&gt; failedUIDs = reSupplyCouponBizService.parallelReSupplyCoupon(uIds, &quot;1&quot;); long duration = (System.nanoTime() - start) / 1_000_000; System.out.println(&quot;done in &quot; + duration + &quot;msecs&quot;); failedUIDs.stream().forEach(System.out::println);}/** * 测试 异步 劵补发操作 每一个UID之间都是异步的 基于JDK 8的CompletableFuture接口 * * 8个UID * done in 610msecs */@Testpublic void testAsyncCompletableFutureReSupplyCoupon() { long start = System.nanoTime(); List&lt;String&gt; failedUIDs = reSupplyCouponBizService.asyncCompletableFutureReSupplyCoupon(uIds, &quot;1&quot;); long duration = (System.nanoTime() - start) / 1_000_000; System.out.println(&quot;done in &quot; + duration + &quot;msecs&quot;); failedUIDs.stream().forEach(System.out::println);} 结果让人相当失望。使用CompletableFuture新接口的耗时大约是使用并行流版本的两倍。难道这种场景下使用CompletableFuture真的是浪费时间吗？也许我们漏掉了某些很重要的东西？我们运行测试代码的电脑是否足以以并行方式运行8个线程？ 并行流的版本运行的足够快，那是因为它能并行的执行的8个线程，它能为每个UID的操作分配一个线程。但是，如果现在我们初始化9个UID进行测试，我们来看看结果： 1234567并行流版本9个UIDdone in 617msecs异步接口版本9个UIDdone in 611msecs 并行流版本9个UID的测试结果比之前大概多消耗了3秒，这个时间间隔刚好是一次模拟调用远程服务接口的耗时。因为可以并行运行的8个线程开始都处于工作状态，都在对前8个UID进行补发劵等操作。第9个UID的操作只能等到前面某个操作完成释放出空闲线程才能继续。 异步接口版本的测试结果和并行流版本相差无几。究其原因都一样：它们内部采用的是同样的通用线程池，默认都使用固定数量的线程，具体线程数取决于Runtime.getRuntime().availableProcessors()的返回值。然而，CompletableFuture具有一定优势，它可以定制执行器，自定义线程池的大小。这是并行流API无法实现的。 定制异步接口的执行器创建一个配有线程池的执行器很容易，但是我们该如何选择合适的线程数目呢？ 《Java并发编程实战》书中介绍到，Brian Goetz和合著者们为线程池大小的优化提供了不少中肯的建议。这非常重要，如果线程池中线程的数量过多，最终它们会竞争稀缺的处理器和内存资源，浪费大量的时间在上下文切换上。反之，如果线程的数目过少，正如你的应用所面临的情况，处理器的一些核可能就无法充分利用。Brian Goetz建议，线程池大小与处理器的利用率之比可以使用下面的公式进行估算：Nthreads = NCPU * UCPU * (1 + W/C)其中： Nthreads是处理器的核的数目，可以通过Runtime.getRuntime().availableProcessors()得到； UCPU是期望的CPU利用率（该值应该介于0和1之间） W/C是等待时间与计算时间的比率 补发劵接口99%的时间都在等待远程服务的响应，所以估算出的W/C的比率为100。如果期望的CPU利用率为100%，则需要创建一个拥有800个线程的线程池。但实际上，线程池中的有些线程根本没机会被使用，反而是一种浪费。所以建议将执行器使用的线程数，与实际需要的线程数（UIDs的数量）设定为同样的值。这样每个UID都对应一个服务线程。但是，当UIDs数量过大时，运行代码的机器必然会因超负荷而崩溃，所以最好还是有一个上限。 业务Service层相关代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 定制执行器-线程池大小为UIDs的数量：设置为守护线程，当程序退出时，线程也会被回收。 */private final Executor executor = Executors.newFixedThreadPool(125, r -&gt; { Thread t = new Thread(r); t.setDaemon(true); return t;});/** * 异步 劵补发操作 定制CompletableFuture接口的执行器 * @param uIds 用户UID集合 * @param couponId 优惠券ID * @return 补发失败的用户UID集合 */@Overridepublic List&lt;String&gt; asyncCompletableFutureCustomExecutorReSupplyCoupon(List&lt;String&gt; uIds, String couponId) { List&lt;String&gt; failUidList = new ArrayList&lt;&gt;(); // 使用定制执行器的CompletableFuture异步操作：验证UID是否存在系统中 List&lt;CompletableFuture&lt;UserInfoModel&gt;&gt; list = uIds.stream() .map(uId -&gt; CompletableFuture.supplyAsync( () -&gt; reSupplyCouponService.queryUserInfo(uId),executor) ).collect(Collectors.toList()); // 等待所有异步操作执行结束，分区筛选出存在的UIDs和不存在的UIDs Map&lt;Boolean, List&lt;UserInfoModel&gt;&gt; joinMap = list.stream() .map(CompletableFuture::join) .collect(Collectors.partitioningBy(Objects::isNull)); // 将不存在的UIDs加入补发失败的集合中 joinMap.get(true) .stream() .map(userInfoModel -&gt; failUidList.add(userInfoModel.getUid())) .collect(Collectors.toList()); // 使用定制执行器的CompletableFuture异步给存在的UIDs补发劵 List&lt;CompletableFuture&lt;Map&lt;String, Object&gt;&gt;&gt; reSupplyCouponResult = joinMap.get(false) .stream() .map(userInfoModel -&gt; CompletableFuture.supplyAsync( () -&gt; reSupplyCouponService.reSupplyCouponWithUid(couponId, userInfoModel.getUid()),executor) ).collect(Collectors.toList()); // 等待所有异步操作执行结束，筛选出补发劵失败的UIDs存入返回结果集合中 reSupplyCouponResult.stream() .map(CompletableFuture::join) .filter(r -&gt; !(Boolean) r.get(&quot;result&quot;)) .map(r -&gt; failUidList.add(String.valueOf(r.get(&quot;uId&quot;)))) .collect(Collectors.toList()); return failUidList;} 使用125个UID进行测试： 12345678910111213141516171819202122232425private static List&lt;String&gt; uIds = new ArrayList&lt;&gt;();/** * 初始化操作，模拟待补发用户 */static { for (int i = 0; i &lt; 125; i++) { uIds.add(String.valueOf(i)); }}/** * 测试 异步 劵补发操作 定制CompletableFuture接口的执行器 * * 125个UID * done in 369msecs */@Testpublic void testAsyncCompletableFutureCustomExecutorReSupplyCoupon() { long start = System.nanoTime(); List&lt;String&gt; failedUIDs = reSupplyCouponBizService.asyncCompletableFutureCustomExecutorReSupplyCoupon(uIds, &quot;1&quot;); long duration = (System.nanoTime() - start) / 1_000_000; System.out.println(&quot;done in &quot; + duration + &quot;msecs&quot;); failedUIDs.stream().forEach(System.out::println);} 测试结果：done in 369msecs，显而易见，耗时和8个UID的并行流版本很接近。性能显著提升。一般而言，随着UID数量继续增多，耗时不会相差太多，直到达到之前计算的阈值800（CPU利用率达到100%）。 在并行流和CompletableFuture之间进行选择并行流底层的Fork/Join框架使用通用的线程池，无法个性化定制。新的CompletableFuture接口可以定制执行器，调整线程池大小，能够更加充分的利用CPU资源。 建议如下： 如果你进行的是计算密集型的操作，并且没有I/O，那么推荐使用Stream接口，因为实现简单，同时效率也可能是最高的（如果所有的线程都是计算密集型的，那就没有必要创建比处理器核数更多的线程）。 反之，如果你并行的工作单元还涉及等待I/O的操作（包括网络连接等待），那么使用CompletableFuture灵活性更好，你可以像前文讨论的那样，依据等待/计算，或者W/C的比率设定需要使用的线程数。这种情况不使用并行流的另一个原因是，处理流的流水线中如果发生I/O等待，流的延迟特性会让我们很难判断到底什么时候触发了等待。 总结执行比较耗时的操作时，尤其是那些依赖一个或多个远程服务的操作，建议进行异步化设计，使用CompletableFuture类提供的特性可轻松实现异步API。","link":"/2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(3)/"},{"title":"《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（四）：使用新的日期时间API","text":"第十二章：新的日期时间API在Java 8之前，我们常用的日期时间API是java.util.Date和java.util.Calendar这两个类。 如果我们要构建一个指定年月日的日期时间对象，比如2019-9-2，使用java.util.Date类的构造方法Date(int year, int month, int date)，传入的年份year参数必须是年份2019减去1900，即传入119。每次创建对象前还需要先进行计算，很不方便。 JDK 1.1提供的java.util.Calendar类在使用时也有很多不方便的地方，比如对一个日期加两天，使用add方法，传入2；对一个日期减两天，也使用add方法，传入-2。还有一点是这个类默认每周第一天是周日。使用起来也有点不方便。 归根到底，JDK1.8之前的日期时间API都是可变的，是线程不安全的。 另外，对时间日期进行格式化的类SimpleDateFormat在java.text包下，该类的定义位置不规范。它也是线程不安全的。 而在Java 8中，时间格式转化器是java.time.format.DateTimeFormatter类，它被声明为final，是不可变的类，线程安全。 另外，Java 8中提供的新日期时间API包含两类：一个是为了便于人阅读使用，包含LocalDate、LocalTime、LocalDateTime这三个类，它们都是用final修饰的类，是不可变的对象，分别表示ISO-8601日历系统中的日期、时间、日期和时间。另外一个是便于机器处理的类，Instant：用来表示机器的日期和时间格式：时间戳。 ISO-8601日历系统：是国际标准化组织制定的现代公民的日期和时间的表示法。时间戳：从UNIX元年：1970年1月1日 00:00:00到某个时间之间的毫秒值。 传统时间格式转换器SimpleDateFormat线程安全问题演示当多个线程同时操作同一个SimpleDateFormat对象时，就会出现线程安全问题。 演示代码： 123456789101112131415161718public static void main(String[] args) { SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); // 使用线程池模拟多线程 ExecutorService threadPool = Executors.newFixedThreadPool(10); // 定义解析日期字符串任务：使用SimpleDateFormat对象解析 Callable&lt;Date&gt; task = () -&gt; sdf.parse(&quot;2019-8-29&quot;); // 存储结果容器 List&lt;Future&lt;Date&gt;&gt; result = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { // 执行得到解析结果 result.add(threadPool.submit(task)); } // 遍历输出 for (Future&lt;Date&gt; r : result) { System.out.println(r.get()); } threadPool.shutdown();} 异常信息如下： 1Exception in thread &quot;main&quot; java.util.concurrent.ExecutionException: java.lang.NumberFormatException: multiple points 解决方法：1、将SimpleDateFormat定义为方法内的局部变量，且方法中没有多线程的操作。2、使用ThreadLocal进行线程封闭。为每个线程保存一个SimpleDateFormat对象。 传统时间格式转换器线程安全问题解决方案：使用ThreadLocal进行线程封闭线程封闭类代码： 1234567891011121314151617181920212223package cn.org.lilu.chapter12;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;/** * @Auther: lilu * @Date: 2019/8/29 * @Description: 传统时间格式转换器线程安全问题解决方案：使用ThreadLocal进行线程封闭 */public class TraditionalSimpleDateFormatThreadLocal { private static final ThreadLocal&lt;DateFormat&gt; threadLocal = new ThreadLocal&lt;DateFormat&gt;() { @Override protected DateFormat initialValue() { return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); } }; public static Date convert(String source) throws Exception { return threadLocal.get().parse(source); }} 演示代码： 1234567891011121314151617public static void main(String[] args) throws Exception { // 使用线程池模拟多线程 ExecutorService threadPool = Executors.newFixedThreadPool(10); // 定义解析日期字符串任务：每个任务都有一份SimpleDateFormat对象的副本 Callable&lt;Date&gt; task = () -&gt; TraditionalSimpleDateFormatThreadLocal.convert(&quot;2019-8-29&quot;); // 解析结果容器 List&lt;Future&lt;Date&gt;&gt; result = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { // 执行得到解析结果 result.add(threadPool.submit(task)); } // 遍历输出 for (Future&lt;Date&gt; r : result) { System.out.println(r.get()); } threadPool.shutdown();} 运行结果正常。 Java 8新的时间格式转化器DateTimeFormatterDateTimeFormatter类定义在java.time.format包下，且声明为final类，不可变，线程安全。 代码演示： 1234567891011121314151617public static void main(String[] args) throws Exception { // 按照哪种格式进行格式转换 // DateTimeFormatter dtf = DateTimeFormatter.ISO_LOCAL_DATE; DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;); // LocalDate.parse(&quot;20190829&quot;,dtf)：将第一个字符串参数按照第二个参数定义的格式器解析，返回一个LocalDate对象 Callable&lt;LocalDate&gt; task = () -&gt; LocalDate.parse(&quot;20190829&quot;,dtf); ExecutorService threadPool = Executors.newFixedThreadPool(10); List&lt;Future&lt;LocalDate&gt;&gt; result = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { result.add(threadPool.submit(task)); } // 遍历输出 for (Future&lt;LocalDate&gt; r : result) { System.out.println(r.get()); } threadPool.shutdown();} Java 8日期时间API：LocalDate、LocalTime、LocalDateTime这三个类的用法几乎一样，LocalDate表示日期，LocalTime表示时间，LocalDateTime包含前两者，表示日期和时间。 可由前两个类组合出第三个类，也可由第三个类提取出前两个类。 年月日对象：LocalDate可使用静态工厂方法now获取当前日期； 可使用静态工厂方法of创建一个LocalDate日期对象，可从一个LocalDate日期对象中获取该日期的年份、月份、这个月的第几天、这周的星期几、今年的第几天、这个月的长度（有几天）和是否为闰年等信息。 代码演示： 1234567891011121314151617181920212223242526272829303132/** * LocalDate：年月日 */@Testpublic void testLocalDate() { // 静态工厂方法now获取当前日期 LocalDate now = LocalDate.now(); // 静态工厂方法of创建一个LocalDate实例 LocalDate date = LocalDate.of(2019,8,26); // 年份 int year = date.getYear(); // 月份 Month month = date.getMonth(); // 这个月第几天 int dayOfMonth = date.getDayOfMonth(); // 这周星期几 DayOfWeek dayOfWeek = date.getDayOfWeek(); // 今年第几天 int dayOfYear = date.getDayOfYear(); // 这个月的长度（有几天） int lengthOfMonth = date.lengthOfMonth(); // 是否闰年 boolean leapYear = date.isLeapYear(); System.out.println(now); // 2019-09-02 System.out.println(year); // 2019 System.out.println(month); // AUGUST System.out.println(dayOfMonth); // 26 System.out.println(dayOfWeek); // MONDAY System.out.println(dayOfYear); // 238 System.out.println(lengthOfMonth); // 31 System.out.println(leapYear); // false} 时分秒对象：LocalTime可使用静态工厂方法now获取当前时间的时分秒（包含纳秒）。 可使用静态工厂方法of创建一个LocalTime时间对象，可从一个LocalTime时间对象中获取该时间的时、分、秒和纳秒等信息。 of方法包含三个重载，方法签名如下： 1234567891011121314151617181920/** * @param hour the hour-of-day to represent, from 0 to 23 * @param minute the minute-of-hour to represent, from 0 to 59 */public static LocalTime of(int hour, int minute);/** * @param hour the hour-of-day to represent, from 0 to 23 * @param minute the minute-of-hour to represent, from 0 to 59 * @param second the second-of-minute to represent, from 0 to 59 */public static LocalTime of(int hour, int minute, int second);/** * @param hour the hour-of-day to represent, from 0 to 23 * @param minute the minute-of-hour to represent, from 0 to 59 * @param second the second-of-minute to represent, from 0 to 59 * @param nanoOfSecond the nano-of-second to represent, from 0 to 999,999,999 */public static LocalTime of(int hour, int minute, int second, int nanoOfSecond); 使用代码示例： 12345678910111213141516171819202122/** * LocalTime：时分秒 * 一天中的时间，比如：13:45:20，可以使用LocalTime类表示 * 可以使用of重载的三个静态工厂方法创建LocalTime实例 * 第一个重载方法接收小时和分钟 * 第二个重载方法同时还接收秒 * 第三个重载方法同时还接收纳秒 */@Testpublic void testLocalTime() { LocalTime now = LocalTime.now(); LocalTime localTime = LocalTime.of(13, 45, 20,1); int hour = localTime.getHour(); int minute = localTime.getMinute(); int second = localTime.getSecond(); int nano = localTime.getNano(); System.out.println(now); // 19:47:51.212 System.out.println(hour); // 13 System.out.println(minute); // 45 System.out.println(second); // 20 System.out.println(nano); // 1} 日期时间字符串解析LocalDate和LocalTime都可以通过解析代表它们的字符串创建。使用静态方法parse。一旦传递的字符串参数无法被解析为合法的LocalDate或LocalTime对象，这两个parse方法都会抛出一个继承自RuntimeException的DateTimeParseException异常。 代码示例： 12345678910111213/** * LocalDate和LocalTime都可以通过解析代表它们的字符串创建。使用静态方法parse。 * 一旦传递的字符串参数无法被解析为合法的LocalDate或LocalTime对象， * 这两个parse方法都会抛出一个继承自RuntimeException的DateTimeParseException异常。 */@Testpublic void testParse() { // 小于10的必须在前面补0，否则抛出异常 LocalDate localDate = LocalDate.parse(&quot;2019-08-26&quot;); LocalTime localTime = LocalTime.parse(&quot;13:45:20&quot;); System.out.println(localDate); System.out.println(localTime);} 年月日时分秒对象：LocalDateTime可使用静态工厂方法now获取当前时间的年月日时分秒纳秒； 可使用静态工厂方法of创建一个LocalDateTime日期时间对象； 可由LocalDate和LocalTime组合出LocalDateTime对象； 可从LocalDateTime对象中提取出LocalDate和LocalTime。 代码示例： 123456789101112131415161718192021222324252627/** * LocalDateTime：年月日时分秒 */@Testpublic void testLocalDateTime() { LocalDateTime localDateTime = LocalDateTime.now(); LocalDateTime localDateTime1 = LocalDateTime.of(2019, Month.AUGUST, 26, 10, 47, 20); LocalDate localDate = LocalDate.now(); LocalTime localTime = LocalTime.now(); // 由LocalDate和LocalTime组合出LocalDateTime LocalDateTime localDateTime2 = LocalDateTime.of(localDate,localTime); LocalDateTime localDateTime3 = localDate.atTime(10,51,32); LocalDateTime localDateTime4 = localDate.atTime(localTime); LocalDateTime localDateTime5 = localTime.atDate(localDate); // 由LocalDateTime提取出LocalDate和LocalTime LocalDate localDateFromLocalDateTime = localDateTime2.toLocalDate(); LocalTime localTimeFromLocalDateTime = localDateTime2.toLocalTime(); System.out.println(localDateTime); // 2019-09-02T19:57:16.516 System.out.println(localDateTime1); // 2019-08-26T10:47:20 System.out.println(localDateTime2); // 2019-09-02T19:57:16.517 System.out.println(localDateTime3); // 2019-09-02T10:51:32 System.out.println(localDateTime4); // 2019-09-02T19:57:16.517 System.out.println(localDateTime5); // 2019-09-02T19:57:16.517 System.out.println(localDateFromLocalDateTime); // 2019-09-02 System.out.println(localTimeFromLocalDateTime); // 19:57:16.517} 时间戳对象：Instant机器的日期和时间格式：从UNIX元年时间开始到现在所经过的秒数对时间进行建模。包含的是由秒及纳秒组成的数字。 使用静态工厂方法now获取当前时刻的时间戳，默认获取的是UTC时区（世界协调时间）所在的时刻，可做时区偏移运算获取带偏移量的日期时间对象OffsetDateTime。可使用toEpochMilli方法获取表示的时间戳秒数。 可使用静态工厂方法ofEpochSecond等对时间戳进行运算。 Instant的设计初衷是为了便于机器使用。它包含的是由秒及纳秒所构成的数字。所以，它无法处理那些我们非常容易理解的时间单位。比如下面这行代码： 1int day = Instant.now().get(ChronoField.DAY_OF_MONTH); 它会抛出如下异常： 1java.time.temporal.UnsupportedTemporalTypeException: Unsupported field: DayOfMonth 示例代码： 123456789101112131415161718192021222324252627282930313233/** * Instant：从UNIX元年时间开始到现在所经过的秒数对时间进行建模。包含的是由秒及纳秒组成的数字。 * * 静态工厂方法：ofEpochSecond包含两个重载版本 * // 传入一个代表秒数的值创建一个Instant实例 * Instant ofEpochSecond(long epochSecond) * // 第一个参数：代表秒数的值，第二个参数：纳秒数，对第一个参数传入的秒数进行调整，确保保存的纳秒分片在0到999 999 999之间。 * Instant ofEpochSecond(long epochSecond, long nanoAdjustment) * * 静态工厂方法：now */@Testpublic void testInstant() { Instant instant1 = Instant.ofEpochSecond(3); Instant instant2 = Instant.ofEpochSecond(3, 0); Instant instant3 = Instant.ofEpochSecond(2, 1_000_000_000); Instant instant4 = Instant.ofEpochSecond(4, -1_000_000_000); System.out.println(instant1); System.out.println(instant2); System.out.println(instant3); System.out.println(instant4); Instant now = Instant.now(); // 默认获取UTC时区的时间 System.out.println(now); // 时区偏移运算：获取偏移8小时的时区的时间。OffsetDateTime：带偏移量的日期时间对象 OffsetDateTime offsetDateTime = now.atOffset(ZoneOffset.ofHours(8)); System.out.println(offsetDateTime); // 转化成时间戳 System.out.println(now.toEpochMilli()); // java.time.temporal.UnsupportedTemporalTypeException: Unsupported field: DayOfMonth int day = now.get(ChronoField.DAY_OF_MONTH); System.out.println(day);} 计算两个时间之间的间隔：Duration 和计算两个日期之间的间隔：Period可以使用Duration类的静态方法between计算两个时间点之间的间隔，between方法接收的参数是两个Temporal对象，虽然LocalDateTime和Instant都是Temporal接口的实现类，但是它们是为不同的目的而设计的，一个是为了便于人阅读使用， 另一个是为了便于机器处理，所以我们不能将它们混用，即不能计算LocalDateTime和Instant对象之间的间隔。 可以使用Period类的静态方法between计算两个日期之间的间隔。 也可使用静态工厂方法直接创建Duration和Period类的对象。 示例代码： 12345678910111213141516171819202122232425262728293031323334/** * 计算两个时间之间的间隔：Duration * 计算两个日期之间的间隔：Period */@Testpublic void testDuration() throws Exception { LocalTime localTime1 = LocalTime.parse(&quot;13:45:20&quot;); LocalTime localTime2 = LocalTime.parse(&quot;13:45:30&quot;); LocalDateTime localDateTime1 = LocalDateTime.now(); Thread.sleep(100); LocalDateTime localDateTime2 = LocalDateTime.now(); Instant instant1 = Instant.ofEpochSecond(3); Instant instant2 = Instant.ofEpochSecond(6); System.out.println(Duration.between(localTime1,localTime2)); // PT10S System.out.println(Duration.between(localDateTime1,localDateTime2)); // PT0.1S System.out.println(Duration.between(instant1,instant2)); // PT3S // 计算两个LocalDate之间的时长 Period periodBetween = Period.between(LocalDate.of(2019, 8, 26), LocalDate.of(2019, 8, 28)); System.out.println(periodBetween); // P1D System.out.println(periodBetween.getDays()); // 2 // Duration和Period的静态工厂方法直接创建实例 Duration durationOfMinutes = Duration.ofMinutes(3); Duration durationOf = Duration.of(3, ChronoUnit.MINUTES); Period periodOfDays = Period.ofDays(10); Period periodOfWeeks = Period.ofWeeks(3); Period periodOf = Period.of(2, 6, 1); System.out.println(durationOfMinutes); // PT3M System.out.println(durationOf); // PT3M System.out.println(periodOfDays); // P10D System.out.println(periodOfWeeks); // P21D System.out.println(periodOf); // P2Y6M1D} 操作、解析和格式化日期LocalDate、LocalTime、LocalDateTime以及Instant这样表示时间点的日期-时间类提供了很多通用的方法用来操作日期-时间。所有的方法都返回一个修改了属性的对象。它们都不会修改原来的对象。 最直接也最简单的方法是使用”withAttribute“方法。”withAttribute“方法会创建对象的一个副本，并按照需要修改它的属性。 也可使用通用的with方法，它接受的第一个参数是一个TemporalField对象，第二个参数是需要修改的值。 with方法还有一个重载的方法，它接收一个日期调整器TemporalAdjuster对象，更加灵活地处理日期。 代码示例： 12345678910111213141516171819202122232425/** * 操纵、解析和格式化日期 * * LocalDate、LocalTime和LocalDateTime类都为final类，不可变，每次操作后都返回一个新的对应对象 */@Testpublic void testUpdateTime() { LocalDate date1 = LocalDate.of(2019, 8, 26); LocalDate date2 = date1.withYear(2020); LocalDate date3 = date2.withDayOfMonth(25); LocalDate date4 = date3.with(ChronoField.MONTH_OF_YEAR, 9); System.out.println(date1); // 2019-08-26 System.out.println(date2); // 2020-08-26 System.out.println(date3); // 2020-08-25 System.out.println(date4); // 2020-09-25 LocalDate date5 = LocalDate.of(2019,8,26); LocalDate date6 = date5.plusWeeks(1); // 加一周 LocalDate date7 = date6.minusYears(3); // 减三年 LocalDate date8 = date7.plus(6, ChronoUnit.MONTHS); // 加六月 System.out.println(date5); // 2019-08-26 System.out.println(date6); // 2019-09-02 System.out.println(date7); // 2016-09-02 System.out.println(date8); // 2017-03-02} 日期调整器：TemporalAdjusterTemporalAdjuster是一个函数式接口，接口方法签名如下： 1Temporal adjustInto(Temporal temporal); 接收一个Temporal对象，返回一个Temporal对象。由于所有的日期时间API都实现了Temporal接口，故它可以用来自定义更加复杂的日期时间操作。 Java 8提供了TemporalAdjusters类，该类通过静态方法提供了大量的常用TemporalAdjuster的实现。 同时还支持定制TemporalAdjuster，定制的方式有两种： 一：实现TemporalAdjuster接口； 二：使用Lambda表达式定制TemporalAdjuster对象，推荐使用TemporalAdjusters类的静态工厂方法ofDateAdjuster，该方法签名如下： 1public static TemporalAdjuster ofDateAdjuster(UnaryOperator&lt;LocalDate&gt; dateBasedAdjuster) 接收一个UnaryOperator函数式接口，返回一个TemporalAdjuster对象。 UnaryOperator函数式接口中方法签名如下，它总是返回它的输入。 123static &lt;T&gt; UnaryOperator&lt;T&gt; identity() { return t -&gt; t;} 相关代码示例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/** * 日期调整器 */@Testpublic void testTemporalAdjuster() { LocalDate date1 = LocalDate.of(2019,8,26); // TemporalAdjuster dayOfWeekInMonth(int ordinal, DayOfWeek dayOfWeek) // dayOfWeek表示星期几 // 如果ordinal为0，则表示本日期所在的月的上一个月的最后一个星期几 // 如果ordinal为正数，则以本日期所在的月从前向后数，第ordinal个星期几 // 如果ordinal为负数，则以本日期所在的月从后往前数，第-ordinal个星期几 LocalDate date2 = date1.with(TemporalAdjusters.dayOfWeekInMonth(1, DayOfWeek.FRIDAY)); System.out.println(&quot;date2=&quot; + date2); // TemporalAdjuster firstDayOfMonth()：创建一个新的日期，它的值为当月的第一天 LocalDate date3 = date1.with(TemporalAdjusters.firstDayOfMonth()); System.out.println(&quot;date3=&quot; + date3); // TemporalAdjuster firstDayOfNextMonth()：创建一个新的日期，它的值为下月的第一天 LocalDate date4 = date1.with(TemporalAdjusters.firstDayOfNextMonth()); System.out.println(&quot;date4=&quot; + date4); // TemporalAdjuster firstDayOfNextYear()：创建一个新的日期，它的值为明年的第一天 LocalDate date5 = date1.with(TemporalAdjusters.firstDayOfNextYear()); System.out.println(&quot;date5=&quot; + date5); // TemporalAdjuster firstDayOfYear()：创建一个新的日期，它的值为今年的第一天 LocalDate date6 = date1.with(TemporalAdjusters.firstDayOfYear()); System.out.println(&quot;date6=&quot; + date6); // TemporalAdjuster firstInMonth(DayOfWeek dayOfWeek)：创建一个新的日期，它的值为同一个月中，第一个符合星期几要求的日期（这个月的第一个星期几） LocalDate date7 = date1.with(TemporalAdjusters.firstInMonth(DayOfWeek.FRIDAY)); System.out.println(&quot;date7=&quot; + date7); // TemporalAdjuster lastDayOfMonth()：创建一个新的日期，它的值为这个月的最后一天 LocalDate date8 = date1.with(TemporalAdjusters.lastDayOfMonth()); System.out.println(&quot;date8=&quot; + date8); // TemporalAdjuster lastDayOfYear()：创建一个新的日期，它的值为今年的最后一天 LocalDate date9 = date1.with(TemporalAdjusters.lastDayOfYear()); System.out.println(&quot;date9=&quot; + date9); // TemporalAdjuster lastInMonth(DayOfWeek dayOfWeek)：创建一个新的日期，它的值为同一个月中，最后一个符合星期几要求的日期 LocalDate date10 = date1.with(TemporalAdjusters.lastInMonth(DayOfWeek.FRIDAY)); System.out.println(&quot;date10=&quot; + date10); // TemporalAdjuster next(DayOfWeek dayOfWeek)：创建一个新的日期，并将其值设定为指定日期之后第一个符合指定星期几的日期 LocalDate date11 = date1.with(TemporalAdjusters.next(DayOfWeek.MONDAY)); System.out.println(&quot;date11=&quot; + date11); // TemporalAdjuster nextOrSame(DayOfWeek dayOfWeek)： // 创建一个新的日期，并将其值设定为指定日期之后第一个符合指定星期几的日期； // 如果指定日期已符合要求，则直接返回该日期 LocalDate date12 = date1.with(TemporalAdjusters.nextOrSame(DayOfWeek.MONDAY)); System.out.println(&quot;date12=&quot; + date12); // TemporalAdjuster previous(DayOfWeek dayOfWeek)：创建一个新的日期，并将其值设定为指定日期之前第一个符合指定星期几的日期 LocalDate date13= date1.with(TemporalAdjusters.previous(DayOfWeek.MONDAY)); System.out.println(&quot;date13=&quot; + date13); // TemporalAdjuster previousOrSame(DayOfWeek dayOfWeek)： // 创建一个新的日期，并将其值设定为指定日期之前第一个符合指定星期几的日期； // 如果指定日期已符合要求，则直接返回该日期 LocalDate date14 = date1.with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY)); System.out.println(&quot;date14=&quot; + date14); // 使用Lambda表达式定制TemporalAdjuster对象，推荐使用TemporalAdjusters类的静态工厂方法ofDateAdjuster // TemporalAdjuster ofDateAdjuster(UnaryOperator&lt;LocalDate&gt; dateBasedAdjuster) TemporalAdjuster nextWorkingDay = TemporalAdjusters.ofDateAdjuster(temporal -&gt; { DayOfWeek dayOfWeek = DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK)); int dayToAdd = 1; if (dayOfWeek == DayOfWeek.FRIDAY) dayToAdd = 3; else if (dayOfWeek == DayOfWeek.SATURDAY) dayToAdd = 2; return temporal.plus(dayToAdd,ChronoUnit.DAYS); });}/** * 定制TemporalAdjuster * * 计算下一个工作日 */class NextWorkingDay implements TemporalAdjuster { /** * 周一到周五为工作日 * 如果是周日到周四，则返回下一天 * 如果是周五、周六、返回下周周一 * @param temporal * @return */ @Override public Temporal adjustInto(Temporal temporal) { // 得到今天星期几 DayOfWeek dayOfWeek = DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK)); int dayToAdd = 1; if (dayOfWeek == DayOfWeek.FRIDAY) dayToAdd = 3; else if (dayOfWeek == DayOfWeek.SATURDAY) dayToAdd = 2; return temporal.plus(dayToAdd,ChronoUnit.DAYS); }} TemporalAdjusters类中包含的工厂方法列表： 方法签名 描述 TemporalAdjuster dayOfWeekInMonth(int ordinal, DayOfWeek dayOfWeek) dayOfWeek表示星期几如果ordinal为0，则表示本日期所在的月的上一个月的最后一个星期几如果ordinal为正数，则以本日期所在的月从前向后数，第ordinal个星期几 如果ordinal为负数，则以本日期所在的月从后往前数，第-ordinal个星期几 TemporalAdjuster firstDayOfMonth() 创建一个新的日期，它的值为当月的第一天 TemporalAdjuster firstDayOfNextMonth() 创建一个新的日期，它的值为下月的第一天 TemporalAdjuster firstDayOfNextYear() 创建一个新的日期，它的值为明年的第一天 TemporalAdjuster firstDayOfYear() 创建一个新的日期，它的值为今年的第一天 TemporalAdjuster firstInMonth(DayOfWeek dayOfWeek) 创建一个新的日期，它的值为同一个月中，第一个符合星期几要求的日期（这个月的第一个星期几） TemporalAdjuster lastDayOfMonth() 创建一个新的日期，它的值为这个月的最后一天 TemporalAdjuster lastDayOfYear() 创建一个新的日期，它的值为今年的最后一天 TemporalAdjuster lastInMonth(DayOfWeek dayOfWeek) 创建一个新的日期，它的值为同一个月中，最后一个符合星期几要求的日期 TemporalAdjuster next(DayOfWeek dayOfWeek) 创建一个新的日期，并将其值设定为指定日期之后第一个符合指定星期几的日期 TemporalAdjuster nextOrSame(DayOfWeek dayOfWeek) 创建一个新的日期，并将其值设定为指定日期之后第一个符合指定星期几的日期；如果指定日期已符合要求，则直接返回该日期 TemporalAdjuster previous(DayOfWeek dayOfWeek) 创建一个新的日期，并将其值设定为指定日期之前第一个符合指定星期几的日期 TemporalAdjuster previousOrSame(DayOfWeek dayOfWeek) 创建一个新的日期，并将其值设定为指定日期之前第一个符合指定星期几的日期；如果指定日期已符合要求，则直接返回该日期 时区时区的处理是新版日期和时间API新增加的重要功能，使用新版日期和时间API时区的处理被极大地简化了。新的java.time.ZoneId类是老版java.util.TimeZone的替代品。它的设计目标就是要让你无需为时区处理的复杂和繁琐而操心，跟其他日期和时间类一 样，ZoneId类也是被final修饰而无法修改的。 代码示例： 123456789101112131415161718/** * 带时区的日期时间API */@Testpublic void testZoneLocalDateTime() { // 查看所有支持的时区 Set&lt;String&gt; availableZoneIds = ZoneId.getAvailableZoneIds(); for (String s: availableZoneIds) { System.out.println(s); } // 通过时区构建LocalDateTime对象 LocalDateTime localDateTimeNow = LocalDateTime.now(ZoneId.of(&quot;Asia/Shanghai&quot;)); // 指定时区构建带时区的日期时间对象 ZonedDateTime zonedDateTime = localDateTimeNow.atZone(ZoneId.of(&quot;Asia/Shanghai&quot;)); System.out.println(localDateTimeNow); // 2019-09-03T10:35:25.677 // 2019-09-03T10:35:25.677+08:00[Asia/Shanghai] 与UTC时间相差8小时 System.out.println(zonedDateTime);} 日期时间API的部分UML图以上介绍的新的日期时间API相关类的UML图如下： 下面这张图能帮助我们更好的理解LocaleDate、 LocalTime、LocalDateTime以及ZoneId之间的差异。","link":"/2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(4)/"}],"tags":[{"name":"年度总结","slug":"年度总结","link":"/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","link":"/tags/IntelliJ-IDEA/"},{"name":"JDK","slug":"JDK","link":"/tags/JDK/"},{"name":"Maven","slug":"Maven","link":"/tags/Maven/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"Windows10","slug":"Windows10","link":"/tags/Windows10/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"GOF","slug":"GOF","link":"/tags/GOF/"},{"name":"Lombok","slug":"Lombok","link":"/tags/Lombok/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"隐式转换","slug":"隐式转换","link":"/tags/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"xxl-job","slug":"xxl-job","link":"/tags/xxl-job/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"Java8","slug":"Java8","link":"/tags/Java8/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"程序员代码面试指南","slug":"程序员代码面试指南","link":"/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"云设计模式","slug":"云设计模式","link":"/tags/%E4%BA%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"方法重载","slug":"方法重载","link":"/tags/%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/"},{"name":"Apache ShardingSphere","slug":"Apache-ShardingSphere","link":"/tags/Apache-ShardingSphere/"}],"categories":[{"name":"年度总结","slug":"年度总结","link":"/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"name":"安装配置","slug":"安装配置","link":"/categories/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java EE","slug":"Java-EE","link":"/categories/Java-EE/"},{"name":"JDK源码解析","slug":"JDK源码解析","link":"/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"MySQL","slug":"数据库/MySQL","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"},{"name":"GOF设计模式","slug":"设计模式/GOF设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/GOF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java SE","slug":"Java-SE","link":"/categories/Java-SE/"},{"name":"Lombok","slug":"Java-EE/Lombok","link":"/categories/Java-EE/Lombok/"},{"name":"JVM","slug":"JVM","link":"/categories/JVM/"},{"name":"中间件","slug":"中间件","link":"/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"运维","slug":"运维","link":"/categories/%E8%BF%90%E7%BB%B4/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"程序员代码面试指南-IT名企算法与数据结构最优解","slug":"算法/程序员代码面试指南-IT名企算法与数据结构最优解","link":"/categories/%E7%AE%97%E6%B3%95/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97-IT%E5%90%8D%E4%BC%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%80%E4%BC%98%E8%A7%A3/"},{"name":"LeetCode","slug":"算法/LeetCode","link":"/categories/%E7%AE%97%E6%B3%95/LeetCode/"},{"name":"行为型","slug":"设计模式/GOF设计模式/行为型","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/GOF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"},{"name":"定时任务","slug":"中间件/定时任务","link":"/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"},{"name":"Docker","slug":"运维/Docker","link":"/categories/%E8%BF%90%E7%BB%B4/Docker/"},{"name":"Nginx","slug":"运维/Nginx","link":"/categories/%E8%BF%90%E7%BB%B4/Nginx/"},{"name":"Java 8实战","slug":"读书笔记/Java-8实战","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java-8%E5%AE%9E%E6%88%98/"},{"name":"简单","slug":"算法/LeetCode/简单","link":"/categories/%E7%AE%97%E6%B3%95/LeetCode/%E7%AE%80%E5%8D%95/"},{"name":"链表","slug":"算法/LeetCode/链表","link":"/categories/%E7%AE%97%E6%B3%95/LeetCode/%E9%93%BE%E8%A1%A8/"},{"name":"云设计模式","slug":"设计模式/云设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Maven","slug":"Java-EE/Maven","link":"/categories/Java-EE/Maven/"},{"name":"分库分表","slug":"中间件/分库分表","link":"/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"}]}