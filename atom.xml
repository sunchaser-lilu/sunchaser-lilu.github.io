<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>向日葵的自我修养</title>
  <icon>https://www.gravatar.com/avatar/a684174a468571d6f45ac289305ed7dc</icon>
  <subtitle>JavaBucket</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lilu.org.cn/"/>
  <updated>2020-05-27T13:11:33.463Z</updated>
  <id>https://lilu.org.cn/</id>
  
  <author>
    <name>SunChaser</name>
    <email>admin@lilu.org.cn</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JDK源码解析之LinkedList</title>
    <link href="https://lilu.org.cn/2020/05/27/javase/base/linkedlist/"/>
    <id>https://lilu.org.cn/2020/05/27/javase/base/linkedlist/</id>
    <published>2020-05-27T13:10:41.476Z</published>
    <updated>2020-05-27T13:11:33.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>LinkedList</code>的底层实现是双向链表，在学习其源码之前，我们首先要搞懂链表的原理。</p><h2 id="单链表简介"><a href="#单链表简介" class="headerlink" title="单链表简介"></a>单链表简介</h2><p>单链表中的数据是以节点的形式来表示的，每个节点存储了当前节点的元素值（数据域）和下一个节点（后继节点）的地址值（指针域）。每个节点的内存空间可以是不连续的，它通过每个节点的指针域将各个节点连接起来。</p><p>每个节点只有一个指针域的链表称为单链表。如果想要遍历单链表，则必须从头节点开始迭代。</p><h2 id="双向链表简介"><a href="#双向链表简介" class="headerlink" title="双向链表简介"></a>双向链表简介</h2><p>双向链表与单链表相比，它的每个节点在单链表的基础上还存储了上一个节点（前驱节点）的地址值。也就是说，我们从任一节点开始，都可以遍历整个链表。</p><h2 id="循环链表简介"><a href="#循环链表简介" class="headerlink" title="循环链表简介"></a>循环链表简介</h2><p>单链表和双链表都可以构造成循环链表，只需将最后一个节点的后继结点指针域指向头节点，形成一个环。因此，从循环链表的任意一个节点开始，都可以遍历整个链表。</p><h2 id="LinkedList简介"><a href="#LinkedList简介" class="headerlink" title="LinkedList简介"></a><code>LinkedList</code>简介</h2><p><code>LinkedList</code>类是基于双向链表实现的，它继承了<code>AbstractSequentialList</code>顺序访问集合抽象模板类，实现了有序集合接口<code>List</code>和双端队列接口<code>Deque</code>。所以，<code>LinkedList</code>即可以作为集合使用，同时可以用作双端队列，还可以用作栈。这是一个非常优秀的实现类。</p><h2 id="LinkedList特性"><a href="#LinkedList特性" class="headerlink" title="LinkedList特性"></a><code>LinkedList</code>特性</h2><p>由于<code>LinkedList</code>类继承自<code>AbstractSequentialList</code>抽象类，而<code>AbstractSequentialList</code>抽象类又继承自<code>AbstractList</code>抽象类。于是<code>LinkedList</code>类得到了<code>AbstractList</code>抽象类的<code>modCount</code>字段。基于该字段实现了<code>fail-fast</code>机制。</p><h2 id="源码详解"><a href="#源码详解" class="headerlink" title="源码详解"></a>源码详解</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义集合的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指向双向链表第一个节点的引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指向双向链表最后一个节点的引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">876323262645176354L</span>;</span><br></pre></td></tr></table></figure><h3 id="Node节点类"><a href="#Node节点类" class="headerlink" title="Node节点类"></a><code>Node</code>节点类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 数据域</span></span><br><span class="line">    E item;</span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    <span class="comment">// 前驱节点</span></span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>遵循了<code>Collection</code>接口的规范：提供了两个标准构造器：<code>void</code>无参构造器和带<code>Collection</code>类型的单个参数构造器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带参构造器：构造一个包含指定集合中元素的链表，其顺序为指定集合迭代器返回的顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无参构造器中没有任何操作。</p><p>带参构造器中首先调用了无参构造器，然后调用<code>addAll(c)</code>方法构造链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该<code>addAll(c)</code>方法是将指定集合<code>c</code>添加至此列表末尾，由于是在构造器中调用，所以<code>size</code>为初始值<code>0</code>。</p><p>我们来看下重载的<code>addAll(size,c)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验索引是否越界</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合转Object数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="comment">// 计算数组长度</span></span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// pred： 插入位置的前驱节点（索引：index - 1）</span></span><br><span class="line">    <span class="comment">// succ： 插入位置的后继节点（索引：index + 1）</span></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        <span class="comment">// 插入位置为末尾</span></span><br><span class="line">        <span class="comment">// 后继节点为null</span></span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 前驱节点为 last</span></span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 插入位置不在末尾，在链表中间</span></span><br><span class="line">        <span class="comment">// 后继节点为 node(index)</span></span><br><span class="line">        succ = node(index);</span><br><span class="line">        <span class="comment">// 前驱节点为后继节点succ的前驱节点</span></span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代Object数组a</span></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="comment">// 强制类型转换</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">        <span class="comment">// 创建一个新的节点newNode：其前驱节点为pred，节点数据域为此次迭代元素e，后继节点为null</span></span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 前驱节点为null：链表初始为空链表；新节点newNode为头节点</span></span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 前驱节点不为null：将pred的后继节点指向newNode</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        <span class="comment">// 将前驱节点置为newNode，以便下次迭代链接节点。</span></span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代完成</span></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 后继节点为null：初始插入位置为链表末尾：将last置为最后一次迭代的pred，即为链表末尾元素。</span></span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 后继节点不为null：从链表中间进行插入：将最后一次迭代的pred元素的后继节点指向succ。</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line">        <span class="comment">// 将succ的前驱节点指向pred。</span></span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 集合大小增加</span></span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是将指定集合插入至指定索引位置，指定索引位置的元素（如果有的话）和后续所有元素都将右移。</p><p>分为两种情况：</p><p>1、 从链表尾部插入</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/jdk/linkedlistaddfromlast.gif"  alt="从链表尾部插入"></p><p>初始条件为：</p><ul><li>初始链表为：<code>[L,I,N]</code></li><li>指定索引位置：<code>index：3</code></li><li>待插入元素集合：<code>collection：[K,E,D]</code></li><li>插入位置的前驱节点：<code>pred：N</code></li><li>插入位置的后继节点：<code>succ：null</code></li></ul><p>插入过程：</p><p>迭代开始：</p><ul><li>待插入集合转数组：<code>a：[K,E,D]</code></li><li>第一次迭代：创建新节点<code>newNode</code>，值为<code>K</code>，前驱节点<code>pred</code>为<code>N</code>，后继节点<code>succ</code>为<code>null</code>，将N的后继节点指向<code>K</code>，将前驱节点<code>pred</code>引用<code>newNode:K</code>。</li><li>第二次迭代：创建新节点<code>newNode</code>，值为<code>E</code>，前驱节点<code>pred</code>为<code>K</code>，后继节点<code>succ</code>为<code>null</code>，将<code>K</code>的后继节点指向<code>E</code>， 将前驱节点<code>pred</code>引用<code>newNode:E</code>。</li><li>第三次迭代：创建新节点<code>newNode</code>，值为<code>D</code>，前驱节点<code>pred</code>为<code>E</code>，后继节点<code>succ</code>为<code>null</code>，将<code>E</code>的后继节点指向<code>D</code>，将前驱节点<code>pred</code>引用<code>newNode:D</code>。</li></ul><p>迭代完成。</p><p>此时后继节点<code>succ</code>仍指向<code>null</code>，前驱节点<code>pred</code>引用<code>newNode:D</code>，为链表末尾节点，将<code>last</code>引用置为<code>pred</code>。</p><p>集合大小增加了数组<code>a</code>的长度个；修改次数<code>modCount</code>增加。</p><p>2、 从链表中间插入</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/jdk/linkedlistaddfrommid.gif"  alt="从链表中间插入"></p><p>初始条件为：</p><ul><li>初始链表为：<code>[L,I,N,D]</code></li><li>指定索引位置：<code>index：3</code></li><li>待插入元素集合：<code>collection：[K,E]</code></li><li>插入位置的前驱节点：<code>pred：N</code></li><li>插入位置的后继节点：<code>succ：D</code></li></ul><p>插入过程：</p><p>迭代开始：</p><ul><li>待插入集合转数组：<code>a：[K,E]</code></li><li>第一次迭代：创建新节点<code>newNode</code>，值为<code>K</code>，前驱节点<code>pred</code>为<code>N</code>，后继节点<code>succ</code>为<code>D</code>，将N的后继节点指向<code>K</code>，将前驱节点<code>pred</code>引用<code>newNode:K</code>。</li><li>第二次迭代：创建新节点<code>newNode</code>，值为<code>E</code>，前驱节点<code>pred</code>为<code>K</code>，后继节点<code>succ</code>为<code>D</code>，将<code>K</code>的后继节点指向<code>E</code>， 将前驱节点<code>pred</code>引用<code>newNode:E</code>。</li></ul><p>迭代完成。</p><p>此时后继节点<code>succ</code>仍指向<code>D</code>，前驱节点<code>pred</code>引用<code>newNode:E</code>，<code>last</code>引用仍指向<code>D</code>。</p><p>将<code>pred</code>的后继节点指向<code>D</code>，将<code>D</code>的前驱节点指向<code>E</code>。</p><p>集合大小增加了数组<code>a</code>的长度个；修改次数<code>modCount</code>增加。</p><h3 id="内部方法"><a href="#内部方法" class="headerlink" title="内部方法"></a>内部方法</h3><p><code>LinkedList</code>类中提供了一些默认或私有方法用来将一个指定元素连接至整个链表。</p><h4 id="连接指定元素作为头节点"><a href="#连接指定元素作为头节点" class="headerlink" title="连接指定元素作为头节点"></a><span id="linkFirst">连接指定元素作为头节点</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取链表头节点f</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">// 创建一个新的节点，其数据域为e，后继节点为链表头节点f。</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    <span class="comment">// 链表头节点引用指向新节点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 旧的头节点为null：原链表为空链表。将尾节点引用last也指向新节点。</span></span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 旧的头节点不为null：新节点将作为整个链表的新的头节点。将旧的头节点的前驱节点指向新节点。</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    <span class="comment">// 集合大小增加</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过头节点引用<code>first</code>获取当前链表头节点<code>f</code>，然后创建一个新的<code>Node</code>节点<code>newNode</code>，其数据域为指定元素<code>e</code>，后继节点为当前链表头节点<code>f</code>；</p><p>然后将头节点引用<code>first</code>指向<code>newNode</code>，判断旧的头节点<code>f</code>是否为<code>null</code>，如果是，则原链表为空链表，将尾节点引用<code>last</code>指向<code>newNode</code>；否则，将旧的头节点<code>f</code>的前驱节点指向<code>newNode</code>。</p><h4 id="连接指定元素作为尾节点"><a href="#连接指定元素作为尾节点" class="headerlink" title="连接指定元素作为尾节点"></a><span id="linkLast">连接指定元素作为尾节点</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取链表尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 创建一个新的节点，其数据域为e，前驱节点为链表尾节点l</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 链表尾节点引用执行新节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 旧的尾节点为null：原链表为空链表。将头节点引用也指向新节点。</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 旧的尾节点不为null：新节点将作为整个链表的新的尾节点。将旧的尾节点的后继节点指向新节点。</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">// 集合大小增加</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过尾节点引用<code>last</code>获取当前链表尾节点<code>l</code>，然后创建一个新的<code>Node</code>节点<code>newNode</code>，其数据域为指定元素<code>e</code>，前驱节点为当前链表尾节点<code>l</code>；</p><p>然后将尾节点引用<code>last</code>指向<code>newNode</code>，判断旧的尾节点<code>l</code>是否为<code>null</code>，如果是，则原链表为空链表，将头节点引用<code>first</code>指向<code>newNode</code>；否则，将旧的尾节点<code>l</code>的后继节点指向<code>newNode</code>。</p><h4 id="在指定节点之前连接指定元素"><a href="#在指定节点之前连接指定元素" class="headerlink" title="在指定节点之前连接指定元素"></a><span id="linkBefore">在指定节点之前连接指定元素</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 约定指定节点succ不为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="comment">// 获取指定节点的前驱节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">// 创建一个新的节点，其数据域为e，前驱节点为指定节点的前驱节点，后继节点为指定节点。</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">// 指定节点的前驱节点指向新节点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 指定节点的旧的前驱节点为null：指定节点为原链表的头节点。新节点将作为新的头节点。</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 指定节点的旧的前驱节点不为null：将指定节点的旧的前驱节点的后继节点指向新节点。</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    <span class="comment">// 集合大小增加</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>约定指定节点<code>succ</code>非空，否则将导致<code>NPE</code>问题。</p><p>首先获取指定节点的前驱节点<code>pred</code>，然后创建一个新的<code>Node</code>节点<code>newNode</code>，其前驱节点为<code>pred</code>，数据域为指定元素<code>e</code>，后继节点为指定节点<code>succ</code>。</p><p>将指定节点<code>succ</code>的前驱节点指向<code>newNode</code>，判断指定节点<code>succ</code>的旧的前驱节点<code>pred</code>是否为<code>null</code>，如果是，则指定节点<code>succ</code>为原链表的头节点，将头节点引用<code>first</code>指向<code>newNode</code>；否则，将旧的前驱节点<code>pred</code>的后继节点指向<code>newNode</code>。</p><h4 id="取消头节点的连接"><a href="#取消头节点的连接" class="headerlink" title="取消头节点的连接"></a>取消头节点的连接</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 约定指定节点f为链表头节点且不为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="comment">// 获取头节点的元素值</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="comment">// 获取头节点的后继节点：即将成为新的头节点。</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    <span class="comment">// 将原头节点的数据域和后继节点置为null。解除对其它对象的引用，便于GC清理。</span></span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">// 将头节点引用指向next</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// next为null：原链表只有一个节点。将尾节点引用置为null。</span></span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// next不为null：将next的前驱节点置为null。取消对原头节点的引用，便于GC清理。</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 集合大小减少</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 返回被剔除的节点元素值。</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>约定指定节点为链表的头节点且非空，否则将导致<code>NPE</code>问题。</p><p>获取头节点的数据域值<code>element</code>和后继节点<code>next</code>，将头节点的数据域和后继节点置为<code>null</code>。解除对原对象的引用，便于<code>GC</code>清理。</p><p>然后将头节点引用<code>first</code>指向<code>next</code>，判断<code>next</code>是否为<code>null</code>，如果是，则原链表只有一个节点，将尾节点引用<code>last</code>置为<code>null</code>；否则，将<code>next</code>节点的前驱节点置为<code>null</code>，取消对原链表头节点的引用。</p><h4 id="取消尾节点的连接"><a href="#取消尾节点的连接" class="headerlink" title="取消尾节点的连接"></a><span id="unlinkLast">取消尾节点的连接</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 约定指定节点l为链表尾节点且不为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="comment">// 获取尾节点的元素值</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="comment">// 获取尾节点的前驱节点：即将成为新的尾节点。</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    <span class="comment">// 将原尾节点的数据域和前驱节点置为null。解除对其它对象的引用，便于GC清理。</span></span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">// 将尾节点引用指向prev</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// prev为null：原链表只有一个节点。将头节点引用置为null。</span></span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// prev不为null：将prev的后继节点置为null。取消对原尾节点的引用，便于GC清理。</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 集合大小减少</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 返回被剔除的节点元素值</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>约定指定节点为链表的尾节点且非空，否则将导致<code>NPE</code>问题。</p><p>获取尾节点的数据域值<code>element</code>和前驱节点<code>prev</code>，将尾节点的数据域和前驱节点置为<code>null</code>。解除对原对象的引用，便于<code>GC</code>清理。</p><p>然后将尾节点引用<code>last</code>指向<code>prev</code>，判断<code>prev</code>是否为<code>null</code>，如果是，则原链表只有一个节点，将头节点引用<code>first</code>置为<code>null</code>；否则，将<code>prev</code>节点的后继节点置为<code>null</code>，取消对原链表尾节点的引用。</p><h4 id="取消指定节点的连接"><a href="#取消指定节点的连接" class="headerlink" title="取消指定节点的连接"></a><span id="unlink">取消指定节点的连接</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 约定指定节点x不为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="comment">// 获取指定节点x的数据域元素</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="comment">// 获取指定节点x的后继节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="comment">// 获取指定节点x的前驱节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 指定节点的前驱节点为null：指定节点为原链表头节点。指定节点的后继节点将作为新的头节点。</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，将指定节点的前驱节点的后继节点指向指定节点的后继节点。</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        <span class="comment">// 指定节点的前驱节点置为null</span></span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 指定节点的后继节点为null：指定节点为原链表尾节点。指定节点的前驱节点将作为新的尾节点。</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，将指定节点的后继节点的前驱节点指向指定节点的前驱节点。</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        <span class="comment">// 指定节点的后继节点置为null</span></span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定节点的数据域元素置为null</span></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 集合大小减少</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 返回被剔除的节点元素值</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>约定指定节点<code>x</code>非空，否则将导致<code>NPE</code>问题。</p><p>分别获取指定节点<code>x</code>的数据域元素<code>element</code>、后继节点<code>next</code>和前驱节点<code>prev</code>。</p><p>如果前驱节点<code>prev</code>为<code>null</code>，则在原链表中，指定节点<code>x</code>为头节点，指定节点的后继节点<code>next</code>将作为新的头节点：将<code>first</code>引用指向后继节点<code>next</code>；否则将前驱节点<code>prev</code>的后继节点指向<code>next</code>，将指定元素<code>x</code>的前驱节点置为<code>null</code>。</p><p>如果后继节点<code>next</code>为<code>null</code>，则在原链表中，指定节点<code>x</code>为尾节点，指定节点的前驱节点<code>prev</code>将作为新的尾节点：将<code>last</code>引用指向前驱节点<code>prev</code>；否则将后继节点<code>next</code>的前驱节点指向<code>prev</code>，将指定元素<code>x</code>的后继节点置为<code>null</code>。</p><p>最后将指定节点<code>x</code>的数据域置为<code>null</code>，解除对象引用，便于<code>GC</code>清理。</p><h4 id="获取指定索引位置的Node节点"><a href="#获取指定索引位置的Node节点" class="headerlink" title="获取指定索引位置的Node节点"></a><span id="node">获取指定索引位置的<code>Node</code>节点</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 约定指定索引合法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="comment">// 二分法</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 指定索引在[0,size/2)之间</span></span><br><span class="line">        <span class="comment">// 获取头节点x</span></span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="comment">// 从0迭代到index，每次迭代将x赋值为x的后继节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="comment">// 迭代完成，x即为指定索引位置的节点</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 指定索引在[size/2,size]之间</span></span><br><span class="line">        <span class="comment">// 获取尾节点 </span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="comment">// 从size-1迭代到index，每次迭代将x赋值为x的前驱节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="comment">// 迭代完成，x即为指定索引位置的节点</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>约定指定索引不会产生越界。</p><p>采用二分法的思想优化时间复杂度，如果指定索引<code>index</code>在<code>[0,size/2)</code>范围内，则从<code>0</code>迭代至<code>index - 1</code>，迭代之前获取头节点<code>x</code>，每次迭代将<code>x</code>赋值为<code>x</code>的后继节点，迭代完成时，<code>x</code>即为指定索引<code>index</code>位置的元素；如果指定索引<code>index</code>在[size/2,size)之间，则从<code>size - 1</code>迭代至<code>index + 1</code>，迭代之前获取尾节点<code>x</code>，每次迭代将<code>x</code>赋值为<code>x</code>的前驱节点，迭代完成时，<code>x</code>即为指定索引<code>index</code>位置的元素。</p><h3 id="集合方法"><a href="#集合方法" class="headerlink" title="集合方法"></a>集合方法</h3><p><code>LinkedList</code>继承了<code>AbstractSequentialList</code>有序集合顺序访问抽象模板类。对集合方法进行了实现，可以作为集合使用。</p><h4 id="添加指定元素至集合末尾"><a href="#添加指定元素至集合末尾" class="headerlink" title="添加指定元素至集合末尾"></a><span id="add">添加指定元素至集合末尾</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用内部方法linkLast(e)</span></span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的最初来源是<code>Collection</code>接口中定义的<code>add(E e)</code>方法。</p><blockquote><p><code>AbstractSequentialList</code>抽象类继承了<code>AbstractList</code>抽象类，在<code>AbstractList</code>抽象类中已经实现了<code>add(E e)</code>方法。它只要求子类去实现<code>add(int index,E e)</code>方法即可实现<code>add(E e)</code>。在<code>LinkedList</code>类中已经提供了<code>add(int index,E e)</code>方法的实现，它为什么还要重写<code>add(E e)</code>方法呢？</p><p>理解：<code>LinkedList</code>作为一个优秀的实现类，它继承/实现了多个接口。在编码开发时，我们经常面向接口编程，例如：<code>List&lt;String&gt; list = new LinkedList&lt;&gt;()</code>。<code>LinkedList</code>类的对象会向上转型为<code>List</code>类。对于实例对象<code>list</code>来说，此时它是一个<code>List</code>，它所具有的方法是<code>List</code>接口中定义的方法，而不是<code>LinkedList</code>类中的方法，所以当我们调用<code>list.add(E e)</code>时，实际上调用的是<code>List</code>类中定义的<code>add(E e)</code>方法，而它的实现是在<code>LinkedList</code>类中。</p><p>也就是说，当我们想把<code>LinkedList</code>作为<code>List</code>集合使用时，我们可以写成：<code>List&lt;String&gt; list = new LinkedList&lt;&gt;()</code>。而当我们想把<code>LinkedList</code>当做<code>Queue</code>队列使用时，我们可以写成<code>Queue&lt;String&gt; queue = new LinkedList&lt;&gt;()</code>。它可以向上转型成任意的父接口（或父接口的父接口），向上转型后，实例对象只拥有转型后的接口中所定义的方法。所以，<code>LinkedList</code>类中对所有父接口中定义的方法都进行了实现，以便向上转型使用。</p><p>这体现了<code>Java</code>的多态机制。</p></blockquote><p>直接调用了内部方法<a href="#linkLast"><code>linkLast(e)</code></a>，在不出现异常的情况下固定返回<code>true</code>。</p><h4 id="在指定索引位置添加指定元素"><a href="#在指定索引位置添加指定元素" class="headerlink" title="在指定索引位置添加指定元素"></a>在指定索引位置添加指定元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验索引是否越界</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        <span class="comment">// 指定索引在集合末尾：调用内部方法连接指定元素至链表末尾</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 指定索引在集合中间：调用内部方法连接指定元素至指定索引位置的节点之前。</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先校验指定索引是否越界，然后判断指定索引是否在集合末尾，如果是，则指定元素为链表的新尾节点，调用内部方法<a href="#linkLast"><code>linkLast(e)</code></a>，将指定元素连接至链表末尾；否则，调用内部方法<a href="#linkBefore"><code>linkBefore(e,node)</code></a>将指定元素连接至指定索引位置的节点之前。</p><h4 id="清空所有元素"><a href="#清空所有元素" class="headerlink" title="清空所有元素"></a>清空所有元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Clearing all of the links between nodes is "unnecessary", but:</span></span><br><span class="line">    <span class="comment">// - helps a generational GC if the discarded nodes inhabit</span></span><br><span class="line">    <span class="comment">//   more than one generation</span></span><br><span class="line">    <span class="comment">// - is sure to free memory even if there is a reachable Iterator</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        <span class="comment">// 迭代：初始x为头节点；迭代结束的条件为：x为null。</span></span><br><span class="line">        <span class="comment">// 获取x的后继节点</span></span><br><span class="line">        Node&lt;E&gt; next = x.next;</span><br><span class="line">        <span class="comment">// 当前x的数据域、后继节点和前驱节点都置为null</span></span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// x赋值为其后继节点，进行下一次迭代。</span></span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清除头尾节点引用</span></span><br><span class="line">    first = last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 重置集合大小</span></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代链表，<code>for</code>循环中获取原链表头节点<code>x</code>，迭代过程中对<code>x</code>进行重新赋值，迭代结束的条件为<code>x</code>为<code>null</code>。</p><p>每次迭代将当前迭代的节点<code>x</code>的数据域、后继节点和前驱节点都置为<code>null</code>，然后将<code>x</code>赋值为<code>x</code>的后继节点，进行下一次迭代，直至<code>x</code>为尾节点。</p><p>迭代完成后清除头尾节点<code>first</code>和<code>last</code>的引用，重置集合大小为<code>0</code>。</p><h4 id="获取指定元素在集合中第一次出现的索引位置"><a href="#获取指定元素在集合中第一次出现的索引位置" class="headerlink" title="获取指定元素在集合中第一次出现的索引位置"></a>获取指定元素在集合中第一次出现的索引位置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 索引记录</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 指定元素为null</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="comment">// 迭代：获取链表头节点x，迭代结束的条件为x为null，每次迭代完成将x赋值为x的后继节点</span></span><br><span class="line">            <span class="comment">// 判断节点x的数据域是否为null：是则找到了指定元素的第一次出现，返回索引记录index；否则，索引增一。</span></span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 指定元素不为null，采用equals方法比较是否相等</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="comment">// 迭代的条件同指定元素为null的情况</span></span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代完成仍未返回：集合中不存在指定元素，返回-1。</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先创建一个索引记录<code>index</code>初始为<code>0</code>，然后迭代链表，分为指定元素为<code>null</code>和非<code>null</code>两种情况，为<code>null</code>则采用<code>==</code>运算符比较；非<code>null</code>则采用<code>equals</code>方法比较是否相等。从链表头节点开始迭代，一旦找到相等的元素，则返回索引<code>index</code>，否则索引增一。如果迭代完成仍未找到指定元素，则返回<code>-1</code>。</p><h4 id="获取指定元素在集合中最后一次出现的索引位置"><a href="#获取指定元素在集合中最后一次出现的索引位置" class="headerlink" title="获取指定元素在集合中最后一次出现的索引位置"></a>获取指定元素在集合中最后一次出现的索引位置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 索引记录初始为集合大小size</span></span><br><span class="line">    <span class="keyword">int</span> index = size;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 指定元素为null，采用==运算符比较</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            <span class="comment">// 迭代：获取链表尾节点x，迭代结束的条件为x为null，每次迭代后将x赋值为x的前驱节点</span></span><br><span class="line">            <span class="comment">// 首先索引记录减一</span></span><br><span class="line">            index--;</span><br><span class="line">            <span class="comment">// 判断节点x的数据域是否为null：是则找到了指定元素的最后一次出现，返回索引记录index；否则，进行下一次迭代。</span></span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 指定元素不为null，采用equals方法比较是否相等</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            <span class="comment">// 迭代的条件同指定元素为null的情况</span></span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代完成仍未返回：集合中不存在指定元素，返回-1。</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先创建一个索引记录<code>index</code>初始为集合大小<code>size</code>，然后迭代链表，分为指定元素为<code>null</code>和非<code>null</code>两种情况，为<code>null</code>则采用<code>==</code>运算符比较；非<code>null</code>则采用<code>equals</code>方法比较是否相等。从链表尾节点开始迭代，迭代一开始就将索引记录减一，然后进行相等比较，一旦找到相等的元素，则返回索引<code>index</code>，否则进行下一次迭代。如果迭代完成仍未找到指定元素，则返回<code>-1</code>。</p><h4 id="判断指定元素是否在集合中至少出现一次"><a href="#判断指定元素是否在集合中至少出现一次" class="headerlink" title="判断指定元素是否在集合中至少出现一次"></a>判断指定元素是否在集合中至少出现一次</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上调用的是<code>indexOf</code>方法寻找指定元素的索引位置，如果返回<code>-1</code>则集合中不存在该指定元素，否则表示指定元素在集合中至少出现过一次。</p><h4 id="获取指定索引位置的元素"><a href="#获取指定索引位置的元素" class="headerlink" title="获取指定索引位置的元素"></a>获取指定索引位置的元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验索引是否越界</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 调用内部方法node(index)获取指定索引位置的节点，取出数据域item返回。</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先校验指定索引是否越界，然后调用内部方法<a href="#node"><code>node(index)</code></a>获取指定索引位置的节点，取出其数据域<code>item</code>返回。</p><h4 id="剔除指定索引位置的元素"><a href="#剔除指定索引位置的元素" class="headerlink" title="剔除指定索引位置的元素"></a><span id="remove">剔除指定索引位置的元素</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验指定索引是否越界</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 调用内部方法node获取指定索引位置节点，再调用内部方法unlink取消此节点的连接</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先校验指定索引是否越界，然后调用内部方法<a href="#node"><code>node(index)</code></a>获取指定索引位置的节点，最后调用内部方法<a href="#unlink"><code>unlink(node)</code></a>取消此节点的连接。</p><h4 id="剔除指定元素的第一次出现"><a href="#剔除指定元素的第一次出现" class="headerlink" title="剔除指定元素的第一次出现"></a><span id="remove">剔除指定元素的第一次出现</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 指定元素为null：从头节点x开始迭代，迭代结束的条件为x为null，每次迭代将x赋值为x的后继节点。</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果找到了null元素，则调用内部方法unlink剔除x元素的连接。</span></span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 指定元素非null</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="comment">// 迭代的条件同指定元素为null的情况，使用equals比较当前迭代元素x与指定元素是否相等。</span></span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代完成都未返回，则集合中无该元素，返回false。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代链表，分为指定元素为<code>null</code>和非<code>null</code>两种情况，为<code>null</code>采用<code>==</code>运算符进行比较，非<code>null</code>则采用<code>equals</code>方法比较是否相等。从链表头节点开始迭代，一旦找到相等的元素，则调用内部方法<a href="#unlink"><code>unlink(node)</code></a>取消该节点的连接，返回<code>true</code>。如果迭代完成时都未找到相等的元素，则返回<code>false</code>。</p><h4 id="覆盖指定索引位置的元素"><a href="#覆盖指定索引位置的元素" class="headerlink" title="覆盖指定索引位置的元素"></a>覆盖指定索引位置的元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验指定索引是否越界</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 获取指定索引位置节点x</span></span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    <span class="comment">// 取出x的数据域</span></span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    <span class="comment">// 给x的数据域赋值为指定元素</span></span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="comment">// 返回x节点旧的数据域</span></span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先校验指定索引是否越界，然后调用内部方法<a href="#node"><code>node(index)</code></a>获取指定索引位置的节点<code>x</code>，取出节点<code>x</code>的数据域，然后为<code>x</code>的数据域重新赋值为指定元素，最后返回节点<code>x</code>旧的数据域。</p><h4 id="获取集合中元素个数"><a href="#获取集合中元素个数" class="headerlink" title="获取集合中元素个数"></a>获取集合中元素个数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接返回<code>size</code>成员变量。</p><h4 id="转换成Object数组"><a href="#转换成Object数组" class="headerlink" title="转换成Object数组"></a>转换成<code>Object</code>数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="comment">// 定义size长度的数组</span></span><br><span class="line">    Object[] result = <span class="keyword">new</span> Object[size];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从头节点x开始迭代，迭代结束的条件为x=null，每次迭代完成将x赋值为x的后继节点</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        <span class="comment">// 填充数组</span></span><br><span class="line">        result[i++] = x.item;</span><br><span class="line">    <span class="comment">// 返回数组</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先定义一个<code>size</code>长度的<code>Object</code>数组，然后从链表头节点开始迭代，每次迭代向<code>Object</code>数组中填充一个元素，迭代完成时数组中的元素即为链表中的全部元素，最后返回数组。</p><h4 id="转换成指定类型数组"><a href="#转换成指定类型数组" class="headerlink" title="转换成指定类型数组"></a>转换成指定类型数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="comment">// 指定数组长度是否小于链表长度</span></span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="comment">// 小于：重新分配一个size长度数组</span></span><br><span class="line">        a = (T[])java.lang.reflect.Array.newInstance(</span><br><span class="line">                            a.getClass().getComponentType(), size);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 返回数组容器</span></span><br><span class="line">    Object[] result = a;</span><br><span class="line">    <span class="comment">// 迭代链表，填充元素。</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        result[i++] = x.item;</span><br><span class="line">    <span class="comment">// 迭代完成，如果指定数组的长度大于链表长度，则将返回数组容器中size索引位置的元素置为null</span></span><br><span class="line">    <span class="comment">// null元素之前为原链表元素，null元素之后为原指定数组元素。</span></span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 数组返回。此时数组中元素类型已由Object强转成泛型T</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入参为泛型数组<code>a</code>，判断入参数组长度是否小于链表长度，小于则重新分配一个链表长度<code>size</code>大小的数组空间。迭代链表，将元素填充至数组，迭代完成时，如果是重新分配的数组空间，则数组中的元素恰好全部为链表中的元素；否则数组中的元素多于链表中的元素，将<code>size</code>索引位置的元素置为<code>null</code>，此时，<code>null</code>元素之前为原链表元素，之后为原入参数组元素。最后返回将<code>Object</code>数组强转成泛型数组。</p><p>此方法可用于将集合中的元素类型转换为指定类型并转换成数组。</p><h3 id="双端队列方法"><a href="#双端队列方法" class="headerlink" title="双端队列方法"></a>双端队列方法</h3><p><code>LinkedList</code>实现了<code>Deque</code>双端队列接口，提供了双端队列的基本实现。</p><h4 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h4><h5 id="入队首"><a href="#入队首" class="headerlink" title="入队首"></a>入队首</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用内部方法<a href="#linkFirst"><code>linkFirst(e)</code></a>连接指定元素<code>e</code>作为新的头节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是调用了内部方法<a href="#linkFirst"><code>linkFirst(e)</code></a>连接指定元素<code>e</code>作为新的头节点。然后返回特殊值<code>true</code>。</p><h5 id="入队尾"><a href="#入队尾" class="headerlink" title="入队尾"></a>入队尾</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用内部方法<a href="#linkLast"><code>linkLast(e)</code></a>连接指定元素<code>e</code>作为新的尾节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是调用了内部方法<a href="#linkLast"><code>linkLast(e)</code></a>连接指定元素<code>e</code>作为新的尾节点。然后返回特殊值<code>true</code>。</p><h4 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h4><h5 id="从队首出队列"><a href="#从队首出队列" class="headerlink" title="从队首出队列"></a>从队首出队列</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取链表头节点，如果头节点为<code>null</code>，则为空队列，抛出<code>NoSuchElementException</code>异常。</p><p>否则调用内部方法<a href="#unlinkFirst"><code>unlinkFirst(e)</code></a>剔除头节点的连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是先获取链表头节点，如果头节点为<code>null</code>，则为空队列，返回<code>null</code>，不会抛出异常；否则调用内部方法<a href="#unlinkFirst"><code>unlinkFirst(e)</code></a>剔除头节点的连接。</p><p>此实现符合<code>Deque</code>接口中的定义：当队列为空队列时，<code>removeFirst()</code>方法抛出异常，而<code>pollFirst()</code>方法返回特殊值<code>null</code>。</p><h5 id="从队尾出队列"><a href="#从队尾出队列" class="headerlink" title="从队尾出队列"></a>从队尾出队列</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取链表尾节点，如果尾节点为<code>null</code>，则为空队列，抛出<code>NoSuchElementException</code>异常。</p><p>否则调用内部方法<a href="#unlinkLast"><code>unlinkLast(e)</code></a>剔除尾节点的连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是先获取链表尾节点，如果尾节点为<code>null</code>，则为空队列，返回<code>null</code>，不会抛出异常；否则调用内部方法<a href="#unlinkLast"><code>unlinkLast(e)</code></a>剔除尾节点的连接。</p><p>此实现也符合<code>Deque</code>接口中的定义：当队列为空队列时，<code>removeLast()</code>方法抛出异常，而<code>pollLast()</code>方法返回特殊值<code>null</code>。</p><h5 id="查询队首元素"><a href="#查询队首元素" class="headerlink" title="查询队首元素"></a><span id="getFirst">查询队首元素</span></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取链表头节点，如果头节点为<code>null</code>，则为空队列，抛出<code>NoSuchElementException</code>异常。否则返回头节点的数据域。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>同样是先获取链表头节点，如果头节点为<code>null</code>，则为空队列，返回<code>null</code>，不会抛出异常；否则返回头节点的数据域。</p><p>此实现也符合<code>Deque</code>接口中的定义：当队列为空队列时，<code>getFirst()</code>方法抛出异常，而<code>peekFirst()</code>方法返回特殊值<code>null</code>。</p><h5 id="查询队尾元素"><a href="#查询队尾元素" class="headerlink" title="查询队尾元素"></a>查询队尾元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取链表尾节点，如果尾节点为<code>null</code>，则为空队列，抛出<code>NoSuchElementException</code>异常。否则返回尾节点的数据域。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是先获取链表尾节点，如果尾节点为<code>null</code>，则为空队列，返回<code>null</code>，不会抛出异常；否则返回尾节点的数据域。</p><p>此实现也符合<code>Deque</code>接口中的定义：当队列为空队列时，<code>getLast()</code>方法抛出异常，而<code>peekLast()</code>方法返回特殊值<code>null</code>。</p><h5 id="删除第一次出现的指定元素"><a href="#删除第一次出现的指定元素" class="headerlink" title="删除第一次出现的指定元素"></a>删除第一次出现的指定元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用集合方法<a href="#remove"><code>remove(o)</code></a>剔除指定元素的第一次出现。</p><h5 id="删除最后一次出现的指定元素"><a href="#删除最后一次出现的指定元素" class="headerlink" title="删除最后一次出现的指定元素"></a>删除最后一次出现的指定元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 指定元素为null</span></span><br><span class="line">        <span class="comment">// 从尾节点开始迭代链表，一旦找到数据域为null的节点，则调用内部方法unlink剔除该节点的连接。</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 指定元素非null，使用equals比较元素是否相等</span></span><br><span class="line">        <span class="comment">// 迭代的条件同指定元素为null的情况</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代完成仍未找到，返回false。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分为指定元素为<code>null</code>和非<code>null</code>两种情况，为<code>null</code>采用<code>==</code>运算符比较，非<code>null</code>采用<code>equals</code>方法比较。从尾节点开始迭代，一旦找到数据域与指定元素相等的节点，则调用内部方法<a href="#unlink"><code>unlink</code></a>剔除该节点的连接。</p><h3 id="普通队列方法"><a href="#普通队列方法" class="headerlink" title="普通队列方法"></a>普通队列方法</h3><p><code>Deque</code>双端队列接口中同样声明了普通队列<code>Queue</code>接口中定义的一系列方法。<code>LinkedList</code>类也对其进行了实现。</p><p><code>Queue</code>接口中定义的方法如下：</p><table><thead><tr><th align="left">action</th><th align="left">throws exception</th><th align="left">returns special value</th></tr></thead><tbody><tr><td align="left">insert</td><td align="left">add(e)</td><td align="left">offer(e)</td></tr><tr><td align="left">remove</td><td align="left">remove()</td><td align="left">poll()</td></tr><tr><td align="left">get head</td><td align="left">element()</td><td align="left">peek()</td></tr></tbody></table><p>它有三组共六个方法，在<code>Queue</code>接口的声明中约定了每组方法中有一个是失败时抛出指定异常，另一个是返回特殊值<code>null</code>或<code>false</code>。</p><p><code>LinkedList</code>类却没有完全遵守<code>Queue</code>接口的约定，所有方法在执行失败时均未抛出指定异常。这是为什么呢？</p><p>在我看来，<code>LinkedList</code>的实现初衷是作为<code>List</code>集合使用（这点可从类名体现出来，它是一种<code>List</code>）。由于其底层数据结构是双向链表，它可以用来实现队列等其它数据结构，所以设计者让<code>LinkedList</code>类实现了队列接口。</p><blockquote><p>是因为双向链表这种数据结构可以用来实现队列，所以才实现队列接口。而不是因为实现了队列接口，才决定使用双向链表这种数据结构。</p></blockquote><h4 id="从队尾入队列"><a href="#从队尾入队列" class="headerlink" title="从队尾入队列"></a>从队尾入队列</h4><p>第一个方法是<code>add(e)</code>，实际上这也是在<code>List</code>接口中定义的方法，它的实现既符合列表的定义，又符合队列的定义。</p><p>详情见集合方法中的<a href="#add"><code>add(e)</code></a>。</p><p>第二个方法是<code>offer(e)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用了<a href="#add"><code>add(e)</code></a>方法。</p><h4 id="从队首出队列-1"><a href="#从队首出队列-1" class="headerlink" title="从队首出队列"></a>从队首出队列</h4><p>第一个方法是<code>remove()</code>，该方法同样也定义在了<code>List</code>接口中，详情见集合方法中的<a href="#remove"><code>remove</code></a>。</p><p>第二个方法是<code>poll()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取链表头节点，如果头节点为<code>null</code>，则为空队列，返回特殊值<code>null</code>；否则调用内部方法<a href="#unlinkFirst"><code>unlinkFirst(f)</code></a>剔除头节点的连接。这符合<code>Queue</code>接口中<code>poll</code>方法的定义。</p><h4 id="查询队首元素-1"><a href="#查询队首元素-1" class="headerlink" title="查询队首元素"></a>查询队首元素</h4><p>第一个方法是<code>element()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用双端队列的<a href="#getFirst"><code>getFirst()</code></a>方法查询队首元素。</p><p>第二个方法是<code>peek()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取链表头节点，如果头节点为<code>null</code>，则为空队列，返回特殊值<code>null</code>；否则返回头节点的数据域。这符合<code>Queue</code>接口中<code>peek</code>方法的定义。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p><code>LinkedList</code>类只提供了列表迭代器的实现，基类<code>AbstractSequentialList</code>类中提供的普通迭代器实现也是列表迭代器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验索引是否越界</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="comment">// 返回从index位置开始的迭代器对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器<code>ListItr</code>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最后一次通过迭代器返回的节点对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastReturned;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前迭代器所持有的节点对象，它将作为迭代的依据，调用previous方法将返回其前驱节点；调用next方法将返回其后继节点。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前迭代器所持有的节点对象的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * fail-fast机制的期望修改次数，初始化为AbstractList#modCount</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带参构造器，构造指定索引位置的列表迭代器。由外部校验索引合法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="comment">// assert isPositionIndex(index);</span></span><br><span class="line">        <span class="comment">// index = size 是合法的，便于从后向前迭代。此时next为尾节点last的后继节点null，可以调用previous方法迭代尾节点。</span></span><br><span class="line">        next = (index == size) ? <span class="keyword">null</span> : node(index);</span><br><span class="line">        nextIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否迭代到了列表末尾</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前nextIndex索引位置的节点元素，且索引右移一位。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// fail-fast</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (!hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="comment">// 记录最后一次通过迭代器返回的节点对象</span></span><br><span class="line">        lastReturned = next;</span><br><span class="line">        <span class="comment">// 当前迭代器所持有的节点对象 赋值 为其后继节点</span></span><br><span class="line">        next = next.next;</span><br><span class="line">        <span class="comment">// 索引右移</span></span><br><span class="line">        nextIndex++;</span><br><span class="line">        <span class="comment">// 返回元素值</span></span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否迭代到了列表开头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前nextIndex索引位置的节点元素，且索引左移一位。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// fail-fast机制</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="comment">// 如果next为null，则初始化该迭代器对象时，构造方法中传入的index=size。</span></span><br><span class="line">        <span class="comment">// 表示从列表尾部开始迭代，将next赋值为尾节点last；否则赋值为其前驱节点。</span></span><br><span class="line">        lastReturned = next = (next == <span class="keyword">null</span>) ? last : next.prev;</span><br><span class="line">        nextIndex--;</span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前迭代索引，其值由构造器初始化。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前迭代索引前一位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 安全地从列表中删除上一次迭代方法（next/previous）返回的节点。</span></span><br><span class="line"><span class="comment">     * 迭代过程中只能调用该方法修改列表，否则将引发fail-fast机制。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// fail-fast机制</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">// 迭代状态校验：调用此remove方法之前必须先调用迭代方法。</span></span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取上次迭代返回节点的后继节点</span></span><br><span class="line">        Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">        <span class="comment">// 剔除lastReturned节点的连接（会导致AbstractList#modCount增加）</span></span><br><span class="line">        unlink(lastReturned);</span><br><span class="line">        <span class="comment">// 从后往前（previous）迭代时，next = lastReturned成立</span></span><br><span class="line">        <span class="keyword">if</span> (next == lastReturned)</span><br><span class="line">            <span class="comment">// 当前迭代器所持有的节点对象赋值为上次迭代返回节点的后继节点</span></span><br><span class="line">            next = lastNext;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 从前往后（next）迭代时，进入else分支，迭代索引减一。</span></span><br><span class="line">            nextIndex--;</span><br><span class="line">        <span class="comment">// 重置迭代器迭代状态，下次调用迭代方法之前不可再调用remove方法。</span></span><br><span class="line">        lastReturned = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 期望修改次数增加</span></span><br><span class="line">        expectedModCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖上次迭代方法返回的节点数据域</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 迭代状态校验</span></span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="comment">// fail-fast机制</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">// 覆盖</span></span><br><span class="line">        lastReturned.item = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在下次调用迭代方法将返回的节点之前连接指定节点e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        lastReturned = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">            linkLast(e);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkBefore(e, next);</span><br><span class="line">        nextIndex++;</span><br><span class="line">        expectedModCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JDK8 新增</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) &#123;</span><br><span class="line">            action.accept(next.item);</span><br><span class="line">            lastReturned = next;</span><br><span class="line">            next = next.next;</span><br><span class="line">            nextIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        checkForComodification();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * fail-fast机制：校验实际修改次数是否等于期望修改次数。不等则立即抛出ConcurrentModificationException异常。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h3><h4 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h4><p>该类提供了深拷贝方法（从<code>LinkedList</code>维度来说可以称为深拷贝）。由于其内部持有的是对象引用，列表中的元素并没有进行“深拷贝”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 克隆实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取一个浅拷贝对象</span></span><br><span class="line">    LinkedList&lt;E&gt; clone = superClone();</span><br><span class="line">    <span class="comment">// 初始化状态</span></span><br><span class="line">    <span class="comment">// Put clone into "virgin" state</span></span><br><span class="line">    clone.first = clone.last = <span class="keyword">null</span>;</span><br><span class="line">    clone.size = <span class="number">0</span>;</span><br><span class="line">    clone.modCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 值填充</span></span><br><span class="line">    <span class="comment">// Initialize clone with our elements</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        clone.add(x.item);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有方法：调用Object#clone浅拷贝</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> LinkedList&lt;E&gt; <span class="title">superClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (LinkedList&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      JDK源码解析之LinkedList顺序访问有序集合实现类
    
    </summary>
    
    
      <category term="JDK源码解析" scheme="https://lilu.org.cn/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="JDK" scheme="https://lilu.org.cn/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码解析之AbstractSequentialList</title>
    <link href="https://lilu.org.cn/2020/05/27/javase/base/abstract-sequential-list/"/>
    <id>https://lilu.org.cn/2020/05/27/javase/base/abstract-sequential-list/</id>
    <published>2020-05-27T13:09:54.711Z</published>
    <updated>2020-05-27T13:10:57.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>AbstractSequentialList</code>类是一个抽象类，它继承了<code>AbstractList</code>抽象类。同样提供了有序集合的骨架实现，但是它是最大程度地减少了支持顺序访问数据的实现类所需的工作。如果需要随机访问数据，优先使用<code>AbstractList</code>抽象类。</p><p>从某种意义上说，该类与<code>AbstractList</code>抽象类相反，该类实现了随机访问方法，而不是像<code>AbstractList</code>抽象类一样抛出异常。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>该抽象类提供了有序集合的骨架实现。让实现类支持顺序访问。</p><p>如果要实现集合，只需继承该类并实现该类的<code>listIterator()</code>抽象方法和<code>AbstractCollection#size()</code>方法；</p><p>如果要实现不可修改的集合，只需继承该类并实现列表迭代器<code>ListIterator</code>的<code>hasNext</code>/<code>next</code>/<code>hasPrevious</code>/<code>previous</code>/<code>index</code>方法。</p><p>如果要实现可修改的集合，在实现不可修改集合的基础上，需要另外实现列表迭代器的<code>set</code>方法；对于可变大小的集合，还需要实现列表迭代器的<code>remove</code>和<code>add</code>方法。</p><p>此外，实现类同样应该遵循<code>Collection</code>接口中提出的规范：必须提供两个标准构造器：<code>void</code>无参构造器和带<code>Collection</code>类型的单个参数的构造器。</p><h2 id="源码详解"><a href="#源码详解" class="headerlink" title="源码详解"></a>源码详解</h2><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractSequentialList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有一个使用<code>protected</code>修饰符修饰的无参构造器。说明该抽象类不允许外部直接实例化使用，因为它只是一个骨架实现，并不提供顺序访问集合的完整功能。</p><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure><p>按正确的顺序返回此列表的列表迭代器，其开始索引为入参<code>index</code>。该类中的其它方法都是基于此抽象方法返回的列表迭代器实现的。</p><h3 id="已实现方法"><a href="#已实现方法" class="headerlink" title="已实现方法"></a>已实现方法</h3><p>所有的已实现方法都传入了索引值，对于客户端而言，看似是随机访问，但内部实现却是顺序访问。</p><h4 id="获取指定索引位置的元素"><a href="#获取指定索引位置的元素" class="headerlink" title="获取指定索引位置的元素"></a>获取指定索引位置的元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listIterator(index).next();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取<code>index</code>索引开始的列表迭代器后调用其<code>next</code>方法获取<code>index</code>索引位置元素返回。</p><h4 id="用指定元素替换指定索引位置的元素"><a href="#用指定元素替换指定索引位置的元素" class="headerlink" title="用指定元素替换指定索引位置的元素"></a>用指定元素替换指定索引位置的元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ListIterator&lt;E&gt; e = listIterator(index);</span><br><span class="line">        E oldVal = e.next();</span><br><span class="line">        e.set(element);</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取<code>index</code>索引开始的列表迭代器后调用其<code>next</code>方法获取<code>index</code>索引位置的旧值，然后调用列表迭代器的<code>set</code>方法，覆盖<code>next</code>方法最后返回的<code>index</code>索引位置的元素，最后返回旧值。</p><h4 id="在指定索引位置插入指定元素"><a href="#在指定索引位置插入指定元素" class="headerlink" title="在指定索引位置插入指定元素"></a>在指定索引位置插入指定元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        listIterator(index).add(element);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此实现会将当前位于<code>index</code>位置的元素（如果有的话）和后续所有元素右移一位（索引增一）。</p><p>首先获取<code>index</code>索引开始的列表迭代器，然后调用列表迭代器的<code>add</code>方法插入指定的元素。</p><p>所以列表迭代器必须实现<code>add</code>方法，否则该方法将抛出<code>UnsupportedOperationException</code>异常。</p><h4 id="删除指定索引位置的元素"><a href="#删除指定索引位置的元素" class="headerlink" title="删除指定索引位置的元素"></a>删除指定索引位置的元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ListIterator&lt;E&gt; e = listIterator(index);</span><br><span class="line">        E outCast = e.next();</span><br><span class="line">        e.remove();</span><br><span class="line">        <span class="keyword">return</span> outCast;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此实现会将<code>index</code>索引位置后续所有元素左移一位（索引减一）。</p><p>首先获取<code>index</code>索引开始的列表迭代器，然后获取<code>index</code>索引位置的旧元素，再调用列表迭代器的<code>remove</code>方法删除元素，最后返回旧元素。</p><p>所以列表迭代器必须实现<code>remove</code>方法，否则该方法将抛出<code>UnsupportedOperationException</code>异常。</p><h4 id="在指定索引位置插入指定集合"><a href="#在指定索引位置插入指定集合" class="headerlink" title="在指定索引位置插入指定集合"></a>在指定索引位置插入指定集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">        ListIterator&lt;E&gt; e1 = listIterator(index);</span><br><span class="line">        Iterator&lt;? extends E&gt; e2 = c.iterator();</span><br><span class="line">        <span class="keyword">while</span> (e2.hasNext()) &#123;</span><br><span class="line">            e1.add(e2.next());</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此实现会将当前位于<code>index</code>索引位置及其后续所有元素右移，指定集合中的元素将以其迭代器返回的顺序显示在当前集合中。</p><p>分别获取当前集合的列表迭代器和指定集合的普通迭代器，迭代指定集合，依次将元素<code>add</code>至当前集合中。</p><p>所以列表迭代器必须实现<code>add</code>方法，否则该方法将抛出<code>UnsupportedOperationException</code>异常。</p><h4 id="获取普通迭代器"><a href="#获取普通迭代器" class="headerlink" title="获取普通迭代器"></a>获取普通迭代器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> listIterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用当前类的抽象方法<code>listIterator()</code>，返回列表迭代器。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>该抽象类提供了顺序访问集合的骨架实现，是<code>LinkedList</code>集合的直接父类。所有实现依托于该类的<code>listIterator()</code>抽象方法。</p>]]></content>
    
    <summary type="html">
    
      JDK源码解析之AbstractSequentialList有序集合顺序访问抽象模板类
    
    </summary>
    
    
      <category term="JDK源码解析" scheme="https://lilu.org.cn/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="JDK" scheme="https://lilu.org.cn/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码解析之Deque</title>
    <link href="https://lilu.org.cn/2020/05/11/javase/base/deque/"/>
    <id>https://lilu.org.cn/2020/05/11/javase/base/deque/</id>
    <published>2020-05-11T12:42:15.499Z</published>
    <updated>2020-05-11T12:47:23.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="双端队列简述"><a href="#双端队列简述" class="headerlink" title="双端队列简述"></a>双端队列简述</h2><p>双端队列是一种更特殊的线性表。普通队列<code>Queue</code>只允许在队首删除元素，在队尾插入元素。而双端队列同时允许在队首和队尾插入和删除元素。</p><h2 id="Deque接口简述"><a href="#Deque接口简述" class="headerlink" title="Deque接口简述"></a><code>Deque</code>接口简述</h2><p><code>Deque</code>接口是<code>Java</code>中的双端队列定义，继承<code>java.util.Queue</code>接口，它提供了操作队首和队尾的六组方法：插入队首/队尾元素、删除队首/队尾元素、提取队首/队尾元素。同<code>Queue</code>接口一样，每组操作都包含两种形式：一种在操作失败时抛出异常；另一种返回特殊的值（<code>null</code>或<code>false</code>）。</p><p>当把双端队列当做普通队列使用时，将出现<code>FIFO</code>（先进先出）行为。继承自<code>Queue</code>接口的方法等同于<code>Deque</code>接口中的特定方法。</p><p>双端队列也可用做<code>LIFO</code>（后进先出）堆栈。应该优先选用此接口，尽量不要使用旧版<code>java.util.Stack</code>类（继承自同步集合<code>Vector</code>）。</p><h2 id="接口详解"><a href="#接口详解" class="headerlink" title="接口详解"></a>接口详解</h2><p>双端队列操作接口：</p><table style="vertical-align:middle; text-align:center;">    <tr>        <th>操作位置</th>        <th colspan="2">队首（Head）</th>        <th colspan="2">队尾（Tail）</th>    </tr>    <tr>        <th>响应</th>        <th>throws exception</th>        <th>special value</th>        <th>throws exception</th>        <th>special value</th>    </tr>    <tr>        <td>insert</td>        <td>addFirst(e)</td>        <td>offerFirst(e)</td>        <td>addLast(e)</td>        <td>offerLast(e)</td>    </tr>    <tr>        <td>remove</td>        <td>removeFirst()</td>        <td>pollFirst()</td>        <td>removeLast()</td>        <td>pollLast()</td>    </tr>    <tr>        <td>get element</td>        <td>getFirst()</td>        <td>peekFirst()</td>        <td>getLast()</td>        <td>peekLast()</td>    </tr></table><h3 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h3><h4 id="入队首"><a href="#入队首" class="headerlink" title="入队首"></a>入队首</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p>插入指定元素至队首，如果成功则返回<code>true</code>，如果达到了当前队列的最大容量限制，则抛出<code>IllegalStateException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p>同样是插入指定元素至队首，如果成功则返回<code>true</code>，如果达到了当前队列的最大容量限制，则返回<code>false</code>。不会抛出异常。</p><p>所以，当使用容量受限的队列时，通常使用<code>offerFirst</code>方法插入指定元素至队首。</p><h4 id="入队尾"><a href="#入队尾" class="headerlink" title="入队尾"></a>入队尾</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p>插入指定元素至队尾，如果成功则返回<code>true</code>，如果达到了当前队列的最大容量限制，则抛出<code>IllegalStateException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p>同样是插入指定元素至队尾，如果成功则返回<code>true</code>，如果达到了当前队列的最大容量限制，则返回<code>false</code>。不会抛出异常。</p><p>所以，当使用容量受限的队列时，通常使用<code>offerLast</code>方法插入指定元素至队尾。</p><h3 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h3><h4 id="从队首出队列"><a href="#从队首出队列" class="headerlink" title="从队首出队列"></a>从队首出队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">removeFirst</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>删除队首第一个元素，如果为空队列，则抛出NoSuchElementException异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">pollFirst</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>同样是删除队首第一个元素，如果为空队列，则返回<code>null</code>。不会抛出异常。</p><h3 id="从队尾出队列"><a href="#从队尾出队列" class="headerlink" title="从队尾出队列"></a>从队尾出队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">removeLast</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>删除队尾第一个元素，如果为空队列，则抛出NoSuchElementException异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">pollLast</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>同样是删除队尾第一个元素，如果为空队列，则返回<code>null</code>。不会抛出异常。</p><h3 id="查询队列元素"><a href="#查询队列元素" class="headerlink" title="查询队列元素"></a>查询队列元素</h3><h4 id="查询队首元素"><a href="#查询队首元素" class="headerlink" title="查询队首元素"></a>查询队首元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">getFirst</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>获取队首元素，如果为空队列，则抛出<code>NoSuchElementException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">peekFirst</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>同样是获取队首元素，如果为空队列，则返回<code>null</code>。不会抛出异常。</p><h4 id="查询队尾元素"><a href="#查询队尾元素" class="headerlink" title="查询队尾元素"></a>查询队尾元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">getLast</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>获取队尾元素，如果为空队列，则抛出<code>NoSuchElementException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">peekLast</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>同样是获取队尾元素，如果为空队列，则返回<code>null</code>。不会抛出异常。</p><h3 id="删除指定元素"><a href="#删除指定元素" class="headerlink" title="删除指定元素"></a>删除指定元素</h3><h4 id="删除第一次出现的指定元素"><a href="#删除第一次出现的指定元素" class="headerlink" title="删除第一次出现的指定元素"></a>删除第一次出现的指定元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span></span>;</span><br></pre></td></tr></table></figure><p>从此双端队列中删除第一次出现的指定元素<code>e</code>。如果从未出现，则队列保持不变。判断队列中的元素与指定元素相等的条件为：<code>o == null ? e == null : o.equals(e)</code>。</p><h4 id="删除最后一次出现的指定元素"><a href="#删除最后一次出现的指定元素" class="headerlink" title="删除最后一次出现的指定元素"></a>删除最后一次出现的指定元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span></span>;</span><br></pre></td></tr></table></figure><p>从此双端队列中删除最后一次出现的指定元素<code>e</code>。如果从未出现，则队列保持不变。判断队列中的元素与指定元素相等的条件为：<code>o == null ? e == null : o.equals(e)</code>。</p><h3 id="作为普通队列"><a href="#作为普通队列" class="headerlink" title="作为普通队列"></a>作为普通队列</h3><p>该双端队列<code>Deque</code>接口同样提供了普通队列<code>Queue</code>的六个操作方法。用作普通队列时，产生<code>FIFO</code>（先进先出）行为，其方法等同于上述双端队列的特定方法。下面是它们的对应关系：</p><table><thead><tr><th align="left">Queue Method</th><th align="left">Equivalent Deque Method</th></tr></thead><tbody><tr><td align="left">add(e)</td><td align="left">addLast(e)</td></tr><tr><td align="left">offer(e)</td><td align="left">offerLast(e)</td></tr><tr><td align="left">remove()</td><td align="left">removeFirst()</td></tr><tr><td align="left">poll()</td><td align="left">pollFirst()</td></tr><tr><td align="left">element()</td><td align="left">getFirst()</td></tr><tr><td align="left">peek()</td><td align="left">peekFirst()</td></tr></tbody></table><p>虽然<code>Deque</code>接口也提供了普通队列的六个操作方法，但我们尽量不要去使用它们，而是使用其对应的方法。</p><p>例如入队列，最好不要调用<code>offer(e)</code>，而是调用<code>offerLast(e)</code>。</p><p>因为当使用<code>offer(e)</code>时，我们还需要思考，<code>offer(e)</code>实际上就是<code>offerLast(e)</code>：从队尾入队列。如果我们直接调用<code>offerLast(e)</code>，一眼就能看出是从队尾入队列。</p><p>所以，使用<code>Deque</code>接口时，推荐明确使用<code>xxxLast</code>/<code>xxxFirst</code>这类方法。</p><h3 id="作为栈"><a href="#作为栈" class="headerlink" title="作为栈"></a>作为栈</h3><p>双端队列可以当做栈（<code>LIFO</code>后进先出）来使用。它提供了遗留类<code>Stack</code>中对栈的基本操作方法。这些方法等同于上述双端队列的特定方法。下面是它们的对应关系：</p><table><thead><tr><th align="left">Stack Method</th><th align="left">Equivalent Deque Method</th></tr></thead><tbody><tr><td align="left">push(e)</td><td align="left">addFirst(e)</td></tr><tr><td align="left">pop()</td><td align="left">removeFirst()</td></tr><tr><td align="left">peek()</td><td align="left">peekFirst()</td></tr></tbody></table><p>当做栈使用时，尽量使用栈的方法：<code>push(e)</code>/<code>pop</code>/<code>peek</code>，不要调用其对应的方法。</p><p>因为遗留类<code>Stack</code>已经存在了，考虑到类库兼容性问题无法将其覆盖，所以在<code>Deque</code>接口中定义了栈的方法，当我们把<code>Deque</code>当做栈使用时，直接调用栈的方法会使语义更加明确。</p><h3 id="作为集合"><a href="#作为集合" class="headerlink" title="作为集合"></a>作为集合</h3><p>由于<code>Deque</code>接口继承了<code>Queue</code>接口，而<code>Queue</code>接口又继承了<code>Collection</code>接口，所以<code>Deque</code>也可作为集合使用。它也定义了一些集合的基本操作。</p><p>判断指定元素<code>o</code>与双端队列中元素<code>e</code>相等的条件为：<code>o == null ? e == null : o.equals(e)</code>。</p><h4 id="删除第一次出现的指定元素-1"><a href="#删除第一次出现的指定元素-1" class="headerlink" title="删除第一次出现的指定元素"></a>删除第一次出现的指定元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br></pre></td></tr></table></figure><p>与<code>Collection</code>接口中定义的类似，删除指定元素在集合中的第一次出现。实际上，该方法等同与<code>removeFirstOccurrence(o)</code>方法。</p><h4 id="判断是否包含指定元素"><a href="#判断是否包含指定元素" class="headerlink" title="判断是否包含指定元素"></a>判断是否包含指定元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br></pre></td></tr></table></figure><p>该双端队列中至少包含一个指定的元素<code>o</code>。</p><h4 id="查询元素个数"><a href="#查询元素个数" class="headerlink" title="查询元素个数"></a>查询元素个数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>返回该双端队列中的元素个数。</p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>提供了两个不同元素顺序的迭代器。</p><h5 id="从队首到队尾的迭代器"><a href="#从队首到队尾的迭代器" class="headerlink" title="从队首到队尾的迭代器"></a>从队首到队尾的迭代器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>迭代器中的元素顺序为双端队列从队首到队尾的元素顺序。</p><h5 id="从队尾到队首的迭代器"><a href="#从队尾到队首的迭代器" class="headerlink" title="从队尾到队首的迭代器"></a>从队尾到队首的迭代器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>以相反的顺序返回迭代器。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Deque</code>接口定义了一个双端队列（<code>Double Ended Queue</code>），它可以从队首或队尾操作元素；也可以当做普通队列<code>Queue</code>使用；同时还可以当做栈<code>Stack</code>来使用。</p>]]></content>
    
    <summary type="html">
    
      JDK源码解析之Deque双端队列
    
    </summary>
    
    
      <category term="JDK源码解析" scheme="https://lilu.org.cn/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="JDK" scheme="https://lilu.org.cn/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码解析之Queue</title>
    <link href="https://lilu.org.cn/2020/05/11/javase/base/queue/"/>
    <id>https://lilu.org.cn/2020/05/11/javase/base/queue/</id>
    <published>2020-05-11T12:41:26.469Z</published>
    <updated>2020-05-11T12:47:23.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="队列简述"><a href="#队列简述" class="headerlink" title="队列简述"></a>队列简述</h2><p>队列是一种特殊的线性表，它具有先进先出（<code>FIFO</code>）的特点，只允许在表的前端（<code>front</code>）进行删除操作，而在表的后端（<code>rear</code>）进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。</p><h2 id="Queue接口简述"><a href="#Queue接口简述" class="headerlink" title="Queue接口简述"></a><code>Queue</code>接口简述</h2><p><code>Queue</code>接口是<code>Java</code>中的队列定义，它也是<code>Java</code>容器中的一员，继承自<code>java.util.Collection</code>接口。<code>Queue</code>接口在<code>Collection</code>接口的基础上定义了三组操作：插入、删除和提取。每组操作都包含两种形式：一种在操作失败时抛出异常；另一种返回特殊的值（<code>null</code>或<code>false</code>）。</p><h2 id="接口详解"><a href="#接口详解" class="headerlink" title="接口详解"></a>接口详解</h2><table><thead><tr><th align="left">action</th><th align="left">throws exception</th><th align="left">returns special value</th></tr></thead><tbody><tr><td align="left">insert</td><td align="left">add(e)</td><td align="left">offer(e)</td></tr><tr><td align="left">remove</td><td align="left">remove()</td><td align="left">poll()</td></tr><tr><td align="left">get head</td><td align="left">element()</td><td align="left">peek()</td></tr></tbody></table><h3 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p>插入指定元素至队尾，如果成功则返回<code>true</code>，如果达到了当前队列的最大容量限制，则抛出<code>IllegalStateException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p>同样是插入指定元素至队尾，如果成功则返回<code>true</code>，如果达到了当前队列的最大容量限制，则返回<code>false</code>。不会抛出异常。</p><p>所以，当使用容量受限的队列时，通常使用<code>offer</code>方法插入元素。</p><h3 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>删除队首第一个元素，如果为空队列，则抛出<code>NoSuchElementException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>同样是删除队首第一个元素，如果为空队列，则返回<code>null</code>。不会抛出异常。</p><h3 id="查询队首元素"><a href="#查询队首元素" class="headerlink" title="查询队首元素"></a>查询队首元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>获取队首元素，如果为空队列，则抛出<code>NoSuchElementException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>同样是获取队首元素，如果为空队列，则返回<code>null</code>。不会抛出异常。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Queue</code>接口实现通常不允许插入<code>null</code>元素，尽管某些实现（例如<code>LinkedList</code>）可以插入<code>null</code>元素，也不应将<code>null</code>插入队列中，因为<code>poll</code>和<code>peek</code>方法会在队列为空队列时返回特殊值<code>null</code>，会产生歧义。</p>]]></content>
    
    <summary type="html">
    
      JDK源码解析之Queue队列
    
    </summary>
    
    
      <category term="JDK源码解析" scheme="https://lilu.org.cn/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="JDK" scheme="https://lilu.org.cn/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码解析之AbstractList</title>
    <link href="https://lilu.org.cn/2020/05/08/javase/base/abstract-list/"/>
    <id>https://lilu.org.cn/2020/05/08/javase/base/abstract-list/</id>
    <published>2020-05-08T13:40:35.812Z</published>
    <updated>2020-05-08T13:16:39.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>AbstractList</code>类是一个抽象类，它继承了<code>AbstractCollection</code>抽象类并实现了<code>List</code>接口。<code>List</code>接口定义了一种有序集合，可以精确控制每个元素的插入位置；而<code>AbstractCollection</code>抽象类提供了两个抽象方法，基于这两个抽象方法提供出了集合的最基本实现。</p><p>所以，<code>AbstractList</code>抽象类提供的是有序集合的骨架实现，用以最大程度地减少支持随机访问数据（例如数组）的实现类所需的工作。而对于顺序访问数据（例如链表），应该优先使用<code>AbstractSequentialList</code>抽象类。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>该抽象类提供了有序集合的骨架实现。让实现类支持随机快速访问。</p><p>如果要实现不可修改的有序集合，只需继承该类并为<code>get</code>和<code>size</code>方法提供实现；如果要实现可修改的有序集合，在实现不可修改的有序集合基础之上，还要另外重写此类的两个重载的<code>set</code>方法（否则将抛出<code>UnsupportedOperationException</code>异常），如果集合的大小是可变的，还要再另外重写两个重载的<code>add</code>方法和一个<code>remove</code>方法。</p><p>此外，实现类同样应该遵循<code>Collection</code>接口中提出的规范：必须提供两个标准构造器：<code>void</code>无参构造器和带<code>Collection</code>类型的单个参数的构造器。</p><p>与其它抽象集合实现不同，此类的实现类不是必须要提供迭代器实现；此类的迭代器和列表迭代器是在“随机访问”方法之上由此类自身进行实现的。</p><p>“随机访问”方法（索引访问）有：</p><ul><li><code>get(int)</code></li><li><code>set(int, Object)</code></li><li><code>set(int, E)</code></li><li><code>add(int Object)</code></li><li><code>add(int, E)</code></li><li><code>remove(int)</code></li></ul><h2 id="源码详解"><a href="#源码详解" class="headerlink" title="源码详解"></a>源码详解</h2><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>只有一个使用<code>protected</code>修饰符修饰的无参构造器。说明该抽象类不允许外部直接实例化使用，因为它只是一个骨架实现，并不提供有序集合的完整功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>只有一个成员变量，表示该列表被结构修改的次数。</p><p>结构修改是指：更改列表大小或以其它方式干扰列表。</p><p>此字段由<code>iterator</code>和<code>listIterator</code>方法返回的迭代器使用。如果在迭代过程中修改了该字段的值，则迭代器将在<code>next</code>、<code>remove</code>和<code>previous</code>方法中抛出<code>ConcurrentModificationException</code>异常。这里就是<code>Java</code>普通集合的<code>fail-fast</code>机制。否则将出现不确定的行为。</p><p>子类对该字段的使用是可选的，当子类需要提供具有<code>fail-fast</code>机制的迭代器（或列表迭代器）时，只需在其<code>add</code>和<code>remove</code>方法中修改该字段的值，一次调用<code>add</code>或<code>remove</code>方法必须修改该值且不超过<code>1</code>。否则迭代器将抛出<code>ConcurrentModificationException</code>异常；当子类不需要提供具有<code>fail-fast</code>机制的迭代器时，可直接忽略该字段。</p><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>该类中只包含一个抽象方法，用于支持随机快速访问（根据索引取值）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="已实现方法"><a href="#已实现方法" class="headerlink" title="已实现方法"></a>已实现方法</h3><p>所有的实现方法都是基于该类的抽象方法或其它已实现方法，大部分实现是基于迭代器的。部分方法中直接抛出<code>UnsupportedOperationException</code>异常，这样的实现表示该方法需要子类进行重写实现。总的来看，该类提供了有序集合的模板实现。下面我们来具体的分析每个方法。</p><h4 id="快速访问"><a href="#快速访问" class="headerlink" title="快速访问"></a>快速访问</h4><h5 id="添加指定元素至列表末尾"><a href="#添加指定元素至列表末尾" class="headerlink" title="添加指定元素至列表末尾"></a>添加指定元素至列表末尾</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    add(size(), e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了重载的<code>add</code>方法，传入<code>size()</code>方法的返回值和指定元素，然后返回<code>true</code>。</p><p>只要重载的<code>add</code>方法中不出现异常，则该<code>add</code>方法始终返回<code>true</code>。</p><p>需要注意的是，支持此操作的列表可能会对可以添加至列表的元素进行限制。例如，某些列表拒绝添加<code>null</code>元素，而另一些对可能添加的元素进行类型限制。所以实现类应在其文档中明确指出对可以添加的元素有哪些限制。</p><h5 id="在指定索引位置添加指定元素"><a href="#在指定索引位置添加指定元素" class="headerlink" title="在指定索引位置添加指定元素"></a>在指定索引位置添加指定元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中直接抛出<code>UnsupportedOperationException</code>异常，是必须要子类重写进行具体实现的。</p><h5 id="用指定元素来覆盖指定索引位置的值"><a href="#用指定元素来覆盖指定索引位置的值" class="headerlink" title="用指定元素来覆盖指定索引位置的值"></a>用指定元素来覆盖指定索引位置的值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中直接抛出<code>UnsupportedOperationException</code>异常，是必须要子类重写进行具体实现的。</p><h5 id="添加指定元素至指定索引位置"><a href="#添加指定元素至指定索引位置" class="headerlink" title="添加指定元素至指定索引位置"></a>添加指定元素至指定索引位置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中直接抛出<code>UnsupportedOperationException</code>异常，是必须要子类重写进行具体实现的。</p><h5 id="删除指定索引位置的元素"><a href="#删除指定索引位置的元素" class="headerlink" title="删除指定索引位置的元素"></a>删除指定索引位置的元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中直接抛出<code>UnsupportedOperationException</code>异常，是必须要子类重写进行具体实现的。</p><h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><h5 id="查询指定元素在列表中第一次出现的索引位置"><a href="#查询指定元素在列表中第一次出现的索引位置" class="headerlink" title="查询指定元素在列表中第一次出现的索引位置"></a>查询指定元素在列表中第一次出现的索引位置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    ListIterator&lt;E&gt; it = listIterator();</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (it.next()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> it.previousIndex();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.next()))</span><br><span class="line">                <span class="keyword">return</span> it.previousIndex();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的实现为：首先调用该类的<code>listIterator()</code>方法获取一个指向列表开头的列表迭代器，然后，从前往后遍历列表，直到第一次找到指定的元素或到达列表的末尾（返回<code>-1</code>）。</p><h5 id="查询指定元素在列表中最后一次出现的索引位置"><a href="#查询指定元素在列表中最后一次出现的索引位置" class="headerlink" title="查询指定元素在列表中最后一次出现的索引位置"></a>查询指定元素在列表中最后一次出现的索引位置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    ListIterator&lt;E&gt; it = listIterator(size());</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasPrevious())</span><br><span class="line">            <span class="keyword">if</span> (it.previous()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> it.nextIndex();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasPrevious())</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.previous()))</span><br><span class="line">                <span class="keyword">return</span> it.nextIndex();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的实现为：首先调用该类的<code>listIterator()</code>方法传入<code>size()</code>方法的返回值（该列表的大小）获取一个指向列表末尾的列表迭代器，然后，从后往前遍历列表，直到第一次找到指定的元素或到达列表的开头（返回<code>-1</code>）。</p><h4 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h4><h5 id="清空列表"><a href="#清空列表" class="headerlink" title="清空列表"></a>清空列表</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    removeRange(<span class="number">0</span>, size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除此列表中的所有元素，内部调用的是<code>removeRange</code>方法。子类必须重写本类的<code>remove</code>或<code>removeRange</code>方法，否则将抛出<code>UnsupportedOperationException</code>异常。</p><p>我们来看下<code>removeRange</code>方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    ListIterator&lt;E&gt; it = listIterator(fromIndex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, n=toIndex-fromIndex; i&lt;n; i++) &#123;</span><br><span class="line">        it.next();</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从该列表中删除索引介于<code>fromIndex</code>和<code>toIndex</code>之间的元素，将<code>toIndex</code>索引后的所有元素左移。当<code>fromIndex</code>等于<code>toIndex</code>时，此方法不会做任何操作。</p><p>入参有两个：</p><ul><li><code>fromIndex</code>：要删除的第一个元素的索引；</li><li><code>toIndex</code>：要删除的最后一个元素之后的索引。</li></ul><p>首先调用<code>listIterator(fromIndex)</code>方法获取位于<code>fromIndex</code>之前的列表迭代器，然后迭代索引区间为<code>[0,toIndex-fromIndex)</code>的元素，在每次迭代过程中，调用<code>ListIterator.next</code>方法获取下一个元素，然后调用<code>ListIterator.remove</code>方法删除当前迭代索引元素，直到删除了整个范围内的元素为止。</p><p>如果<code>ListIterator.remove</code>方法的时间复杂度为<code>O(n)</code>，那么该方法的时间复杂度为<code>O(n^2)</code>。</p><h5 id="将指定集合从指定索引位置开始插入"><a href="#将指定集合从指定索引位置开始插入" class="headerlink" title="将指定集合从指定索引位置开始插入"></a>将指定集合从指定索引位置开始插入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">        add(index++, e);</span><br><span class="line">        modified = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将指定集合<code>c</code>从索引为<code>index</code>的位置开始插入，需要子类实现<code>add(int,E)</code>方法，否则将抛出<code>UnsupportedOperationException</code>异常。</p><p>首先调用<code>rangeCheckForAdd(index)</code>方法校验索引范围（区间为<code>[0,size())</code>），然后迭代指定集合<code>c</code>，使用<code>add(int,E)</code>方法进行插入。</p><p>一般来说，子类会选择重写该方法来提高批量插入效率。</p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><h5 id="普通迭代器"><a href="#普通迭代器" class="headerlink" title="普通迭代器"></a>普通迭代器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接创建内部类<code>Itr</code>的实例对象返回。我们来看下这个内部类<code>Itr</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Index of element to be returned by subsequent call to next.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Index of element returned by most recent call to next or</span></span><br><span class="line"><span class="comment">         * previous.  Reset to -1 if this element is deleted by a call</span></span><br><span class="line"><span class="comment">         * to remove.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The modCount value that the iterator believes that the backing</span></span><br><span class="line"><span class="comment">         * List should have.  If this expectation is violated, the iterator</span></span><br><span class="line"><span class="comment">         * has detected concurrent modification.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = cursor;</span><br><span class="line">                E next = get(i);</span><br><span class="line">                lastRet = i;</span><br><span class="line">                cursor = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AbstractList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">                <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">                    cursor--;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有三个成员变量：</p><ul><li><code>cursor</code>：游标，初始化为<code>0</code>，后续调用该内部类的<code>next</code>方法返回的元素索引。</li><li><code>lastRet</code>：初始化为<code>-1</code>，最近一次调用<code>next</code>或<code>previous</code>方法返回的元素索引。如果一次调用中删除了当前指向的元素，则将其重置为<code>-1</code>。</li><li><code>expectedModCount</code>：期望修改次数，初始化为外部类<code>AbstractList</code>的成员变量<code>modCount</code>，迭代器认为后续迭代过程中列表应该具有的<code>modCount</code>值，如果期望值与实际<code>modCount</code>值不相等，则出现了并发修改的情况。</li></ul><p>有三个公共方法：</p><p>1、判断是否还有下一个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cursor != size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断当前游标是否等于列表大小。<code>size()</code>方法为父类<code>AbstractCollection</code>中的抽象<code>size()</code>方法。</p><p>2、获取当前游标索引指向的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        E next = get(i);</span><br><span class="line">        lastRet = i;</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用当前内部类的<code>checkForComodification()</code>方法校验期望修改次数<code>expectedModCount</code>是否等于实际修改次数<code>modCount</code>。如果不相等，则已出现并发修改，抛出<code>ConcurrentModificationException</code>异常。</p><p>然后调用外部类<code>AbstractList</code>的抽象方法<code>get(int)</code>根据当前游标索引取值，将当前游标值赋给成员变量<code>lastRet</code>，当前游标右移一位，最后返回取到的元素。</p><p>先校验<code>modCount</code>的值，如果在校验通过且代码执行到<code>get(i)</code>之前时有其它线程修改了当前列表的大小，则可能会出现索引越界<code>IndexOutOfBoundsException</code>的异常，此时将其捕获，在<code>catch</code>块中再次进行<code>modCount</code>校验，如果校验不通过，则会直接抛出<code>ConcurrentModificationException</code>异常；但可能在这次校验之前又有其它线程将当前列表还原了，此时校验又会通过，所以在校验之后主动抛出<code>NoSuchElementException</code>异常。</p><p>3、删除最近一次通过<code>next</code>方法获取到的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AbstractList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">            cursor--;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先如果<code>lastRet</code>小于<code>0</code>，则该迭代器的<code>next</code>方法未先调用，抛出<code>IllegalStateException</code>异常。</p><p>然后检查<code>expectedModCount</code>与<code>modCount</code>是否相等，不相等则出现并发修改，抛出<code>ConcurrentModificationException</code>异常。</p><p>接下来调用外部类<code>AbstractList</code>的<code>remove</code>方法，删除上次通过<code>next</code>方法获取到的元素。所以<code>AbstractList</code>的子类必须重写<code>AbstractList</code>类的<code>remove</code>方法。</p><p>删除元素之后，将游标左移一位，此时指向的是删除的元素之后的第一个元素。然后重置<code>lastRet=-1</code>，重新将修改过后的<code>modCount</code>赋给<code>expectedModCount</code>。</p><blockquote><p>解释：</p><p>例如列表<code>A,B,C</code>。</p><p>初始状态：初始游标<code>cursor</code>为<code>0</code>指向元素<code>A</code>，<code>lastRet=-1</code>；</p><p>第一次调用<code>next</code>方法：游标<code>cursor</code>右移一位为<code>1</code>指向元素<code>B</code>，<code>lastRet=0</code>；</p><p>此时调用<code>AbstractList</code>的<code>remove</code>方法：删除索引为<code>lastRet=0</code>的元素<code>A</code>，<code>lastRet=0 &lt; cursor=1</code>，游标左移一位为<code>0</code>指向元素<code>B</code>，重置<code>lastRet=-1</code>并将<code>modCount</code>重新赋值给<code>expectedModCount</code>。</p><p>由于调用过外部类<code>AbstractList</code>的<code>remove</code>方法，此时的<code>modCount</code>值已经修改。</p></blockquote><h5 id="列表迭代器"><a href="#列表迭代器" class="headerlink" title="列表迭代器"></a>列表迭代器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> listIterator(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用<code>listIterator(0)</code>方法返回，我们来看下该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先校验传入索引<code>index</code>范围，然后直接一个返回<code>ListItr</code>的实例对象。我们来看下<code>ListItr</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">            cursor = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">                E previous = get(i);</span><br><span class="line">                lastRet = cursor = i;</span><br><span class="line">                <span class="keyword">return</span> previous;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AbstractList.<span class="keyword">this</span>.set(lastRet, e);</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = cursor;</span><br><span class="line">                AbstractList.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                cursor = i + <span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该类继承了内部类<code>Itr</code>并实现了<code>ListIterator</code>接口。</p><p>继承得到了<code>Itr</code>类的三个属性：<code>cursor</code>、<code>lastRet</code>和<code>expectedModCount</code>。</p><p>只有一个带参构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">    cursor = index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让游标指向传入的索引<code>index</code>。</p><p>重写了<code>ListIterator</code>接口的六个方法，我们来依次看下实现：</p><p>1、判断是否有前一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接判断当前游标<code>cursor</code>是否指向<code>0</code>，为<code>0</code>表示指向列表开始位置，无前一个元素。</p><p>2、获取前一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">        E previous = get(i);</span><br><span class="line">        lastRet = cursor = i;</span><br><span class="line">        <span class="keyword">return</span> previous;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取当前游标指向索引的前一位<code>i</code>，获取其元素值<code>previous</code>，将索引<code>i</code>赋值给游标<code>cursor</code>和最后返回元素索引<code>lastRet</code>，最后返回元素<code>previous</code>。校验逻辑同<code>Itr</code>迭代器的<code>next</code>方法。</p><p>3、获取下一个即将迭代元素索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cursor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接返回游标<code>cursor</code>。</p><p>4、获取即将迭代元素的前一个元素的索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cursor-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接返回游标<code>cursor</code>减一。</p><p>5、用指定元素替换最近一次迭代返回的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AbstractList.<span class="keyword">this</span>.set(lastRet, e);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅能在上次调用<code>next</code>或<code>previous</code>方法之后没有调用迭代器的<code>remove</code>或<code>add</code>方法的情况下才能调用。</p><p>调用了外部抽象类<code>AbstractList</code>的<code>set</code>方法将<code>lastRet</code>索引指向的元素替换成指定元素<code>e</code>，然后将实际<code>modCount</code>赋给期望修改次数<code>expectedModCount</code>。校验逻辑同<code>Itr</code>迭代器的<code>remove</code>方法。</p><p>6、插入指定元素至列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        AbstractList.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将指定元素<code>e</code>插入列表，该元素的插入位置为：<code>next</code>方法返回的元素（如果有元素）之前和<code>previous</code>方法返回的元素（如果有元素）之后。如果列表中本来不包含任何元素，则指定元素<code>e</code>将成为列表中的唯一元素。调用此方法后，<code>nextIndex</code>和<code>previousIndex</code>方法的调用返回值将增加一。</p><p>首先获取当前游标指向索引<code>i</code>，然后调用外部类<code>AbstractList</code>的<code>add</code>方法将指定元素<code>e</code>插入指定索引<code>i</code>位置。将<code>lastRet</code>重置为<code>-1</code>，游标<code>cursor</code>增一，即下次调用<code>next</code>方法将返回指定元素<code>e</code>之后的元素，而调用<code>previous</code>方法将返回指定元素<code>e</code>。最后将实际<code>modCount</code>赋给期望修改次数<code>expectedModCount</code>。校验逻辑同<code>set</code>方法。</p><h4 id="比较和哈希"><a href="#比较和哈希" class="headerlink" title="比较和哈希"></a>比较和哈希</h4><h5 id="equals比较"><a href="#equals比较" class="headerlink" title="equals比较"></a><code>equals</code>比较</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> List))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    ListIterator&lt;E&gt; e1 = listIterator();</span><br><span class="line">    ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator();</span><br><span class="line">    <span class="keyword">while</span> (e1.hasNext() &amp;&amp; e2.hasNext()) &#123;</span><br><span class="line">        E o1 = e1.next();</span><br><span class="line">        Object o2 = e2.next();</span><br><span class="line">        <span class="keyword">if</span> (!(o1==<span class="keyword">null</span> ? o2==<span class="keyword">null</span> : o1.equals(o2)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !(e1.hasNext() || e2.hasNext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较指定对象与此对象是否相等。当且仅当指定对象也是一个列表，且两个列表具有相同的大小，并且两个列表中所有对应的元素也均相等时，返回<code>true</code>。判断两个元素相等的条件为：当且仅当<code>e1 == null ? e2 == null : e1.equals(e2)</code>时，两个元素认为是相等的。</p><p>换句话说，如果两个列表包含相同顺序的相同元素，则将它们定义为相等。</p><p>此实现首先检查指定的对象是否为当前列表（<code>==</code>判断地址是否相等），如果是，则返回<code>true</code>；如果不是，将检查指定对象是否为<code>List</code>类型，如果不是则返回<code>false</code>；如果是，则迭代两个列表，比较相对应的元素对，如果有任何比较返回<code>false</code>，则该方法返回<code>false</code>。如果比较完成后任意一个迭代器还有元素，则返回<code>false</code>（因为两个列表长度不相等），否则迭代完成后将返回<code>true</code>。</p><h5 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a><code>hashCode</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashCode = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : <span class="keyword">this</span>)</span><br><span class="line">        hashCode = <span class="number">31</span>*hashCode + (e==<span class="keyword">null</span> ? <span class="number">0</span> : e.hashCode());</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此实现完全使用<code>List#hashCode</code>方法文档中定义的列表哈希函数的代码。</p>]]></content>
    
    <summary type="html">
    
      JDK源码解析之AbstractList有序集合抽象模板类
    
    </summary>
    
    
      <category term="JDK源码解析" scheme="https://lilu.org.cn/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="JDK" scheme="https://lilu.org.cn/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码解析之List</title>
    <link href="https://lilu.org.cn/2020/05/05/javase/base/list/"/>
    <id>https://lilu.org.cn/2020/05/05/javase/base/list/</id>
    <published>2020-05-05T13:41:46.494Z</published>
    <updated>2020-05-05T13:16:12.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>List</code>接口继承了<code>Collection</code>接口，更精确的定义了一种集合类型。</p><p>该接口定义的是一种有序集合，也称为序列。接口的使用者可以精确控制序列中每个元素的插入位置。可以通过其整数索引（序列中的位置）访问元素，并在序列中搜索元素。</p><p>与<code>Set</code>集合不同，序列通常允许重复的元素（<code>equals</code>比较相等）。并且允许多个<code>null</code>元素。</p><h2 id="主要接口签名"><a href="#主要接口签名" class="headerlink" title="主要接口签名"></a>主要接口签名</h2><p>对于<code>Iterator</code>、<code>add</code>、<code>remove</code>、<code>equals</code>和<code>hashCode</code>方法，序列在<code>Collection</code>接口的定义之外，又增加了一些其它定义。同时为了方便起见，序列中还包含了对继承方法的重新声明。</p><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a><code>hashCode()</code></h3><p><code>Collection</code>接口中的<code>hashCode</code>方法只是定义了返回值是该集合的哈希码（调用的是<code>Object</code>类的<code>hashCode</code>方法）。而<code>List</code>接口明确规定了集合<code>hashCode</code>的计算方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hashCode = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (E e : list)</span><br><span class="line">    hashCode = <span class="number">31</span>*hashCode + (e==<span class="keyword">null</span> ? <span class="number">0</span> : e.hashCode());</span><br></pre></td></tr></table></figure><p>计算每一个元素的<code>hashCode</code>并相加。</p><p>这确保了对于任意两个集合<code>list1</code>和<code>list2</code>，如果满足<code>list1.hashCode() == list2.hashCode()</code>，则<code>list1.equals(list2)</code>一定相等。这符合<code>Object#hashCode</code>的规定。</p><h3 id="equals-Object-o"><a href="#equals-Object-o" class="headerlink" title="equals(Object o)"></a><code>equals(Object o)</code></h3><p><code>Collection</code>接口中的<code>equals</code>方法的定义是指定对象与当前集合是否相等，如果实现类希望不使用默认的<code>Object#equals</code>方法的<code>==</code>比较，那么需要重写该方法。</p><p><code>List</code>接口中重写的<code>equals</code>方法规定了判断指定对象与集合是否相等的逻辑：当且仅当指定的对象也是一个<code>List</code>序列，具有相同的大小，并且两个序列中所有对应位置的元素都相等（相等的条件为：<code>e1 == null ? e2 == null : e1.equals(e2)</code>）。</p><p>换句话说，如果两个序列中相同索引位置的元素都相等，那么这两个序列被定义为相等。</p><p>这个定义确保了<code>equals</code>方法可以在<code>List</code>接口的不同实现类中正常运行。</p><h3 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a><code>add(E e)</code></h3><p><code>Collection</code>接口中的<code>add</code>方法定义了可以向集合中添加元素。而<code>List</code>接口中定义的<code>add</code>方法规定了元素添加的位置：添加到原集合末尾。</p><h3 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a><code>add(int index, E element)</code></h3><p><code>List</code>接口中新增的接口签名，在指定索引位置插入指定元素。如果指定索引位置有元素，该元素及其之后的所有元素整体向后移动一位。</p><h3 id="addAll-Collection-lt-extends-E-gt-c"><a href="#addAll-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll(Collection&lt;? extends E&gt; c)"></a><code>addAll(Collection&lt;? extends E&gt; c)</code></h3><p>同样地，<code>Collection</code>接口中的<code>add</code>方法只是定义了可以向当前集合中插入另一个集合。而<code>List</code>接口明确规定了插入的位置为原集合末尾。</p><h3 id="addAll-int-index-Collection-lt-extends-E-gt-c"><a href="#addAll-int-index-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll(int index, Collection&lt;? extends E&gt; c)"></a><code>addAll(int index, Collection&lt;? extends E&gt; c)</code></h3><p><code>List</code>接口中新增的接口签名，在指定索引位置插入指定集合。如果指定索引位置有元素，该元素及其之后的所有元素整体向后移动指定集合大小位。</p><h3 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a><code>remove(int index)</code></h3><p><code>List</code>接口中新增的接口签名，删除序列中指定索引位置的元素。如果指定索引位置后还有其它元素，则之后的所有元素整体向前移动一位，最后返回被移除的那个元素。</p><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a><code>Iterator</code></h3><p><code>List</code>接口提供了一个称为<code>ListIterator</code>的特殊迭代器，除了允许<code>Iterator</code>接口提供的常规操作外，它还允许元素的插入和替换以及双向访问。提供了一种方式来获取从序列的指定位置开始的序列迭代器。</p><p>定义了以下两个方法获取序列迭代器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure><p>其中重载的带一个参数的<code>listIterator(int index)</code>方法从指定索引位置开始返回序列迭代器，它表示在首次调用<code>ListIterator#next</code>方法时将返回指定索引位置的元素。首次调用<code>ListIterator#previous</code>方法时将返回指定索引减一位置的元素。</p><h2 id="其它特性"><a href="#其它特性" class="headerlink" title="其它特性"></a>其它特性</h2><p><code>List</code>接口定义了四个方法用于对序列元素进行位置（索引）访问。索引从<code>0</code>开始。在某些实现类中，例如<code>LinkedList</code>，这些方法的实现可能在时间上与索引的值成比例增长。因此，如果在编码过程中不知道<code>List</code>的实现类（例如使用反射等）具体是哪个类，则遍历序列可能比通过索引进行索引更加高效。</p><ul><li><code>void add(int index, E element);</code>：在指定索引位置添加指定元素。</li><li><code>E get(int index);</code>：获取指定索引位置的元素。</li><li><code>E remove(int index);</code>：移除指定索引位置的元素。</li><li><code>E set(int index, E element);</code>：给指定索引位置的元素赋值。</li></ul><p>另外，<code>List</code>接口还定义了两个用来搜索指定对象的方法，从性能来看，应谨慎使用这些方法。在许多实现类中，它们的执行效率非常低下。</p><ul><li><code>int indexOf(Object o);</code>：返回指定元素第一次出现在该序列中的索引位置。如果不存在则返回<code>-1</code>。</li><li><code>int lastIndexOf(Object o);</code>：返回指定元素最后一次出现在该序列中的索引位置。如果不存在则返回<code>-1</code>。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>List</code>接口是对<code>Collection</code>接口的进一步定义，明确了一种集合的类型：序列。</p><p>接口中的方法一部分是对父接口方法的重新声明，另一部分是为了对序列这种集合建模而增加的接口。</p><p>我们学习该接口是为了“从上往下”地对集合框架的特性进行认知。</p>]]></content>
    
    <summary type="html">
    
      JDK源码解析之List接口
    
    </summary>
    
    
      <category term="JDK源码解析" scheme="https://lilu.org.cn/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="JDK" scheme="https://lilu.org.cn/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码解析之Collection</title>
    <link href="https://lilu.org.cn/2020/05/05/javase/base/collection/"/>
    <id>https://lilu.org.cn/2020/05/05/javase/base/collection/</id>
    <published>2020-05-05T13:41:18.915Z</published>
    <updated>2020-05-05T13:16:03.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Collection</code>接口是<code>Java</code>容器类库中的顶层接口之一。它概括了序列的概念：一种存放一组对象的方式。</p><p><code>JDK</code>不提供<code>Collection</code>接口的直接实现，而是提供更特殊的子接口的实现，比如<code>Set</code>和<code>List</code>。该接口通常用于传递集合并在需要最大通用性的地方操纵它们。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>所有通用的<code>Collection</code>接口实现类（通常通过其子接口之一来间接实现）应该提供两个标准构造器：</p><ul><li><code>void</code>无参构造器：创建一个空集合。</li><li>带有<code>Collection</code>类型的单个参数的构造器：创建一个新集合，该集合具有与参数相同的元素。</li></ul><p>事实上，后一个构造器允许我们复制任何集合，从而产生所需实现类型的等效集合。</p><p>由于接口无法包含构造器，所以无法强制执行此规范，但是<code>Java</code>平台库中的所有通用<code>Collection</code>实现都遵循了该规范。</p><p>此接口中包含一些“破坏性”方法：修改集合的操作。如果实现类不支持，将抛出<code>UnsupportedOperationException</code>异常。在这种情况下，如果调用对集合没有影响，则可以但不强制要求这些方法抛出<code>UnsupportedOperationException</code>异常。例如，对不可修改的集合调用<code>addAll(Collection c)</code>方法时，如果待添加的集合<code>c</code>为空，则可以但不是必须抛出异常。</p><p>有些集合实现对它们可能包含的元素有限制。例如，有些实现禁止<code>null</code>元素，而有些实现对其元素类型有限制。尝试添加不合法元素会引发未经检查的异常，通常为<code>NullPointerException</code>或<code>ClassCastException</code>。尝试查询不合法元素的存在可能会引发异常，或者可能仅返回<code>false</code>。一些实现类将表现出前者的行为，而某些实现类则表现出后者的行为。更一般的，尝试对不合法元素进行操作，该操作的完成不会导致不合法元素插入集合中，这可能会抛出异常，或者可能会成功，一切都取决于实现类。对于<code>Collection</code>接口的规范来说，这些异常是可选的，并未显式抛出。</p><p>该接口中的许多方法都是根据<code>Object#equals(Object o)</code>方法的术语定义的。例如以下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br></pre></td></tr></table></figure><p>此接口的定义为：当且仅当此集合中至少包含一个元素<code>e</code>，使得<code>o == null ? e == null : o.equals(e)</code>成立。</p><p>不应理解为对集合中所有元素都调用<code>equals</code>方法，找到一个满足条件的就可以返回。实现类可以自由进行优化，从而避免<code>equals</code>频繁调用。例如，可以先比较两个元素的哈希码（<code>Object#hashCode()</code>方法的规范保证了具有不相等哈希码的两个对象一定不相等。）</p><p>简单的说，各种<code>Collection</code>接口实现类都可以自由利用基础方法（<code>Object</code>类的方法），只要实现类认为合适即可。</p><h2 id="接口签名"><a href="#接口签名" class="headerlink" title="接口签名"></a>接口签名</h2><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><ul><li><code>int size()</code>：返回集合中的元素个数，最多为<code>Integer.MAX_VALUE</code>。</li><li><code>boolean isEmpty()</code>：如果集合中不包含任何元素则返回<code>true</code>。</li><li><code>boolean contains(Object o)</code>：当且仅当此集合中至少包含一个元素<code>e</code>使得<code>o == null ? e == null : o.equals(e)</code>成立时返回<code>true</code>。</li><li><code>Iterator&lt;E&gt; iterator()</code>：返回此集合中元素的迭代器。</li><li><code>Object[] toArray()</code>：返回包含此集合中所有元素的数组。如果此集合对由其迭代器返回元素的顺序进行了任何保证，则此方法必须按相同的顺序返回元素。操作返回的数组不会对原集合产生任何影响（安全）。此方法充当基于数组的<code>API</code>和基于集合的<code>API</code>之间的桥梁。</li></ul><h3 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h3><ul><li><code>boolean add(E e)</code>：插入元素<code>e</code>至集合中，如果此集合由于调用该方法发生更改，则返回<code>true</code>；如果集合不允许重复元素，且已经包含<code>e</code>，则返回<code>false</code>。</li><li><code>boolean remove(Object o)</code>：从集合中删除元素<code>o</code>。需满足条件：<code>o == null ? e == null : o.equals(e)</code>。如果存在多个满足条件的元素，则只会删除先找到的那个。</li></ul><h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><ul><li><code>boolean containsAll(Collection&lt;?&gt; c)</code>：如果集合中包含指定集合<code>c</code>中的所有元素，则返回<code>true</code>。</li><li><code>boolean addAll(Collection&lt;? extends E&gt; c)</code>：将指定集合<code>c</code>中的所有元素添加至当前集合中。如果在操作过程中修改了指定的集合<code>c</code>，则此操作的行为是不确定的。</li><li><code>boolean removeAll(Collection&lt;?&gt; c)</code>：删除所有包含在指定集合<code>c</code>中的元素。此调用返回后，当前集合中将不包含与指定集合相同的元素。</li><li><code>boolean retainAll(Collection&lt;?&gt; c)</code>：仅保留此集合中包含在指定集合<code>c</code>中的元素。换句话说，此操作完成后，当前集合与指定集合中的元素完全相同。</li><li><code>void clear()</code>：删除此集合中的全部元素。</li></ul><h3 id="比较和哈希"><a href="#比较和哈希" class="headerlink" title="比较和哈希"></a>比较和哈希</h3><p>该接口重新声明了<code>Object#equals</code>和<code>Object#hashCode</code>方法，强制子类必须实现这两个方法。</p><p><code>Collection</code>接口要求<code>hashCode</code>方法返回该集合的哈希码；<code>equals</code>方法比较指定的对象与该集合是否相等。</p><h3 id="JDK8新增默认方法"><a href="#JDK8新增默认方法" class="headerlink" title="JDK8新增默认方法"></a><code>JDK8</code>新增默认方法</h3><p><code>JDK8</code>的<code>StreamAPI</code>提供的两个方法。在此顶层接口中定义默认实现，表示所有的集合都可以使用流操作。</p><h4 id="获取串行流"><a href="#获取串行流" class="headerlink" title="获取串行流"></a>获取串行流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取并行流"><a href="#获取并行流" class="headerlink" title="获取并行流"></a>获取并行流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      JDK源码解析之Collection接口
    
    </summary>
    
    
      <category term="JDK源码解析" scheme="https://lilu.org.cn/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="JDK" scheme="https://lilu.org.cn/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码解析之AbstractCollection</title>
    <link href="https://lilu.org.cn/2020/05/05/javase/base/abstract-collection/"/>
    <id>https://lilu.org.cn/2020/05/05/javase/base/abstract-collection/</id>
    <published>2020-05-05T13:40:24.602Z</published>
    <updated>2020-05-05T13:16:21.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>java.util.AbstractCollection</code>类是一个抽象类，它实现了<code>Collection</code>接口。从设计模式的角度来看，以<code>Abstract</code>开头的类应该是一个模板方法类。事实也是如此，它提供了对<code>Collection</code>接口的最基本实现。以最大程度地减少实现类所需的工作。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>该抽象类只提供了集合的最基本实现，并未对实现类的特性进行任何限制。</p><p>如果要实现不可修改的集合，只需继承该类并为<code>iterator</code>和<code>size</code>方法提供实现（由<code>iterator</code>方法返回的迭代器必须实现<code>hasNext</code>和<code>next</code>方法）；如果要实现可修改的集合，在实现不可修改集合的基础之上，还要另外重写此类的<code>add</code>方法（否则将抛出<code>UnsupportedOperationException</code>异常），同时由<code>iterator</code>方法返回的迭代器必须另外实现其<code>remove</code>方法。</p><p>此外，实现类同样应该遵循<code>Collection</code>接口中提出的规范：必须提供两个标准构造器：<code>void</code>无参构造器和带<code>Collection</code>类型的单个参数的构造器。</p><p>所有未进行实现的方法都被标记为抽象方法待子类实现。下面我们来看下在该抽象类中是如何对集合进行最基本实现的。</p><h2 id="源码详解"><a href="#源码详解" class="headerlink" title="源码详解"></a>源码详解</h2><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>只有一个使用<code>protected</code>修饰符修饰的无参构造器。说明该抽象类不允许外部直接实例化使用，因为它只是最基本的实现，并不具备集合的完整功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>只有一个静态成员变量，它表明了要分配的数组的最大大小。如果超出此限制可能会导致<code>OutOfMemoryError</code>。</p><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>所有的抽象方法都是待具体子类去实现的方法。一共有两个：</p><ul><li><code>public abstract Iterator&lt;E&gt; iterator();</code>：返回一个迭代器。</li><li><code>public abstract int size();</code>：计算集合大小。</li></ul><h3 id="已实现方法"><a href="#已实现方法" class="headerlink" title="已实现方法"></a>已实现方法</h3><p>所有实现方法都是最基本的实现，当子类有更好的实现方式时完全可以进行重写。</p><h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><h5 id="判断集合是否为空"><a href="#判断集合是否为空" class="headerlink" title="判断集合是否为空"></a>判断集合是否为空</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需判断<code>size()</code>方法计算出的集合大小是否为<code>0</code>即可。由于<code>size()</code>方法是抽象方法，此方法相当于还是交由子类实现。</p><h5 id="判断集合中是否包含指定的元素"><a href="#判断集合中是否包含指定的元素" class="headerlink" title="判断集合中是否包含指定的元素"></a>判断集合中是否包含指定的元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (it.next()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.next()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用抽象的<code>iterator</code>方法获取一个迭代器对象，然后对集合进行迭代遍历。</p><p>分为两种情况，指定的元素为<code>null</code>和非<code>null</code>，如果为<code>null</code>，则使用<code>==</code>运算符比较；如果为非<code>null</code>，则使用<code>equals</code>方法进行比较。</p><p>迭代器对象的<code>hasNext</code>和<code>next</code>方法均由具体子类进行实现。</p><h5 id="将集合转换成对象数组"><a href="#将集合转换成对象数组" class="headerlink" title="将集合转换成对象数组"></a>将集合转换成对象数组</h5><p>将该集合的迭代器返回的所有元素按相同顺序连续存储在数组中，数组索引从<code>0</code>开始。返回的数组长度等于集合元素的数量，即使在迭代过程中此集合的大小发生了改变（并发修改），最终返回的数组也与集合保持一致。</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="comment">// Estimate size of array; be prepared to see more or fewer elements</span></span><br><span class="line">    Object[] r = <span class="keyword">new</span> Object[size()];</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (! it.hasNext()) <span class="comment">// fewer elements than expected</span></span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(r, i);</span><br><span class="line">        r[i] = it.next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> it.hasNext() ? finishToArray(r, it) : r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先创建<code>size()</code>大小的<code>Object</code>数组，调用<code>iterator</code>方法得到集合的迭代器，然后对创建的<code>Object</code>数组进行下标索引遍历：</p><p>正常情况下，在<code>for</code>循环的遍历中，<code>it.hasNext()</code>方法将一直返回<code>true</code>，<code>if</code>条件判断将不会成立，循环完成后，迭代器的<code>hasNext</code>方法将返回<code>false</code>，最终将<code>r</code>数组返回；</p><p>而在并发修改的情况下，会出现迭代过程中集合元素减少的情况，这时<code>if(!it.hasNext())</code>判断成立，将返回<code>Arrays.copyOf(r,i)</code>：拷贝一个新数组，其长度为<code>i</code>；</p><p>同样地，并发修改会造成集合元素增加的情况，<code>for</code>循环遍历原集合长度<code>r.length</code>次后就已经结束了，再返回时进行了三目表达式判断，如果迭代器的<code>hasNext</code>方法返回<code>true</code>（还有下一个元素），则调用<code>finishToArray(r, it)</code>方法并返回。</p><p>下面我们来看下<code>finishToArray</code>方法的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T[] finishToArray(T[] r, Iterator&lt;?&gt; it) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = r.length;</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cap = r.length;</span><br><span class="line">        <span class="keyword">if</span> (i == cap) &#123;</span><br><span class="line">            <span class="keyword">int</span> newCap = cap + (cap &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// overflow-conscious code</span></span><br><span class="line">            <span class="keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">                newCap = hugeCapacity(cap + <span class="number">1</span>);</span><br><span class="line">            r = Arrays.copyOf(r, newCap);</span><br><span class="line">        &#125;</span><br><span class="line">        r[i++] = (T)it.next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// trim if overallocated</span></span><br><span class="line">    <span class="keyword">return</span> (i == r.length) ? r : Arrays.copyOf(r, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入参为原集合的对象数组（并发修改前的集合）和集合的迭代器。</p><p>首先记录原数组的长度为<code>i</code>；</p><p>然后开始迭代，再次记录一次原数组长度，用局部变量<code>cap</code>接收，在第一次迭代时<code>i == cap</code>成立，对<code>cap</code>进行扩容，<code>newCap = cap + (cap &gt;&gt; 1) + 1;</code>：扩容大约为原<code>cap</code>的<code>1.5</code>倍。</p><p>扩容后如果发现大于了定义的静态成员变量<code>MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8</code>时，则进行容量最大化处理：调用<code>hugeCapacity</code>方法。</p><p><code>hugeCapacity</code>方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError</span><br><span class="line">            (<span class="string">"Required array size too large"</span>);</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可看到返回的最大容量为<code>Integer.MAX_VALUE</code>。</p><p>接下来调用<code>r = Arrays.copyOf(r, newCap);</code>，将数组<code>r</code>中的元素拷贝至一个新的容量为<code>newCap</code>的数组中并赋值给<code>r</code>。</p><p>再接下来调用<code>r[i++] = (T)it.next();</code>将集合中的剩余元素（并发修改产生的，索引大于<code>i</code>）填充至新容量的<code>r</code>数组中。</p><p>然后进行下一次的迭代，如果<code>newCap</code>容量的数组仍不能完全填充集合中的剩余元素，则<code>i == cap</code>条件会再次成立，会再次进行扩容，直至完全填充。</p><p>填充完成后，<code>r</code>数组并不是恰好被填满，因为扩容是直接扩容<code>1.5</code>倍，很可能数组末尾没有任何元素，所以在<code>return</code>时利用三目运算符判断<code>i == r.length</code>是否成立，如果成立则表示恰好填满，直接返回<code>r</code>数组；否则调用<code>Arrays.copyOf(r, i)</code>将<code>r</code>数组拷贝至一个新的容量为<code>i</code>的数组中返回。</p><h4 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h4><h5 id="添加元素至集合"><a href="#添加元素至集合" class="headerlink" title="添加元素至集合"></a>添加元素至集合</h5><p>此抽象类直接抛出<code>UnsupportedOperationException</code>异常。由具体子类去重写<code>add</code>方法来实现向集合中添加元素。</p><blockquote><p>添加元素已经属于集合的个性化操作了，不同的集合保存元素的方式不同，添加的方式也不同，在抽象类中不应有任何具体实现。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="从集合中删除指定元素"><a href="#从集合中删除指定元素" class="headerlink" title="从集合中删除指定元素"></a>从集合中删除指定元素</h5><p>此抽象类中没有任何存储集合元素的介质，唯一能接触到集合元素的是迭代器。</p><blockquote><p>这里就体现出迭代器设计模式的好处了：不用去关心子类采用何种算法去实现迭代，只需要知道<code>hasNext</code>方法可判断集合中是否还有元素；<code>next</code>方法可获取到本次迭代的元素即可。</p></blockquote><p>所以删除指定元素利用的是迭代器的删除方法。我们来看下具体代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it.next()==<span class="keyword">null</span>) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.next())) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分为指定元素为<code>null</code>和非<code>null</code>两种情况：<code>null</code>使用<code>==</code>运算符比较；非<code>null</code>使用<code>equals</code>方法比较。最终都会调用迭代器的<code>remove</code>方法删除指定元素。</p><p>所以实现类如果不重写该<code>remove(Object o)</code>方法，则必须在<code>iterator()</code>方法返回的迭代器中实现迭代器的<code>remove</code>方法。否则将抛出<code>UnsupportedOperationException</code>异常。</p><h4 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h4><h5 id="判断是否包含指定集合中的全部元素"><a href="#判断是否包含指定集合中的全部元素" class="headerlink" title="判断是否包含指定集合中的全部元素"></a>判断是否包含指定集合中的全部元素</h5><p>使用迭代器遍历指定集合中的所有元素，遍历过程中调用本抽象类中的<code>contains</code>方法判断是否包含，只要出现一个不包含的情况，返回<code>false</code>，全部包含返回<code>true</code>。</p><blockquote><p>语法糖：JDK5引入的forEach循环实际调用的是迭代器，这是一个语法糖。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object e : c)</span><br><span class="line">        <span class="keyword">if</span> (!contains(e))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加指定集合至当前集合"><a href="#添加指定集合至当前集合" class="headerlink" title="添加指定集合至当前集合"></a>添加指定集合至当前集合</h5><p>使用迭代器迭代指定的集合，并将迭代器返回的每个对象添加至当前集合中。</p><p>由于当前集合的<code>add</code>方法中直接抛出<code>UnsupportedOperationException</code>异常，所以该方法依赖于具体子类的<code>add</code>方法实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c)</span><br><span class="line">        <span class="keyword">if</span> (add(e))</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除指定集合中的全部元素"><a href="#删除指定集合中的全部元素" class="headerlink" title="删除指定集合中的全部元素"></a>删除指定集合中的全部元素</h5><p>使用迭代器遍历当前集合，如果迭代器返回的元素包含在指定集合中，则调用迭代器的<code>remove</code>方法将其从当前集合中删除。</p><p>所以，子类实现的<code>iterator</code>方法返回的迭代器必须包含<code>remove</code>方法实现。否则调用该方法将抛出<code>UnsupportedOperationException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    Iterator&lt;?&gt; it = iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.contains(it.next())) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="从当前集合中删除指定集合之外的全部元素"><a href="#从当前集合中删除指定集合之外的全部元素" class="headerlink" title="从当前集合中删除指定集合之外的全部元素"></a>从当前集合中删除指定集合之外的全部元素</h5><p>使用迭代器遍历当前集合，如果迭代器返回的元素不包含在指定集合中，则调用迭代器的<code>remove</code>方法将其重当前集合中删除。</p><p>所以，子类实现的<code>iterator</code>方法返回的迭代器必须包含<code>remove</code>方法实现。否则调用该方法将抛出<code>UnsupportedOperationException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!c.contains(it.next())) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="清空集合"><a href="#清空集合" class="headerlink" title="清空集合"></a>清空集合</h5><p>在此抽象类中，是使用迭代器遍历当前集合，调用迭代器的<code>remove</code>方法依次删除每个元素。</p><p>但大多数具体实现类会选择重写该方法以提高效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        it.next();</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="转换成字符串"><a href="#转换成字符串" class="headerlink" title="转换成字符串"></a>转换成字符串</h4><p>此方法是重写<code>Object#toString</code>方法，避免在控制台打印集合时打印出集合对象的地址值。其格式为：最外层用方括号<code>[]</code>括起来，方括号中间填充由迭代器返回的元素，顺序为迭代器返回的顺序。相邻元素中间以英文逗号<code>,</code>分隔。每一个元素通过<code>String.valueOf(Object)</code>方法转换成字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="string">'['</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        E e = it.next();</span><br><span class="line">        sb.append(e == <span class="keyword">this</span> ? <span class="string">"(this Collection)"</span> : e);</span><br><span class="line">        <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">            <span class="keyword">return</span> sb.append(<span class="string">']'</span>).toString();</span><br><span class="line">        sb.append(<span class="string">','</span>).append(<span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法是大多数集合的<code>toString</code>方法，具体实现类（例如<code>ArrayList</code>）中并未重写该方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>该抽象类虽然提供了很多方法的实现，但所有的实现都是基于<code>iterator</code>和<code>size</code>这两个方法。从模板方法设计模式的角度看，该类定义了集合操作的算法骨架，具体实现还是得由子类去进行实现。</p>]]></content>
    
    <summary type="html">
    
      JDK源码解析之AbstractCollection抽象模板类
    
    </summary>
    
    
      <category term="JDK源码解析" scheme="https://lilu.org.cn/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="JDK" scheme="https://lilu.org.cn/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码解析之ArrayList</title>
    <link href="https://lilu.org.cn/2020/05/02/javase/base/arraylist/"/>
    <id>https://lilu.org.cn/2020/05/02/javase/base/arraylist/</id>
    <published>2020-05-02T13:40:45.924Z</published>
    <updated>2020-06-01T13:48:42.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>ArrayList</code>底层数据结构是动态数组，与普通的数组相比，它的容量可以动态增长。在添加的元素数量达到一定值时，会触发自动扩容机制，保证集合的可用性。</p><p>它继承了<code>AbstractList</code>抽象类，并实现了<code>List</code>、<a href="/2020/04/26/javase/base/randomaccess/"><code>RandomAccess</code></a>、<a href="/2020/04/26/javase/base/cloneable/"><code>Cloneable</code></a> 和 <a href="/2020/03/21/javase/base/serializable/"><code>java.io.Serializable</code></a>接口。</p><blockquote><p><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/tree/master/java-se/src/main/java/com/sunchaser/javase/collect/reimpllist" target="_blank" rel="noopener"><code>AbstractList</code>抽象类已经实现了<code>List</code>接口，为什么<code>ArrayList</code>还要去实现<code>List</code>接口？</a></p></blockquote><p>由于底层由数组存储元素，其取指定下标位置元素、在集合尾部插入元素和求数组长度的时间复杂度为<code>O(1)</code>；而在指定索引位置插入和删除元素的时间复杂度为<code>O(n)</code>。</p><h2 id="使用分析"><a href="#使用分析" class="headerlink" title="使用分析"></a><span id="useAnalysis">使用分析</span></h2><p>在开发中，我们会经常使用<code>ArrayList</code>来存储对象，例如对数据库批量插入/修改的入参实体集合、数据库的列表查询结果集转换成前端视图模型对象等。一般来说，我们的使用形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 连续添加10个元素</span></span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br><span class="line">list.add(<span class="string">"b"</span>);</span><br><span class="line">list.add(<span class="string">"c"</span>);</span><br><span class="line">list.add(<span class="string">"d"</span>);</span><br><span class="line">list.add(<span class="string">"e"</span>);</span><br><span class="line">list.add(<span class="string">"f"</span>);</span><br><span class="line">list.add(<span class="string">"g"</span>);</span><br><span class="line">list.add(<span class="string">"h"</span>);</span><br><span class="line">list.add(<span class="string">"i"</span>);</span><br><span class="line">list.add(<span class="string">"j"</span>);</span><br><span class="line"><span class="comment">// 添加第11个元素</span></span><br><span class="line">list.add(<span class="string">"k"</span>);</span><br><span class="line"><span class="comment">// do other</span></span><br></pre></td></tr></table></figure><p>这样使用似乎没有任何问题，但这却不是一个匠心程序员该写出来的代码。</p><p>为什么这么说呢？我们知道<code>ArrayList</code>底层是动态数组，那这个数组什么时候进行动态呢？换句话说，数组什么时候会进行扩容？又扩容到多少呢？</p><p>以上代码执行完后到底有没有进行扩容？这些都是问题，让我们带着这些问题来看下面的源码。</p><h2 id="源码详解"><a href="#源码详解" class="headerlink" title="源码详解"></a>源码详解</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于空ArrayList实例的共享空数组实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 共享的空数组实例，用于默认大小的空实例。</span></span><br><span class="line"><span class="comment"> * 将该成员变量与EMPTY_ELEMENTDATA区分开来，以了解添加第一个元素时需要填充多少。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储ArrayList的元素的数组缓冲区。ArrayList的容量是此数组缓冲区的长度。</span></span><br><span class="line"><span class="comment"> * 添加第一个元素时，任何具有elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA的空ArrayList都将扩展为DEFAULT_CAPACITY。</span></span><br><span class="line"><span class="comment"> * 非私有成员以简化嵌套类访问。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList的大小（它包含的元素个数）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配的最大数组大小。某些VM在数组中保留一些标头字。</span></span><br><span class="line"><span class="comment"> * 尝试分配更大的数组可能会导致OutOfMemoryError：请求的数组大小超出VM限制。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><h4 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h4><p>构造一个初始容量为<code>10</code>的空列表。将<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>空列表赋给存储元素的<code>elementData</code>数组缓冲区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有参构造"><a href="#有参构造" class="headerlink" title="有参构造"></a>有参构造</h4><p><code>1</code>、 构造一个具有指定初始容量的空列表。入参<code>initialCapacity</code>为列表的指定初始容量，如果为负数则抛出<code>IllegalArgumentException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建initialCapacity大小的Object类数组。</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 指定容量为0，赋值静态空数组成员变量。</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 负数抛出异常。</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span> + initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>2</code>、 构造一个包含指定集合元素的列表，其顺序由集合的迭代器返回。入参<code>c</code>集合中的元素将被放入此列表，如果集合为<code>null</code>则抛出<code>NullPointerException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 集合转数组赋值给elementData</span></span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="comment">// 集合元素个数不为0。</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray方法返回的可能不是Object[]数组，此处判断如果不为Object[]类型则转换成Object[]类型。</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 赋值静态空数组成员变量。</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组拷贝方法"><a href="#数组拷贝方法" class="headerlink" title="数组拷贝方法"></a>数组拷贝方法</h3><p>由于<code>ArrayList</code>底层使用数组进行元素存储，其很多实现都是对数组进行直接操作。所以在看其它方法之前，很有必要先弄懂一些数组的方法。</p><p><code>java.util.Arrays</code>是<code>JDK</code>提供的一个数组工具类，在<code>ArrayList</code>中大量使用了它的一个静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> original 待拷贝数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newLength 拷贝后新数组的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> original 待拷贝数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newLength 拷贝后新数组的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newType 数组元素类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">// 传入的newType类型是否是Object类型，是则创建Object数组，否则创建指定类型数组。</span></span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">        ? (T[]) new Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    <span class="comment">// native方法</span></span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="comment">// 返回创建的新长度的数组</span></span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将src数组中srcPos索引及其之后的length个元素分别拷贝至dest数组中destPos索引及其之后的length个位置上。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src 源数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcPos 源数组拷贝开始位置索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest 目标数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destPos 目标数组拷贝开始位置索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 拷贝的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p><code>ArrayList</code>提供了两个重载的<code>add</code>插入方法。第一个是将指定元素添加至列表末尾；第二个是将指定元素添加至指定位置；同时还提供了两个重载的<code>addAll</code>方法，用来批量插入。</p><h4 id="插入至列表末尾"><a href="#插入至列表末尾" class="headerlink" title="插入至列表末尾"></a>插入至列表末尾</h4><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里我们可以对<a href="#useAnalysis"><code>使用分析</code></a>中的示例代码进行分析了：</p><p>首先使用<code>new</code>关键字调用无参构造器初始化一个<code>ArrayList</code>集合对象，我们知道其实质是将<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>空列表赋给存储元素的<code>elementData</code>数组缓冲区。创建出的<code>list</code>对象的<code>size</code>成员变量初始化为<code>0</code>，然后调用<code>list</code>对象的<code>add</code>方法添加元素。</p><p>第一次调用：<code>list.add(&quot;a&quot;);</code></p><p>在<code>add</code>方法中首先调用<code>ensureCapacityInternal</code>方法，确保内部容量，然后将传入的元素赋值给<code>elementData</code>数据域末尾。最后返回<code>true</code>。</p><p>确保内部容量<code>ensureCapacityInternal</code>方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次调用<code>add</code>方法时：<code>elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>（构造器中初始化），<code>minCapacity = size + 1</code>（其值为<code>1</code>）。</p><p>调用<code>calculateCapacity(elementData, minCapacity)</code>方法计算容量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// new ArrayList&lt;&gt;() 时，初始化为 elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时<code>elementData</code>等于<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>，返回<code>DEFAULT_CAPACITY</code>（其值为<code>10</code>）和<code>minCapacity</code>（其值为<code>1</code>）中较大的值，即返回<code>10</code>。</p><p>随即调用了<code>ensureExplicitCapacity(10)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先增加当前集合的修改次数。然后判断计算出的容量是否超出了当前<code>elementData</code>数组长度，如果超过则进行<code>grow</code>扩容。</p><p>在第一次调用<code>add</code>方法时显然超过了，进行扩容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">// 旧的容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 新容量为原来的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 新容量小于传入的计算出的容量，则新容量为传入容量。</span></span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 新容量超过了最大值，则计算最大容量</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    <span class="comment">// 数组内容拷贝</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容流程为：</p><ul><li>获取旧容量<code>oldCapacity</code>；</li><li>计算新容量，利用位运算（速度远超整除运算）得到旧容量的一半再加上旧容量，即扩容<code>1.5</code>倍；</li><li>检查新容量是否小于传入的计算容量<code>minCapacity</code>，如果小于，则将传入的容量作为新容量；</li><li>检查得到的新容量是否大于<code>ArrayList</code>定义的所能容纳的最大容量：<code>Integer,MAX_VALUE - 8</code>；</li><li>如果大于，则调用<code>hugeCapacity(minCapacity)</code>计算最大容量：如果<code>minCapacity</code>大于<code>Integer.MAX_VALUE - 8</code>，则最大容量为<code>Integer.MAX_VALUE</code>，否则为<code>Integer.MAX_VALUE - 8</code>。</li><li>最后调用<code>Arrays.copyOf(elementData, newCapacity)</code>进行数组拷贝，得到一个以新容量为长度的数组对象并赋值给<code>elementData</code>。</li></ul><p>第一次调用<code>add</code>方法时，旧容量<code>oldCapacity = 0</code>，通过位运算计算出的新容量也为<code>0</code>，所以最后新容量<code>newCapacity = minCapacity</code>，等于<code>10</code>。</p><blockquote><p>所以我们使用<code>new</code>关键字调用无参构造器创建<code>ArrayList</code>对象时，实际上只初始化了一个空数组，在第一次调用<code>add</code>方法时才会进行空数组的扩容。</p></blockquote><p>扩容完成后，<code>elementData</code>数组容量充足，可以往其末尾添加元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elementData[size++] = e;</span><br></pre></td></tr></table></figure><p>像<a href="#useAnalysis"><code>使用分析</code></a>中的示例代码一样，我们不断地向其中添加元素，当添加的元素个数不超过<code>10</code>时，<code>ensureExplicitCapacity(int minCapacity)</code>方法判断<code>minCapacity - elementData.length</code>始终小于<code>0</code>（经过第一次扩容后<code>elementData.length</code>的值为<code>10</code>），不会进行<code>grow</code>扩容; 而当添加至第<code>11</code>个元素<code>k</code>时，情况发生变化：</p><ul><li><code>calculateCapacity(elementData, minCapacity)</code>方法直接返回<code>minCapacity = 11</code>；</li><li>然后调用<code>ensureExplicitCapacity(int minCapacity)</code>方法，此时<code>elementData</code>数组长度为<code>10</code>，<code>minCapacity - elementData.length</code>大于<code>0</code>，将再次进行<code>grow</code>扩容。</li></ul><p>而扩容的流程我们知道，会调用<code>Arrays.copyOf(elementData, newCapacity)</code>方法进行数组拷贝，会有性能损耗。</p><p>所以，具有匠心的代码应该像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定初始容量的构造</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">11</span>);</span><br><span class="line"><span class="comment">// 连续添加10个元素</span></span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br><span class="line">list.add(<span class="string">"b"</span>);</span><br><span class="line">list.add(<span class="string">"c"</span>);</span><br><span class="line">list.add(<span class="string">"d"</span>);</span><br><span class="line">list.add(<span class="string">"e"</span>);</span><br><span class="line">list.add(<span class="string">"f"</span>);</span><br><span class="line">list.add(<span class="string">"g"</span>);</span><br><span class="line">list.add(<span class="string">"h"</span>);</span><br><span class="line">list.add(<span class="string">"i"</span>);</span><br><span class="line">list.add(<span class="string">"j"</span>);</span><br><span class="line"><span class="comment">// 添加第11个元素</span></span><br><span class="line">list.add(<span class="string">"k"</span>);</span><br><span class="line"><span class="comment">// do other</span></span><br></pre></td></tr></table></figure><p>调用指定初始容量的构造器，在创建<code>list</code>对象时就会对<code>elementData</code>数组进行初始化，而不是在第一次调用<code>add</code>方法时。</p><p>所以如果能提前预估到集合容量，尽量提前指定容量，避免频繁的扩容带来的性能损耗。</p><blockquote><p>根据使用场景，如果集合的数据量不好预估，且只会对其进行增删操作，则不建议使用<code>ArrayList</code>集合，而是建议使用<code>LinkedList</code>集合。</p></blockquote><h4 id="插入至指定位置"><a href="#插入至指定位置" class="headerlink" title="插入至指定位置"></a>插入至指定位置</h4><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 待插入元素的指定的位置的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 待插入的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验索引是否越界</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">// 确保容量，修改modCount值</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 数组拷贝：将[index,size)索引区间的元素整体向后移动一个单位，将集合的`index`位置留空。</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    <span class="comment">// 给index索引位置赋值为待插入元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// 集合大小增加</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="将一个集合全部元素插入至当前集合末尾"><a href="#将一个集合全部元素插入至当前集合末尾" class="headerlink" title="将一个集合全部元素插入至当前集合末尾"></a>将一个集合全部元素插入至当前集合末尾</h4><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 集合转数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="comment">// 待添加元素个数</span></span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="comment">// 确保容量</span></span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    <span class="comment">// 数组拷贝</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    <span class="comment">// 集合大小增加</span></span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="comment">// 传入集合无元素则返回false，否则返回true。</span></span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将传入的集合<code>c</code>转为<code>Object[]</code>对象数组，调用<code>Collection</code>的<code>toArray()</code>方法，不管是哪种集合的实现，最终都会返回一个数组。以下是<code>ArrayList</code>类的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用工具类的方法<code>Arrays.copyOf</code>方法进行数组拷贝，返回一个<code>Object[]</code>数组。</p><h4 id="从当前集合指定索引位置开始，将一个集合全部元素插入"><a href="#从当前集合指定索引位置开始，将一个集合全部元素插入" class="headerlink" title="从当前集合指定索引位置开始，将一个集合全部元素插入"></a>从当前集合指定索引位置开始，将一个集合全部元素插入</h4><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 待插入集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验索引是否越界</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">// 集合转Object数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="comment">// 待插入集合元素个数</span></span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="comment">// 确保容量</span></span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    <span class="comment">// 需要移动的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 不是从末尾添加，则将[index,size)索引上的元素整体向后移动numMoved个单位。</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// Object数组拷贝至elementData</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    <span class="comment">// 集合大小增加</span></span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="comment">// 传入集合无元素则返回false，否则返回true。</span></span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>删除集合中的元素有多种情况：删除指定索引位置元素/删除指定元素/删除指定索引范围内的元素/删除全部元素/指定条件删除（<code>Java8</code>新增）等。</p><h4 id="删除指定索引位置元素"><a href="#删除指定索引位置元素" class="headerlink" title="删除指定索引位置元素"></a>删除指定索引位置元素</h4><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除指定索引位置的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验索引是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 获取旧的index索引位置元素值</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="comment">// 计算需要移动的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 移动元素：[index+1,size)索引区间的元素整体向前移动一个单位。</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 清除末尾索引原有的引用，减小集合大小</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="comment">// 返回被删除的元素值</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么判断<code>size - index - 1 &gt; 0</code>？</p><p>答：集合大小<code>size</code>是从<code>1</code>开始计算，而数组下标索引<code>index</code>是从<code>0</code>开始计算。</p></blockquote><h4 id="删除指定元素"><a href="#删除指定元素" class="headerlink" title="删除指定元素"></a>删除指定元素</h4><p>由于<code>ArrayList</code>集合中的元素可以重复，指定的元素可能在集合中出现多次，所以该方法删除的是指定元素在集合中第一次出现位置的元素。</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 指定元素为null：==运算符比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非null：equals方法比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>fori</code>循环是从索引为<code>0</code>开始遍历，所以删除的是具有最低索引的元素。</p></blockquote><p>我们来看下<code>fastRemove(index);</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 计算需要移动的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 移动元素：[index+1,size)索引区间元素整体向前移动一位。</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 清除末尾索引原有的引用，减小集合大小</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除指定索引范围内的元素"><a href="#删除指定索引范围内的元素" class="headerlink" title="删除指定索引范围内的元素"></a>删除指定索引范围内的元素</h4><p>该方法为<code>ArrayList</code>类中受保护的方法，外部无法直接进行调用。由<code>JDK</code>集合框架内部进行使用。</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 约定 fromIndex 小于 toIndex，否则，进行元素移动时会出现索引越界。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromIndex 开始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toIndex 结束索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 计算需要移动的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - toIndex;</span><br><span class="line">    <span class="comment">// 移动元素：[toIndex,size)索引区间元素整体向前移动toIndex - fromIndex个单位。</span></span><br><span class="line">    System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                     numMoved);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="comment">// 计算新的数组大小</span></span><br><span class="line">    <span class="keyword">int</span> newSize = size - (toIndex-fromIndex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 清除删除的索引位置原有的引用</span></span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指定新的数组大小</span></span><br><span class="line">    size = newSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除全部元素"><a href="#删除全部元素" class="headerlink" title="删除全部元素"></a>删除全部元素</h4><p>有两种情况：一种是删除当前集合全部元素，方法为<code>clear()</code>；另一种是从当前集合中删除指定集合中包含的所有元素，方法为<code>removeAll(Collection&lt;?&gt; c)</code>。</p><p><code>clear()</code>方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="comment">// 清除所有索引位置的引用对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 集合大小置0</span></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>removeAll(Collection&lt;?&gt; c)</code>方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 非空</span></span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，调用<code>Java8</code>提供的<code>Objects.requireNonNull(c);</code>方法对传入的集合<code>c</code>进行非空校验。</p><p>然后，调用私有方法<code>batchRemove(c, false)</code>，传入集合<code>c</code>和布尔值<code>false</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                elementData[w++] = elementData[r];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">        <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">            <span class="comment">// clear to let GC do its work</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">            modCount += size - w;</span><br><span class="line">            size = w;</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来写一个简单的<code>demo</code>来看下其过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; removeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    removeList.add(<span class="number">1</span>);</span><br><span class="line">    removeList.add(<span class="number">2</span>);</span><br><span class="line">    removeList.add(<span class="number">3</span>);</span><br><span class="line">    removeList.add(<span class="number">4</span>);</span><br><span class="line">    removeList.add(<span class="number">5</span>);</span><br><span class="line">    removeList.add(<span class="number">6</span>);</span><br><span class="line">    List&lt;Integer&gt; beRemovedList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    beRemovedList.add(<span class="number">3</span>);</span><br><span class="line">    beRemovedList.add(<span class="number">4</span>);</span><br><span class="line">    beRemovedList.add(<span class="number">6</span>);</span><br><span class="line">    System.out.println(removeList);</span><br><span class="line">    System.out.println(beRemovedList);</span><br><span class="line">    removeList.removeAll(beRemovedList);</span><br><span class="line">    System.out.println(removeList);</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>创建一个<code>removeList</code>集合并初始化六个元素，再创建一个待删除的<code>beRemovedList</code>集合并初始化三个元素（在<code>removeList</code>中）。</p><p>下面我们来分析<code>removeAll</code>方法的具体执行流程：</p><p>当我们调用<code>removeList.removeAll(beRemovedList);</code>时，会先对<code>beRemovedList</code>进行非空校验，然后调用<code>batchRemove</code>方法：</p><p>1、使用局部最终变量<code>elementData</code>指向当前集合（<code>removeList</code>）的引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br></pre></td></tr></table></figure><p>2、定义两个索引并初始化为<code>0</code>，以及定义一个布尔值用来记录当前集合是否被修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>3、从<code>r</code>到<code>size</code>进行遍历，判断传入的集合<code>c</code>是否包含<code>r</code>位置的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">    <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">        elementData[w++] = elementData[r];</span><br></pre></td></tr></table></figure><p>我们对着我们的<code>demo</code>程序进行分析，<code>c = {3, 4, 6}</code>，<code>elementData = {1, 2, 3, 4, 5, 6}</code>，<code>size=6</code>，<code>complement = false</code>。</p><p>每次循环<code>r</code>的值增一，循环结束的条件为<code>r &lt; size</code>不成立，即当<code>r = size</code>时循环结束。</p><ul><li>第一次循环：<code>r = 0</code>，<code>elementData[r] = 1</code>，<code>c.contains(1) = false</code>。<code>if</code>条件成立，<code>w = 0</code>。将<code>elementData[r]</code>赋值给<code>elementData[w++]</code>：即将当前不在<code>c</code>集合中的元素赋值到集合的第<code>0</code>位置，随后<code>w</code>增一。此时<code>elementData</code>的第<code>0</code>位置元素为：<code>1</code>。</li><li>第二次循环：<code>r = 1</code>，<code>elementData[r] = 2</code>，<code>c.contains(2) = false</code>。<code>if</code>条件成立，<code>w = 1</code>。将<code>elementData[r]</code>赋值给<code>elementData[w++]</code>：即将当前不在<code>c</code>集合中的元素赋值到集合的第<code>1</code>位置，随后<code>w</code>增一。此时<code>elementData</code>的第<code>1</code>位置元素为：<code>2</code>。</li><li>第三次循环：<code>r = 2</code>，<code>elementData[r] = 3</code>，<code>c.contains(3) = true</code>。<code>if</code>条件不成立，<code>w</code>的值为<code>2</code>，不做任何操作。</li><li>第四次循环：<code>r = 3</code>，<code>elementData[r] = 4</code>，<code>c.contains(4) = true</code>。<code>if</code>条件不成立，<code>w</code>的值为<code>2</code>，不做任何操作。</li><li>第五次循环：<code>r = 4</code>，<code>elementData[r] = 5</code>，<code>c.contains(5) = false</code>。<code>if</code>条件成立，<code>w = 2</code>，将<code>elementData[r]</code>赋值给<code>elementData[w++]</code>：即将当前不在<code>c</code>集合中的元素赋值到集合的第<code>2</code>位置，随后<code>w</code>增一。此时<code>elementData</code>的第<code>2</code>位置元素为：<code>5</code>。</li><li>第六次循环：<code>r = 5</code>，<code>elementData[r] = 6</code>，<code>c.contains(6) = true</code>。<code>if</code>条件不成立，<code>w</code>的值为<code>3</code>，不做任何操作。</li></ul><p>循环结束，<code>w = 3</code>，<code>elementData = {1, 2, 5, ......}</code>，<code>r = 6</code>。</p><p>接下来我们来看下<code>finally</code>块中的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line"><span class="comment">// even if c.contains() throws.</span></span><br><span class="line"><span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">    System.arraycopy(elementData, r,elementData, w,size - r);</span><br><span class="line">    w += size - r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">    modCount += size - w;</span><br><span class="line">    size = w;</span><br><span class="line">    modified = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于我们的<code>demo</code>程序：</p><p>此时<code>r = size</code>，第一个<code>if</code>块不进入。</p><p>此时<code>(w = 3) != (size = 6)</code>，进入第二个<code>if</code>块，将索引从<code>w</code>到<code>size - 1</code>位置的元素置为<code>null</code>，释放对原来元素的引用。</p><p>接下来是一些收尾工作：</p><ul><li>记录修改次数，修改（移除）了<code>size - w</code>个元素；</li><li>将集合大小设为<code>w</code>：为在<code>for</code>循环中给<code>elementData</code>域赋值的元素个数。</li><li>设置修改标记为<code>true</code>，此处是<code>c</code>集合中的元素全部从集合中删除。</li></ul><p>最后，<code>batchRemove</code>方法返回<code>modified</code>布尔值：表示是否当前集合中删除了指定集合<code>c</code>中包含的所有元素。</p><h3 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h3><p>修改方法只有一个：修改指定索引位置的元素为新的元素。</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 指定的新元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验索引是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 获取index索引位置的旧元素</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="comment">// 赋值为新的指定元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// 返回旧元素</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询元素"><a href="#查询元素" class="headerlink" title="查询元素"></a>查询元素</h3><p>由于<code>ArrayList</code>底层由<code>elementData</code>数组存储元素，所以支持按数组下标访问：即随机快速访问。其查询的时间复杂度为<code>O(1)</code>，这也是为什么<code>ArrayList</code>实现<code>RandomAccess</code>的原因：标记该类支持随机快速访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验索引是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 按数组下标取值</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h3><h4 id="clone方法"><a href="#clone方法" class="headerlink" title="clone方法"></a><code>clone</code>方法</h4><p><a href="/2020/04/26/javase/base/cloneable">传送门</a></p><h4 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a><code>size</code>方法</h4><p>获取集合大小：返回成员变量<code>size</code>。</p><h4 id="isEmpty方法"><a href="#isEmpty方法" class="headerlink" title="isEmpty方法"></a><code>isEmpty</code>方法</h4><p>判断集合是否为空集合：返回<code>size == 0</code>得到的值。</p><h4 id="indexOf方法"><a href="#indexOf方法" class="headerlink" title="indexOf方法"></a><span id="indexOf"><code>indexOf</code>方法</span></h4><p>返回指定元素在当前集合中第一次出现的位置索引。如果当前集合中不包含此元素，返回<code>-1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 指定元素为null：使用==运算符比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非null：使用equals方法比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到，返回-1。</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从前往后遍历，<code>null</code>值使用<code>==</code>运算符进行比较，其它对象使用<code>equals</code>方法比较。</p><h4 id="lastIndexOf方法"><a href="#lastIndexOf方法" class="headerlink" title="lastIndexOf方法"></a><code>lastIndexOf</code>方法</h4><p>返回指定元素在当前集合中最后一次出现的位置索引。如果当前集合中不包含此元素，返回<code>-1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从后往前遍历，<code>null</code>值使用<code>==</code>运算符进行比较，其它对象使用<code>equals</code>方法比较。</p><h4 id="contains方法"><a href="#contains方法" class="headerlink" title="contains方法"></a><code>contains</code>方法</h4><p>判断指定元素是否在集合中。调用的是<a href="#indexOf"><code>indexOf(o)</code></a>方法，判断其返回值是否大于等于<code>0</code>，等于<code>-1</code>说明不在集合中。</p><h4 id="iterator方法"><a href="#iterator方法" class="headerlink" title="iterator方法"></a><code>iterator</code>方法</h4><p>该方法是迭代器设计模式的体现。使用了<code>new</code>关键字创建了一个私有内部类<code>Itr</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>私有内部类<code>Itr</code>实现了<code>java.util.Iterator</code>迭代器接口。其成员变量有三个：</p><ul><li><code>cursor</code>：游标（下一个要返回元素的索引）。</li><li><code>lastRet</code>：初始化为<code>-1</code>，最后一个被返回元素的索引；如果集合中本来没有任何元素则返回<code>-1</code>。</li><li><code>expectedModCount</code>：期望的修改次数。初始化为当前集合的<code>modCount</code>。</li></ul><p>只有一个无参构造函数。</p><p>我们知道使用迭代器对<code>ArrayList</code>进行遍历的写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; iteratorList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">iteratorList.add(<span class="number">1</span>);</span><br><span class="line">iteratorList.add(<span class="number">2</span>);</span><br><span class="line">iteratorList.add(<span class="number">3</span>);</span><br><span class="line">iteratorList.add(<span class="number">4</span>);</span><br><span class="line">iteratorList.add(<span class="number">5</span>);</span><br><span class="line">iteratorList.add(<span class="number">6</span>);</span><br><span class="line">Iterator&lt;Integer&gt; iterator = iteratorList.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Integer next = iterator.next();</span><br><span class="line">    System.out.println(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中关键的两个方法为：<code>hasNext()</code>和<code>next()</code>。接下来我们着重来看下这两个方法。</p><p>首先调用<code>iteratorList</code>对象的<code>iterator()</code>方法得到一个迭代器对象，经过上面的分析我们可知这实际是一个<code>Itr</code>对象。</p><p>其<code>hasNext()</code>方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cursor != size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回当前游标<code>cursor</code>是否不等于集合大小<code>size</code>。如果不等于<code>size</code>，说明还有下一个元素。可继续迭代。否则迭代完成。</p><p><code>next()</code>方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// fail-fast机制</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="comment">// 获取当前游标</span></span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="comment">// 当前游标超过集合大小则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="comment">// 获取存储元素的数组对象</span></span><br><span class="line">    Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="comment">// 当前游标超出数组长度：与hasNext方法中的判断出现了矛盾。并发修改：fail-fast机制</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    <span class="comment">// 校验通过，游标加一</span></span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 最后一个被返回元素的索引赋值为旧的游标i，返回旧的游标对应的元素。</span></span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在<code>Itr</code>类中使用<code>this</code>指代的是当前<code>Itr</code>对象，使用<code>ArrayList.this</code>指代的是集合对象。</p></blockquote><blockquote><p>为什么<code>ArrayList</code>使用迭代器遍历没有普通<code>fori</code>循环遍历效率高？</p><p>答：经过以上代码的分析，原因显而易见：使用迭代器遍历，首先需要使用<code>new</code>关键字创建一个<code>Itr</code>对象，创建对象需要耗时（一次）；其次，中间有多次条件判断并且有局部变量产生，以及一个加<code>1</code>操作，这也需要耗费时间（多次：每次调用<code>next</code>方法）。</p></blockquote><h2 id="Demo实战"><a href="#Demo实战" class="headerlink" title="Demo实战"></a><code>Demo</code>实战</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.collect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 插入元素</span></span><br><span class="line">        ArrayList&lt;String&gt; addList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 集合尾部插入</span></span><br><span class="line">        addList.add(<span class="string">"测试1"</span>);</span><br><span class="line">        System.out.println(addList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 集合指定索引位置插入</span></span><br><span class="line">        addList.add(<span class="number">1</span>,<span class="string">"指定位置1"</span>);</span><br><span class="line">        System.out.println(addList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 集合指定索引位置插入：索引位置无元素且不是尾部：索引越界。</span></span><br><span class="line">        <span class="comment">// addList.add(10,"指定位置2");</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待插入集合初始化</span></span><br><span class="line">        ArrayList&lt;String&gt; toBeAddList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        toBeAddList.add(<span class="string">"测试2"</span>);</span><br><span class="line">        toBeAddList.add(<span class="string">"测试3"</span>);</span><br><span class="line">        toBeAddList.add(<span class="string">"测试4"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待指定索引位置插入集合初始化</span></span><br><span class="line">        ArrayList&lt;String&gt; toBeAddIndexList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        toBeAddIndexList.add(<span class="string">"测试5"</span>);</span><br><span class="line">        toBeAddIndexList.add(<span class="string">"测试6"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将一个集合全部元素插入至当前集合末尾</span></span><br><span class="line">        addList.addAll(toBeAddList);</span><br><span class="line">        System.out.println(addList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从当前集合指定索引位置开始，将一个集合全部元素插入</span></span><br><span class="line">        addList.addAll(<span class="number">1</span>,toBeAddIndexList);</span><br><span class="line">        System.out.println(addList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除元素</span></span><br><span class="line">        List&lt;Integer&gt; removeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        removeList.add(<span class="number">1</span>);</span><br><span class="line">        removeList.add(<span class="number">2</span>);</span><br><span class="line">        removeList.add(<span class="number">6</span>);</span><br><span class="line">        removeList.add(<span class="number">3</span>);</span><br><span class="line">        removeList.add(<span class="number">4</span>);</span><br><span class="line">        removeList.add(<span class="number">5</span>);</span><br><span class="line">        removeList.add(<span class="number">6</span>);</span><br><span class="line">        removeList.add(<span class="number">4</span>);</span><br><span class="line">        System.out.println(removeList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除指定索引位置元素</span></span><br><span class="line">        removeList.remove(<span class="number">1</span>);</span><br><span class="line">        System.out.println(removeList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除指定元素在集合中第一次出现位置的元素</span></span><br><span class="line">        removeList.remove(<span class="keyword">new</span> Integer(<span class="number">6</span>));</span><br><span class="line">        System.out.println(removeList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待删除元素集合</span></span><br><span class="line">        List&lt;Integer&gt; beRemovedList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        beRemovedList.add(<span class="number">2</span>);</span><br><span class="line">        beRemovedList.add(<span class="number">3</span>);</span><br><span class="line">        beRemovedList.add(<span class="number">6</span>);</span><br><span class="line">        System.out.println(removeList);</span><br><span class="line">        System.out.println(beRemovedList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从当前集合中删除指定集合中包含的所有元素</span></span><br><span class="line">        <span class="keyword">boolean</span> b = removeList.removeAll(beRemovedList);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        System.out.println(removeList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除全部元素</span></span><br><span class="line">        removeList.clear();</span><br><span class="line">        System.out.println(removeList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改元素集合初始化</span></span><br><span class="line">        ArrayList&lt;Integer&gt; operatorList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        operatorList.add(<span class="number">1</span>);</span><br><span class="line">        operatorList.add(<span class="number">2</span>);</span><br><span class="line">        operatorList.add(<span class="number">3</span>);</span><br><span class="line">        operatorList.add(<span class="number">2</span>);</span><br><span class="line">        operatorList.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(operatorList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改元素，将索引为1的元素修改为6</span></span><br><span class="line">        operatorList.set(<span class="number">1</span>,<span class="number">6</span>);</span><br><span class="line">        System.out.println(operatorList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询元素</span></span><br><span class="line">        Integer integer = operatorList.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(integer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 克隆</span></span><br><span class="line">        Object clone = operatorList.clone();</span><br><span class="line">        System.out.println(clone);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// size</span></span><br><span class="line">        System.out.println(operatorList.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// isEmpty</span></span><br><span class="line">        System.out.println(operatorList.isEmpty());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// indexOf</span></span><br><span class="line">        System.out.println(operatorList.indexOf(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lastIndexOf</span></span><br><span class="line">        System.out.println(operatorList.lastIndexOf(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// contains</span></span><br><span class="line">        System.out.println(operatorList.contains(<span class="number">3</span>));</span><br><span class="line">        System.out.println(operatorList.contains(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代器设计模式</span></span><br><span class="line">        List&lt;Integer&gt; iteratorList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        iteratorList.add(<span class="number">1</span>);</span><br><span class="line">        iteratorList.add(<span class="number">2</span>);</span><br><span class="line">        iteratorList.add(<span class="number">3</span>);</span><br><span class="line">        iteratorList.add(<span class="number">4</span>);</span><br><span class="line">        iteratorList.add(<span class="number">5</span>);</span><br><span class="line">        iteratorList.add(<span class="number">6</span>);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = iteratorList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer next = iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 普通fori循环遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,size = iteratorList.size(); i &lt; size; i++) &#123;</span><br><span class="line">            System.out.println(iteratorList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// forEach遍历，底层实现为迭代器</span></span><br><span class="line">        <span class="keyword">for</span> (Integer i : iteratorList) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>ArrayList</code>集合是我们在工作中用到的最多的集合，我们必须熟练掌握其特性。</p><p>通过上面的源码分析可知，<code>ArrayList</code>集合查找效率非常高。顺序添加元素至末尾效率也很高，但需要确保不扩容，否则进行数组拷贝很耗时。所以我们在创建<code>ArrayList</code>对象时，如果可以预估到集合中元素个数，最好指定初始容量，以避免在插入时扩容带来的性能损耗。</p><p>本文<code>Demo</code>实战代码见：<a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/java-se/src/main/java/com/sunchaser/javase/collect/ArrayListTest.java" target="_blank" rel="noopener">传送门</a></p>]]></content>
    
    <summary type="html">
    
      JDK源码解析之ArrayList集合
    
    </summary>
    
    
      <category term="JDK源码解析" scheme="https://lilu.org.cn/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="JDK" scheme="https://lilu.org.cn/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码解析之RandomAccess</title>
    <link href="https://lilu.org.cn/2020/04/26/javase/base/randomaccess/"/>
    <id>https://lilu.org.cn/2020/04/26/javase/base/randomaccess/</id>
    <published>2020-04-26T13:42:07.640Z</published>
    <updated>2020-04-26T13:15:30.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>该接口是<code>List</code>实现使用的标记型接口，表明它们支持快速（通常是恒定时间）随机访问。此接口的主要目的是允许通用算法更改其行为，以应用于随机访问列表或顺序访问列表时提供良好的性能。</p><p>当应用于顺序访问列表（例如<code>LinkedList</code>）时，用于操纵随机访问列表（例如<code>ArrayList</code>）的最佳算法会产生二次行为。鼓励使用通用列表算法，先检查给定列表是否为该接口的实例，然后再应用一种算法（如果将其应用于顺序访问列表则性能较差），并在必要时更改其行为以保证可接受的性能。</p><p>公认的是，随机访问和顺序访问之间的区别通常是模糊的。例如，某些<code>List</code>实现在变得庞大的情况下提供渐进线性的访问时间，但实际上却是恒定的访问时间。这样的<code>List</code>实现通常应该实现此接口。根据经验，如果满足以下条件，则<code>List</code>实现应实现此接口：</p><p>对于类的典型实例，此循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, n=list.size(); i &lt; n; i++)</span><br><span class="line">    list.get(i);</span><br></pre></td></tr></table></figure><p>比这个循环运行更快：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Iterator i=list.iterator(); i.hasNext(); )</span><br><span class="line">    i.next();</span><br></pre></td></tr></table></figure><h2 id="ArrayList效率比较"><a href="#ArrayList效率比较" class="headerlink" title="ArrayList效率比较"></a><code>ArrayList</code>效率比较</h2><p><code>ArrayList</code>实现了<code>RandomAccess</code>接口，根据<code>RandomAccess</code>接口定义，使用<code>fori</code>循环遍历比迭代器遍历更快。下面我们来进行验证。</p><p>创建一个<code>ArrayList</code>集合并填充一千万个元素，分别使用<code>fori</code>循环和迭代器进行遍历，计算其运行时间。完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.randomaccess;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机访问和迭代器访问效率比较</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomIteratorCompare</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// init list data</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            list.add(String.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// random access</span></span><br><span class="line">        <span class="keyword">long</span> randomStartTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,size = list.size(); i &lt; size; i++) &#123;</span><br><span class="line">            list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> randomEndTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"random access:"</span> + (randomEndTime - randomStartTime));</span><br><span class="line">        <span class="comment">// sequential access</span></span><br><span class="line">        <span class="keyword">long</span> sequentialStartTime = System.currentTimeMillis();</span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> sequentialEndTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"sequential access:"</span> + (sequentialEndTime - sequentialStartTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">random access:6</span><br><span class="line">sequential access:11</span><br></pre></td></tr></table></figure><p>结果显而易见，<code>ArrayList</code>使用迭代器遍历效率略低于<code>fori</code>遍历。</p><h2 id="LinkedList效率比较"><a href="#LinkedList效率比较" class="headerlink" title="LinkedList效率比较"></a><code>LinkedList</code>效率比较</h2><p>当应用于<code>LinkedList</code>时，用于操纵<code>ArrayList</code>的最佳算法（<code>fori</code>循环遍历）会产生二次行为。<code>ListedList</code>未实现<code>RandomAccess</code>接口。</p><p>我们来创建一个<code>LinkedList</code>，对其填充元素并分别使用<code>fori</code>循环和迭代器进行遍历。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init LinkedList data</span></span><br><span class="line">List&lt;String&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    linkedList.add(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// random access</span></span><br><span class="line"><span class="keyword">long</span> linkedListRandomStartTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,size = linkedList.size(); i &lt; size; i++) &#123;</span><br><span class="line">    linkedList.get(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> linkedListRandomEndTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"random access:"</span> + (linkedListRandomEndTime - linkedListRandomStartTime));</span><br><span class="line"><span class="comment">// sequential access</span></span><br><span class="line"><span class="keyword">long</span> linkedListSequentialStartTime = System.currentTimeMillis();</span><br><span class="line">Iterator&lt;String&gt; linkedListIterator = arrayList.iterator();</span><br><span class="line"><span class="keyword">while</span> (linkedListIterator.hasNext()) &#123;</span><br><span class="line">    linkedListIterator.next();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> linkedListSequentialEndTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"sequential access:"</span> + (linkedListSequentialEndTime - linkedListSequentialStartTime));</span><br></pre></td></tr></table></figure><p>运行后控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">random access:11031</span><br><span class="line">sequential access:10</span><br></pre></td></tr></table></figure><p>可以看到，<code>fori</code>循环遍历所耗费的时间已经远远超过了迭代器遍历，这说明适用于<code>ArrayList</code>的最佳算法不再适用于<code>LinkedList</code>，这与集合的内部数据结构和<code>get</code>方法实现有关。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实现了<code>RandomAccess</code>接口的<code>ArrayList</code>使用<code>fori</code>循环遍历效率更高，而<code>LinkedList</code>使用迭代器遍历效率极高。</p>]]></content>
    
    <summary type="html">
    
      JDK源码解析之RandomAccess标记型接口
    
    </summary>
    
    
      <category term="JDK源码解析" scheme="https://lilu.org.cn/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="JDK" scheme="https://lilu.org.cn/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>深入理解深浅拷贝</title>
    <link href="https://lilu.org.cn/2020/04/26/javase/base/depth-shallow-copy/"/>
    <id>https://lilu.org.cn/2020/04/26/javase/base/depth-shallow-copy/</id>
    <published>2020-04-26T13:41:29.605Z</published>
    <updated>2020-04-26T13:15:19.603Z</updated>
    
    <content type="html"><![CDATA[<p>无论是<code>java.lang.Object#clone()</code>方法还是自己实现的克隆方法，都存在着浅拷贝和深拷贝的问题。</p><p>那么什么是浅拷贝和深拷贝呢？</p><p>举一个不太恰当的例子：大家都玩过英雄联盟这款游戏吧？英雄联盟中的孙悟空这个英雄的<code>W</code>技能是“真假猴王”：孙悟空进入隐形状态片刻，并留下一个替身，替身在片刻后会对其周围的敌人造成魔法伤害。如果玩家攻击替身，替身掉血但本身不掉血。这似乎可以理解成深拷贝。</p><h2 id="浅拷贝和深拷贝简介"><a href="#浅拷贝和深拷贝简介" class="headerlink" title="浅拷贝和深拷贝简介"></a>浅拷贝和深拷贝简介</h2><ul><li>浅拷贝：只拷贝被克隆对象中按值传递的属性数据，不拷贝引用类型的属性数据。换言之，所有对其它对象的引用仍指向原来的对象，拷贝的是栈内的引用而不是堆内的对象。</li><li>深拷贝：除了浅拷贝需要克隆的值传递的属性数据之外，还会拷贝引用类型所指向的对象，即拷贝的引用会指向新的对象。换言之，深拷贝把待克隆的对象所引用的对象全都拷贝了一遍。</li></ul><p>深拷贝要深入到多少层，这是一个需要根据实际情况来决定的问题。当拷贝至无引用对象的时候，就可称之为完全深拷贝。此外，深拷贝中还可能会出现循环引用的问题，需要仔细处理。</p><h2 id="java-lang-Object-clone-浅拷贝"><a href="#java-lang-Object-clone-浅拷贝" class="headerlink" title="java.lang.Object#clone()浅拷贝"></a><code>java.lang.Object#clone()</code>浅拷贝</h2><p>为了证实该方法是浅拷贝，我们先来尝试设计一下英雄，首先创建一个<code>LOL</code>英雄接口，它包含两个方法：攻击和被攻击，攻击时法力值减少，被攻击时生命值减少。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.cloneable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LOL英雄接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LolHero</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 攻击</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lolSkill 使用的技能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attack</span><span class="params">(LolSkill lolSkill)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 受到其它英雄攻击</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">beAttacked</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们来定义技能类，技能包括按键<code>key</code>、技能名称和技能描述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.cloneable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LOL英雄的技能类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LolSkill</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LolSkill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LolSkill</span><span class="params">(String key, String name, String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"LolSkill&#123;"</span>);</span><br><span class="line">        sb.append(<span class="string">"key='"</span>).append(key).append(<span class="string">'\''</span>);</span><br><span class="line">        sb.append(<span class="string">", name='"</span>).append(name).append(<span class="string">'\''</span>);</span><br><span class="line">        sb.append(<span class="string">", desc='"</span>).append(desc).append(<span class="string">'\''</span>);</span><br><span class="line">        sb.append(<span class="string">'&#125;'</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来定义生命值和法力值类。</p><p>生命值类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.cloneable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 英雄生命值类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeValue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer lifeValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LifeValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LifeValue</span><span class="params">(Integer lifeValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lifeValue = lifeValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getLifeValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lifeValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LifeValue <span class="title">setLifeValue</span><span class="params">(Integer lifeValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lifeValue = lifeValue;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"LifeValue&#123;"</span>);</span><br><span class="line">        sb.append(<span class="string">"lifeValue="</span>).append(lifeValue);</span><br><span class="line">        sb.append(<span class="string">'&#125;'</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法力值类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.cloneable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 英雄法力值类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mana</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer mana;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mana</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mana</span><span class="params">(Integer mana)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mana = mana;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getMana</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mana;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mana <span class="title">setMana</span><span class="params">(Integer mana)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mana = mana;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"Mana&#123;"</span>);</span><br><span class="line">        sb.append(<span class="string">"mana="</span>).append(mana);</span><br><span class="line">        sb.append(<span class="string">'&#125;'</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们来创建孙悟空英雄类，它实现了自定义的<code>LOL</code>英雄接口和<code>java.lang.Cloneable</code>接口，包含英雄名称、生命值、法力值和四个技能等属性，重写了<code>java.lang.Cloneable#clone()</code>方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.cloneable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 英雄：孙悟空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SunWuKong</span> <span class="keyword">implements</span> <span class="title">LolHero</span>,<span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"齐天大圣-孙悟空"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生命值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LifeValue sunWuKongLifeValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 法力值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Mana sunWuKongMana;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* skill */</span></span><br><span class="line">    <span class="keyword">private</span> LolSkill Q = <span class="keyword">new</span> LolSkill(<span class="string">"Q"</span>,<span class="string">"粉碎打击"</span>,<span class="string">"孙悟空的下次攻击造成额外物理伤害，获得距离加成，并暂时减少敌人的护甲。"</span>);</span><br><span class="line">    <span class="keyword">private</span> LolSkill W = <span class="keyword">new</span> LolSkill(<span class="string">"W"</span>,<span class="string">"真假猴王"</span>,<span class="string">"孙悟空进入隐形状态片刻，并留下一个替身，替身在片刻后会对其周围的敌人造成魔法伤害。"</span>);</span><br><span class="line">    <span class="keyword">private</span> LolSkill E = <span class="keyword">new</span> LolSkill(<span class="string">"E"</span>,<span class="string">"腾云突击"</span>,<span class="string">"孙悟空突进至目标敌人处，并变出最多2个分身，攻击附近目标。对每个击中的目标造成物理伤害。"</span>);</span><br><span class="line">    <span class="keyword">private</span> LolSkill R = <span class="keyword">new</span> LolSkill(<span class="string">"R"</span>,<span class="string">"大闹天宫"</span>,<span class="string">"孙悟空展开金箍棒，不停地旋转，对敌人造成伤害并将其击飞。在此期间，孙悟空速度持续增加。"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">(LolSkill lolSkill)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用了"</span> + lolSkill + <span class="string">"进行了攻击"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beAttacked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer oldSunWuKongLifeValue = <span class="keyword">this</span>.sunWuKongLifeValue.getLifeValue() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.sunWuKongLifeValue.setLifeValue(oldSunWuKongLifeValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LifeValue <span class="title">getSunWuKongLifeValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sunWuKongLifeValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SunWuKong <span class="title">setSunWuKongLifeValue</span><span class="params">(LifeValue sunWuKongLifeValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sunWuKongLifeValue = sunWuKongLifeValue;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mana <span class="title">getSunWuKongMana</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sunWuKongMana;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SunWuKong <span class="title">setSunWuKongMana</span><span class="params">(Mana sunWuKongMana)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sunWuKongMana = sunWuKongMana;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"SunWuKong&#123;"</span>);</span><br><span class="line">        sb.append(<span class="string">"name='"</span>).append(name).append(<span class="string">'\''</span>);</span><br><span class="line">        sb.append(<span class="string">", sunWuKongLifeValue="</span>).append(sunWuKongLifeValue);</span><br><span class="line">        sb.append(<span class="string">", sunWuKongMana="</span>).append(sunWuKongMana);</span><br><span class="line">        sb.append(<span class="string">'&#125;'</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一切准备就绪，我们来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.cloneable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深浅拷贝测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthCopyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个孙悟空英雄对象，并赋予生命值1000，法力值2000</span></span><br><span class="line">        SunWuKong sunWuKong = <span class="keyword">new</span> SunWuKong();</span><br><span class="line">        sunWuKong.setSunWuKongLifeValue(<span class="keyword">new</span> LifeValue(<span class="number">1000</span>))</span><br><span class="line">                .setSunWuKongMana(<span class="keyword">new</span> Mana(<span class="number">2000</span>));</span><br><span class="line">        <span class="comment">// 克隆一个替身</span></span><br><span class="line">        SunWuKong clone = (SunWuKong) sunWuKong.clone();</span><br><span class="line">        System.out.println(sunWuKong);</span><br><span class="line">        System.out.println(clone);</span><br><span class="line">        System.out.println(sunWuKong == clone);</span><br><span class="line">        <span class="comment">// 替身受到攻击</span></span><br><span class="line">        clone.beAttacked();</span><br><span class="line">        System.out.println(sunWuKong);</span><br><span class="line">        System.out.println(clone);</span><br><span class="line">        System.out.println(sunWuKong == clone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SunWuKong&#123;name&#x3D;&#39;齐天大圣-孙悟空&#39;, sunWuKongLifeValue&#x3D;LifeValue&#123;lifeValue&#x3D;1000&#125;, sunWuKongMana&#x3D;Mana&#123;mana&#x3D;2000&#125;&#125;</span><br><span class="line">SunWuKong&#123;name&#x3D;&#39;齐天大圣-孙悟空&#39;, sunWuKongLifeValue&#x3D;LifeValue&#123;lifeValue&#x3D;1000&#125;, sunWuKongMana&#x3D;Mana&#123;mana&#x3D;2000&#125;&#125;</span><br><span class="line">false</span><br><span class="line">SunWuKong&#123;name&#x3D;&#39;齐天大圣-孙悟空&#39;, sunWuKongLifeValue&#x3D;LifeValue&#123;lifeValue&#x3D;999&#125;, sunWuKongMana&#x3D;Mana&#123;mana&#x3D;2000&#125;&#125;</span><br><span class="line">SunWuKong&#123;name&#x3D;&#39;齐天大圣-孙悟空&#39;, sunWuKongLifeValue&#x3D;LifeValue&#123;lifeValue&#x3D;999&#125;, sunWuKongMana&#x3D;Mana&#123;mana&#x3D;2000&#125;&#125;</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>孙悟空“替身”受到攻击后，“真身”的生命值也减少了。可以看出真身和替身引用的是同一个生命值对象。足以证实<code>java.lang.Cloneable#clone()</code>方法是浅拷贝。</p><h2 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a>深拷贝的实现</h2><p>深拷贝则不能简单的在重写的<code>clone</code>方法内直接调用<code>super.clone()</code>，需要将当前类的每一个引用对象都进行拷贝，如果引用对象还包含引用对象，则需进行多层拷贝。</p><p>当前类的每一个引用对象均需实现<code>java.lang.Cloneable</code>接口并重写其<code>clone</code>方法。</p><p>我们来看下<code>SunWuKong</code>类的引用对象：<code>LifeValue</code>和<code>Mana</code>。</p><p><code>LifeValue</code>代码实现为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.cloneable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 英雄生命值类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeValue</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer lifeValue;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Mana</code>代码实现为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.cloneable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 英雄法力值类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mana</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer mana;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时<code>SunWuKong</code>类的<code>clone</code>方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.cloneable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 英雄：孙悟空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SunWuKong</span> <span class="keyword">implements</span> <span class="title">LolHero</span>,<span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"齐天大圣-孙悟空"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生命值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LifeValue sunWuKongLifeValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 法力值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Mana sunWuKongMana;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        SunWuKong clone = (SunWuKong) <span class="keyword">super</span>.clone();</span><br><span class="line">        LifeValue lifeValueClone = (LifeValue) <span class="keyword">this</span>.sunWuKongLifeValue.clone();</span><br><span class="line">        Mana manaClone = (Mana) <span class="keyword">this</span>.sunWuKongMana.clone();</span><br><span class="line">        clone.setSunWuKongLifeValue(lifeValueClone);</span><br><span class="line">        clone.setSunWuKongMana(manaClone);</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看下输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SunWuKong&#123;name&#x3D;&#39;齐天大圣-孙悟空&#39;, sunWuKongLifeValue&#x3D;LifeValue&#123;lifeValue&#x3D;1000&#125;, sunWuKongMana&#x3D;Mana&#123;mana&#x3D;2000&#125;&#125;</span><br><span class="line">SunWuKong&#123;name&#x3D;&#39;齐天大圣-孙悟空&#39;, sunWuKongLifeValue&#x3D;LifeValue&#123;lifeValue&#x3D;1000&#125;, sunWuKongMana&#x3D;Mana&#123;mana&#x3D;2000&#125;&#125;</span><br><span class="line">false</span><br><span class="line">SunWuKong&#123;name&#x3D;&#39;齐天大圣-孙悟空&#39;, sunWuKongLifeValue&#x3D;LifeValue&#123;lifeValue&#x3D;1000&#125;, sunWuKongMana&#x3D;Mana&#123;mana&#x3D;2000&#125;&#125;</span><br><span class="line">SunWuKong&#123;name&#x3D;&#39;齐天大圣-孙悟空&#39;, sunWuKongLifeValue&#x3D;LifeValue&#123;lifeValue&#x3D;999&#125;, sunWuKongMana&#x3D;Mana&#123;mana&#x3D;2000&#125;&#125;</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>替身对象受到攻击后，原对象生命值不变，替身对象生命值减少。这就是深拷贝的实现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>深拷贝要求被拷贝的类的每一个引用对象都实现<code>java.lang.Cloneable</code>接口并实现<code>clone</code>方法，所以当需要实现深拷贝时，需要进行对象功能的全面考虑，特别是当引用对象还包含引用对象的多层嵌套时，需要结合对象的功能进行考虑。</p><p>本篇文章所有源代码地址：<a href="https://github.com/sunchaser-lilu/gold-road-to-Java/tree/master/java-se/src/main/java/com/sunchaser/javase/base/cloneable" target="_blank" rel="noopener">传送门</a></p>]]></content>
    
    <summary type="html">
    
      深入理解深浅拷贝
    
    </summary>
    
    
      <category term="JDK源码解析" scheme="https://lilu.org.cn/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="JDK" scheme="https://lilu.org.cn/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码解析之Cloneable</title>
    <link href="https://lilu.org.cn/2020/04/26/javase/base/cloneable/"/>
    <id>https://lilu.org.cn/2020/04/26/javase/base/cloneable/</id>
    <published>2020-04-26T13:41:00.429Z</published>
    <updated>2020-04-26T13:14:57.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cloneable接口简介"><a href="#Cloneable接口简介" class="headerlink" title="Cloneable接口简介"></a><code>Cloneable</code>接口简介</h2><p>1、一个类实现<code>java.lang.Cloneable</code>标记性接口以向<code>java.lang.Object#clone()</code>方法指示该方法为该类的实例进行逐域复制是合法的。</p><p>2、在未实现<code>java.lang.Cloneable</code>接口的实例上调用<code>java.lang.Object#clone()</code>方法会导致抛出<code>java.lang.CloneNotSupportedException</code>异常。</p><p>3、按照约定，实现了<code>java.lang.Cloneable</code>接口的类应使用<code>public</code>公共方法重写<code>java.lang.Object#clone()</code>方法（<code>protected</code>受保护的）。</p><h2 id="克隆的基本使用"><a href="#克隆的基本使用" class="headerlink" title="克隆的基本使用"></a>克隆的基本使用</h2><p>由于<code>java.util.ArrayList</code>类实现了<code>Cloneable</code>接口，我们可以将一个<code>ArrayList</code>集合的数据克隆至另一个新的集合中。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.cloneable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个ArrayList集合的数据克隆至另一个新的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListClone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = Lists.newArrayList();</span><br><span class="line">        list.add(<span class="string">"Java大法好"</span>);</span><br><span class="line">        list.add(<span class="string">"PHP是世界上最好的语言"</span>);</span><br><span class="line">        list.add(<span class="string">"向日葵的自我修养"</span>);</span><br><span class="line">        Object clone = list.clone();</span><br><span class="line">        System.out.println(clone == list);</span><br><span class="line">        System.out.println(clone);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明：</p><ol><li>创建一个<code>ArrayList</code>集合对象；</li><li>往其中添加三个元素；</li><li>调用集合对象的<code>clone()</code>方法；</li><li>判断克隆后的集合地址与原集合地址是否相等；</li><li>分别打印两个集合的内容。</li></ol><p>运行程序，可以看到，克隆后的<code>ArrayList</code>集合与旧集合的地址不一样，但其内容相同。</p><h2 id="ArrayList-clone-方法源码分析"><a href="#ArrayList-clone-方法源码分析" class="headerlink" title="ArrayList#clone()方法源码分析"></a><code>ArrayList#clone()</code>方法源码分析</h2><p>调用了<code>list</code>对象的<code>clone()</code>方法，我们来看下其实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现其调用的是<code>super.clone()</code>方法得到的一个新的集合。</p><p>那么该<code>super</code>指代的是哪个父类呢？</p><ul><li><code>java.util.ArrayList</code>的直接父类是<code>java.util.AbstractList</code>；</li><li><code>java.util.AbstractList</code>的直接父类是<code>java.util.AbstractCollection</code>；</li><li><code>java.util.AbstractCollection</code>是一个抽象类，实现了<code>java.util.Collection</code>接口，没有继承任何父类。</li></ul><p>但是我们却没有在<code>java.util.AbstractList</code>和<code>java.util.AbstractCollection</code>类中找到<code>clone()</code>方法。</p><p>事实上可以直接借助<code>IDEA</code>的快捷键得到其是<code>Object</code>类的<code>clone()</code>方法。</p><p>只有<code>java.util.ArrayList</code>类中有<code>clone()</code>方法，这也是为什么在基本使用的代码中创建的集合，使用<code>java.util.ArrayList</code>接收而不用顶层接口<code>java.util.List</code>接收的原因。</p><p>我们来看下<code>Object#clone()</code>方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><p>这是一个本地<code>navive</code>方法，使用了<code>protected</code>访问修饰符，并显式抛出了<code>java.lang.CloneNotSupportedException</code>异常。其实现是由底层的<code>c/c++</code>语言进行实现的，我们无法从<code>Java</code>语言层面看到。</p><p>克隆出一个<code>ArrayList</code>对象<code>v</code>之后，调用工具类<code>java.util.Arrays</code>的<code>copyOf</code>方法，将原集合的数据<code>elementData</code>和集合大小<code>size</code>传入，拷贝集合元素至克隆集合<code>v</code>的<code>elementData</code>域中。</p><p>我们来看下<code>java.util.Arrays#copyOf()</code>方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">        ? (T[]) new Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>copyOf</code>方法内部调用的是另一个重载的<code>copyOf</code>方法，判断传入的集合数据<code>elementData</code>类型是不是<code>Object[]</code>数组类型，如果是<code>Object</code>类型则使用<code>new</code>关键字创建一个新的<code>Object[]</code>数组，否则创建其它类型的数组，最后调用<code>System.arraycopy</code>方法将传入的数组元素拷贝至新建的数组中返回。</p><p>返回了新的数组之后，将克隆出来的集合<code>v</code>的<code>elementData</code>域引用指向新的数组地址，然后设置修改次数<code>modCount</code>字段为<code>0</code>，得到一个全新的克隆集合返回。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Java</code>中所有类都是从<code>java.lang.Object</code>类继承而来的，而<code>Object</code>类提供<code>protected Object clone()</code>方法对对象进行克隆，子类必须实现标记型接口<code>java.lang.Cloneable</code>才支持克隆，当然子类也可以重写<code>Object#clone()</code>方法来实现自己的克隆方式。</p><p>对象的克隆有一个基本问题：对象可能包含对其它对象的引用，当使用<code>Object#clone()</code>方法来克隆对象时，此对象对其它对象的引用也被克隆了一份（注意：这里克隆的是引用）。</p><p><code>java.lang.Cloneable</code>接口只起一个作用，就是在运行期指示虚拟机在当前类使用<code>Object#clone()</code>方法是合法的。通过克隆可以得到一个对象的复制。但由于<code>Object</code>类并未实现<code>java.lang.Cloneable</code>接口，所以被克隆的类如果未实现<code>java.lang.Cloneable</code>接口，在调用<code>java.lang.Object#clone()</code>方法时会抛出<code>java.lang.CloneNotSupportedException</code>异常。</p>]]></content>
    
    <summary type="html">
    
      JDK源码解析之Cloneable标记性接口
    
    </summary>
    
    
      <category term="JDK源码解析" scheme="https://lilu.org.cn/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="JDK" scheme="https://lilu.org.cn/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码解析之Serializable</title>
    <link href="https://lilu.org.cn/2020/03/21/javase/base/serializable/"/>
    <id>https://lilu.org.cn/2020/03/21/javase/base/serializable/</id>
    <published>2020-03-21T13:42:17.942Z</published>
    <updated>2020-03-21T13:14:14.875Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>什么是序列化和反序列化？</p><ul><li>序列化：将对象的二进制数据流写入硬盘（或用于网络传输）；</li><li>反序列化：从硬盘（网络）中将对象的二进制数据流读取出来转化成对象。</li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>实现了<code>java.io.serializable</code>标记性接口的类是可序列化的，可序列化类的所有子类型都是可序列化的。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Java</code>中序列化接口是一个空接口，仅用于标记可序列化的语义。</p><h2 id="序列化UID字段：serialVersionUID"><a href="#序列化UID字段：serialVersionUID" class="headerlink" title="序列化UID字段：serialVersionUID"></a>序列化<code>UID</code>字段：<code>serialVersionUID</code></h2><p>实现了<code>java.io.Serializable</code>接口的类，如果未显式进行声明，在编译期<code>JVM</code>将使用自己的算法生成默认的<code>serialVersionUID</code>字段。</p><blockquote><p>默认的<code>serialVersionUID</code>生成算法对类的详细信息非常敏感，因不同的<code>JVM</code>实现而异，并且在反序列化过程中会可能会导致意外的<code>java.io.InvalidClassException</code>异常。</p></blockquote><p>当进行序列化操作时，会将此<code>serialVersionUID</code>序列化进二进制流中；</p><p>当进行反序列化操作时，如果用来接收对象的类中的<code>serialVersionUID</code>字段值与序列化时的值不一致，会导致反序列化失败。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p>首先创建一个用来序列化测试的类<code>SerializableClass</code>，并实现序列化接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.serizlizable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/3/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableClass</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5135631042912401553L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SerializableClass <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SerializableClass <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"SerializableClass&#123;"</span>);</span><br><span class="line">        sb.append(<span class="string">"name='"</span>).append(name).append(<span class="string">'\''</span>);</span><br><span class="line">        sb.append(<span class="string">", age="</span>).append(age);</span><br><span class="line">        sb.append(<span class="string">'&#125;'</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来创建测试类来进行序列化。首先在当前类所在包中创建<code>serializableClass.txt</code>文件。之后我们序列化写对象写入该文件中，反序列化从该文件中读对象。</p><p>使用以下代码即可获取<code>txt</code>文件的绝对路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前类所在包中的serializableClass.txt文件路径</span></span><br><span class="line">String path = SerializableTest.class.getResource("").getPath();</span><br><span class="line">path = path.replace(<span class="string">"target/classes"</span>,<span class="string">"src/main/java"</span>) + <span class="string">"serializableClass.txt"</span>;</span><br></pre></td></tr></table></figure><p>接下来创建用来序列化的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SerializableClass sc = <span class="keyword">new</span> SerializableClass().setName(<span class="string">"序列化"</span>).setAge(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>然后我们创建序列化的方法<code>writeObject</code>，将对象和<code>txt</code>文件绝对路径传入进行写对象操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(SerializableClass sc,String path)</span> </span>&#123;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    ObjectOutputStream ops = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(path);</span><br><span class="line">        ops = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">        ops.writeObject(sc);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ops != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ops.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>main</code>方法中调用即可将对象写入文本文件中，可打开文本文件查看（有点乱码）。</p><p>下面我们来创建反序列化的方法<code>readObject</code>，将文本文件路径传入进行读对象操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">        ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">        SerializableClass sc = (SerializableClass) ois.readObject();</span><br><span class="line">        System.out.println(sc);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ois != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该方法后可在控制台看到对象打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SerializableClass&#123;name&#x3D;&#39;序列化&#39;, age&#x3D;10&#125;</span><br></pre></td></tr></table></figure><h3 id="反序列化失败演示"><a href="#反序列化失败演示" class="headerlink" title="反序列化失败演示"></a>反序列化失败演示</h3><p>先调用<code>writeObject</code>方法将对象序列化写入文本文件，然后去修改<code>SerializableClass</code>的<code>serialVersionUID</code>字段的值，再去调用<code>readObject</code>方法从文本文件中反序列化读对象。这时反序列化就会失败，并抛出<code>java.io.InvalidClassException</code>异常。</p><p>主要异常堆栈信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidClassException: com.sunchaser.javase.base.serizlizable.SerializableClass; </span><br><span class="line"></span><br><span class="line">local class incompatible: stream classdesc serialVersionUID &#x3D; 5135632042912401553, local class serialVersionUID &#x3D; 5135631042912401553</span><br></pre></td></tr></table></figure><h2 id="IDEA中生成serialVersionUID"><a href="#IDEA中生成serialVersionUID" class="headerlink" title="IDEA中生成serialVersionUID"></a><code>IDEA</code>中生成<code>serialVersionUID</code></h2><p>打开<code>IDEA</code>，选择<code>File</code>-&gt;<code>Settings</code>-&gt;<code>Editor</code>-&gt;<code>Inspections</code>，在搜索框中输入<code>serialVersionUID</code>，找到<code>Serializable class without &#39;serialVersionUID&#39;</code>，进行勾选，点击<code>apply</code>-&gt;<code>OK</code>进行保存。</p><p>设置之后如果实现了<code>Serializable</code>接口的类未定义<code>serialVersionUID</code>字段，则类名处会有黄色警告，输入光标移动至类名处按下快捷键<code>alt+enter</code>会有生成<code>serialVersionUID</code>的快捷方式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文完整代码地址：<a href="https://github.com/sunchaser-lilu/gold-road-to-Java/tree/master/java-se/src/main/java/com/sunchaser/javase/base/serizlizable" target="_blank" rel="noopener">传送门</a></p><p><code>Serializable</code>接口实际上就是一个标记，实现了该接口的类才允许被序列化和反序列化，而<code>serialVersionUID</code>字段则像是一个“版本号”，序列化时将该字段一起存至二进制流中，反序列化时用该字段来判断是否是存进去时的状态。它的作用其实就是判断反序列化出来的对象是不是原来序列化的对象。</p>]]></content>
    
    <summary type="html">
    
      JDK源码解析之Serializable标记性接口
    
    </summary>
    
    
      <category term="JDK源码解析" scheme="https://lilu.org.cn/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="JDK" scheme="https://lilu.org.cn/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>勇闯算法-在行列都排好序的矩阵中找指定的数</title>
    <link href="https://lilu.org.cn/2020/03/21/algorithm/coding-interview-guide/arraysandmatrices/solution01/"/>
    <id>https://lilu.org.cn/2020/03/21/algorithm/coding-interview-guide/arraysandmatrices/solution01/</id>
    <published>2020-03-21T13:32:10.914Z</published>
    <updated>2020-03-21T13:14:28.660Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：《程序员代码面试指南-IT名企算法与数据结构最优解》-左程云著</p><p>牛客网在线<code>OJ</code>系统地址：<a href="https://www.nowcoder.com/practice/b929be9dbbaa489a91afa3fec195c228?tpId=101&tqId=33069&tPage=1&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking" target="_blank" rel="noopener">传送门</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个<code>N × M</code>的整型矩阵<code>matrix</code>和一个整数<code>K</code>，<code>matrix</code>的每一行每一列都是排好序的。实现一个函数，判断<code>K</code>是否在<code>matrix</code>中。</p><blockquote><p>要求：</p><p>时间复杂度为<code>O(N + M)</code>，额外空间复杂度为<code>O(1)</code>。</p></blockquote><p>备注：</p><p>1 ⩽ N, M ⩽1000</p><p>0 ⩽ K, 矩阵中的数 ⩽ 10^9^</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行有三个整数<code>N</code>，<code>M</code>，<code>K</code>；</p><p>接下来<code>N</code>行，每行<code>M</code>个整数为输入的矩阵。</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>若<code>K</code>存在于矩阵中输出<code>&quot;Yes&quot;</code>，否则输出<code>&quot;No&quot;</code>。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 4 5</span><br><span class="line">1 2 3 4</span><br><span class="line">2 4 5 6</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 4 233</span><br><span class="line">1 2 3 4</span><br><span class="line">2 4 5 6</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>由于矩阵中的行和列都是排好序的，我们可以知道最后一列是每一行的最大值，最后一行是每一列的最大值。整个矩阵的最大值在右下角。</p><p>要想减少时间复杂度，我们必须能够快速排除某些行或列，基于最后一列或行是每一行或列的最大值的特点，我们可以从矩阵右上角或左下角开始查找，如果不是指定的数，我们就可以排除掉一行或一列了。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><h3 id="思路一：从矩阵右上角开始查找"><a href="#思路一：从矩阵右上角开始查找" class="headerlink" title="思路一：从矩阵右上角开始查找"></a>思路一：从矩阵右上角开始查找</h3><ol><li>从矩阵最右上角的数开始查找（<code>row=0,col=M-1</code>：第<code>0</code>行，第<code>M-1</code>列）。</li><li>比较当前数<code>matrix[row][col]</code>与<code>K</code>的关系：</li></ol><ul><li>如果等于<code>K</code>，则找到了，返回<code>&quot;Yes&quot;</code>，整个过程结束。</li><li>如果大于<code>K</code>，则该列被排除，令<code>col=col-1</code>，重复步骤<code>2</code>。</li><li>如果小于<code>K</code>，则该行被排除，令<code>row=row+1</code>，重复步骤<code>2</code>。</li></ul><ol start="3"><li>如果找到越界都没有找到与<code>K</code>相等的数，则返回<code>&quot;No&quot;</code>，整个过程结束。</li></ol><h3 id="思路二：从矩阵左下角开始查找"><a href="#思路二：从矩阵左下角开始查找" class="headerlink" title="思路二：从矩阵左下角开始查找"></a>思路二：从矩阵左下角开始查找</h3><ol><li>从矩阵最左上角的数开始查找（<code>row=N-1,col=0</code>：第<code>N-1</code>行，第<code>0</code>列）。</li><li>比较当前数<code>matrix[row][col]</code>与<code>K</code>的关系：</li></ol><ul><li>如果等于<code>K</code>，则找到了，返回<code>&quot;Yes&quot;</code>，整个过程结束。</li><li>如果大于<code>K</code>，则该行被排除，令<code>row=row-1</code>，重复步骤<code>2</code>。</li><li>如果小于<code>K</code>，则该列被排除，令<code>col=col+1</code>，重复步骤<code>2</code>。</li></ul><ol start="3"><li>如果找到越界都没有找到与<code>K</code>相等的数，则返回<code>&quot;No&quot;</code>，整个过程结束。</li></ol><h2 id="代码实现（Java）"><a href="#代码实现（Java）" class="headerlink" title="代码实现（Java）"></a>代码实现（<code>Java</code>）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// receive input params</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        <span class="keyword">int</span> m = scanner.nextInt();</span><br><span class="line">        <span class="keyword">int</span> k = scanner.nextInt();</span><br><span class="line">        <span class="comment">// build matrix</span></span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                matrix[i][j] = scanner.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do check</span></span><br><span class="line">        <span class="keyword">boolean</span> containsOne = isContainsOne(matrix, k);</span><br><span class="line">        System.out.println(containsOne ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// boolean containsTwo = isContainsTwo(matrix, k);</span></span><br><span class="line">        <span class="comment">// System.out.println(containsTwo ? "Yes" : "No");</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断方式一：双重for循环</span></span><br><span class="line"><span class="comment">     * 外层循环矩阵每一行</span></span><br><span class="line"><span class="comment">     * 内层循环矩阵每一列</span></span><br><span class="line"><span class="comment">     * 相等直接返回true；</span></span><br><span class="line"><span class="comment">     * 若小于k，则排除当前行，结束内层循环，遍历下一行。</span></span><br><span class="line"><span class="comment">     * 若大于k，则排除当前列，j--，内存循环进入下一次。</span></span><br><span class="line"><span class="comment">     * 若双重循环完成都未找到k，则返回false。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isContainsOne</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = col - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> value = ints[j];</span><br><span class="line">                <span class="keyword">if</span> (value == k) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; k) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断方式二：while循环</span></span><br><span class="line"><span class="comment">     * 越界条件：行遍历完或列遍历完</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isContainsTwo</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = col - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; row &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = matrix[i][j];</span><br><span class="line">            <span class="keyword">if</span> (value == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; k) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      勇闯算法-在行列都排好序的矩阵中找指定的数，题目来源：《程序员代码面试指南-IT名企算法与数据结构最优解》-左程云著。
    
    </summary>
    
    
      <category term="算法" scheme="https://lilu.org.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="程序员代码面试指南-IT名企算法与数据结构最优解" scheme="https://lilu.org.cn/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97-IT%E5%90%8D%E4%BC%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%80%E4%BC%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>修炼xxl-job之调度中心—初始化失败任务管理中心</title>
    <link href="https://lilu.org.cn/2020/03/03/middleware/xxl-job/job-fail-monitor/"/>
    <id>https://lilu.org.cn/2020/03/03/middleware/xxl-job/job-fail-monitor/</id>
    <published>2020-03-03T13:37:19.160Z</published>
    <updated>2020-03-03T13:13:47.193Z</updated>
    
    <content type="html"><![CDATA[<p>调度中心启动时主要执行了<code>XxlJobScheduler.init()</code>方法，该方法中有六个初始化动作，这篇文章来分析第三个初始化动作：初始化失败任务管理中心。其关键调用代码为：<code>JobFailMonitorHelper.getInstance().start();</code></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>来看<code>com.xxl.job.admin.core.thread.JobFailMonitorHelper</code>类的源码。</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>先看类的主要成员变量：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/xxl-job/JobFailMonitorHelper.memberVariables.png"  alt="JobFailMonitorHelper.memberVariables"></p><ol><li>私有<code>slf4j</code>日志对象；</li><li>私有静态<code>JobFailMonitorHelper</code>类实例对象：<code>instance</code>；</li><li>私有成员变量：<code>Thread</code>类对象<code>monitorThread</code>；</li><li>私有布尔变量<code>toStop</code>，初始化为<code>false</code>。</li></ol><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><ol><li>实例<code>instance</code>的公有静态访问器<code>getInstance()</code>；</li><li>公有<code>start()</code>方法；</li><li>公有<code>toStop()</code>方法。</li><li>私有<code>failAlarm()</code>方法，用于失败告警。</li></ol><p>其中公有静态访问器<code>getInstance()</code>和私有静态<code>JobFailMonitorHelper</code>类实例对象<code>instance</code>共同形成了饿汉式单例模式。</p><h3 id="start-方法解析"><a href="#start-方法解析" class="headerlink" title="start()方法解析"></a><code>start()</code>方法解析</h3><p>可以发现该类的主要实现是在<code>start()</code>方法中，先折叠一些实现我们来看下整体。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/xxl-job/JobFailMonitorHelper.start.png"  alt="JobFailMonitorHelper.start"></p><ol><li>给私有成员变量<code>Thread</code>类对象<code>monitorThread</code>赋值，即创建一个子线程：实现<code>Runnable</code>接口并重写其<code>run</code>方法；</li><li>将其设置为守护线程；</li><li>设置线程名为：<code>xxl-job, admin JobFailMonitorHelper</code>；</li><li>调用线程的<code>start()</code>方法启动线程。</li></ol><p>这其实是一个守护线程。</p><p>我们继续来看子线程重写的<code>run</code>方法的具体实现：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/xxl-job/JobFailMonitorHelper.complete.start.png"  alt="JobFailMonitorHelper.complete.start"></p><p>看起来实现有点长，我们逐渐将其拆解来分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!toStop) &#123;</span><br></pre></td></tr></table></figure><p>循环，判断的条件为私有布尔变量<code>toStop</code>的非，而<code>toStop</code>被初始化为了<code>false</code>，所以这是一个死循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; failLogIds = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().findFailJobLogIds(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>从配置“容器”<code>com.xxl.job.admin.core.conf.XxlJobAdminConfig</code>对象中拿到<code>com.xxl.job.admin.dao.XxlJobLogDao</code>对象，调用<code>findFailJobLogIds(1000)</code>方法。这是<code>Mybatis</code>持久层的方法，来看一下其实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Mapper接口 *&#x2F;</span><br><span class="line">public List&lt;Long&gt; findFailJobLogIds(@Param(&quot;pagesize&quot;) int pagesize);</span><br><span class="line"></span><br><span class="line">&#x2F;* xml实现 *&#x2F;</span><br><span class="line">&lt;select id&#x3D;&quot;findFailJobLogIds&quot; resultType&#x3D;&quot;long&quot; &gt;</span><br><span class="line">SELECT id FROM &#96;xxl_job_log&#96;</span><br><span class="line">WHERE !(</span><br><span class="line">(trigger_code in (0, 200) and handle_code &#x3D; 0)</span><br><span class="line">OR</span><br><span class="line">(handle_code &#x3D; 200)</span><br><span class="line">)</span><br><span class="line">AND &#96;alarm_status&#96; &#x3D; 0</span><br><span class="line">ORDER BY id ASC</span><br><span class="line">LIMIT #&#123;pagesize&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p>传入的参数<code>pagesize</code>为<code>1000</code>，<code>SQL</code>的查询条件：非（调度成功 或 执行成功）。</p><p>所以此处实际上就是分页查询<code>1000</code>条失败任务日志记录的<code>failLogIds</code>。</p><p>如果存在失败的日志记录则进行遍历处理，我们往下看处理逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lockRet = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateAlarmStatus(failLogId, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (lockRet &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">XxlJobLog log = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().load(failLogId);</span><br><span class="line">XxlJobInfo info = XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().loadById(log.getJobId());</span><br></pre></td></tr></table></figure><p>调用<code>XxlJobLogDao</code>的<code>updateAlarmStatus</code>方法，来看下其<code>Mybatis</code>的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int updateAlarmStatus(@Param(&quot;logId&quot;) long logId,</span><br><span class="line"> @Param(&quot;oldAlarmStatus&quot;) int oldAlarmStatus,</span><br><span class="line"> @Param(&quot;newAlarmStatus&quot;) int newAlarmStatus);</span><br><span class="line"></span><br><span class="line">&lt;update id&#x3D;&quot;updateAlarmStatus&quot; &gt;</span><br><span class="line">    UPDATE xxl_job_log</span><br><span class="line">    SET</span><br><span class="line">        &#96;alarm_status&#96; &#x3D; #&#123;newAlarmStatus&#125;</span><br><span class="line">    WHERE &#96;id&#96;&#x3D; #&#123;logId&#125; AND &#96;alarm_status&#96; &#x3D; #&#123;oldAlarmStatus&#125;</span><br><span class="line">&lt;&#x2F;update&gt;</span><br></pre></td></tr></table></figure><p><code>CAS</code>乐观锁的方式将<code>alarm_status</code>字段从<code>0</code>更新为<code>-1</code>。</p><blockquote><p>思考：这里为什么使用乐观锁？有什么作用？</p><p>猜想：支持调度集群部署，高可用。</p></blockquote><p>如果乐观锁“加锁”成功，则根据失败任务<code>failLogId</code>加载任务日志信息和任务信息。</p><p>得到了任务必要信息后就可以进行处理了，包括重试或告警，我们继续往下看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (log.getExecutorFailRetryCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    JobTriggerPoolHelper.trigger(log.getJobId(), TriggerTypeEnum.RETRY, (log.getExecutorFailRetryCount()-<span class="number">1</span>), log.getExecutorShardingParam(), log.getExecutorParam());</span><br><span class="line">String retryMsg = <span class="string">"&lt;br&gt;&lt;br&gt;&lt;span style=\"color:#F39C12;\" &gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span>+ I18nUtil.getString(<span class="string">"jobconf_trigger_type_retry"</span>) +<span class="string">"&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; &lt;/span&gt;&lt;br&gt;"</span>;</span><br><span class="line">log.setTriggerMsg(log.getTriggerMsg() + retryMsg);</span><br><span class="line">XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateTriggerInfo(log);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断日志信息中执行器失败重试次数是否仍大于零，是则进行重试。</p><p>重试即重新进行调度，调用<code>JobTriggerPoolHelper</code>类的<code>trigger()</code>方法，传入了五个参数，我们来分别解释一下：</p><ul><li><code>log.getJobId()</code>：任务信息表自增主键。</li><li><code>TriggerTypeEnum.RETRY</code>：执行类型：重试。</li><li><code>(log.getExecutorFailRetryCount()-1)</code>：当前重试次数减一，这里传入是为了执行时存入日志表，当再次失败时可确保重试次数。</li><li><code>log.getExecutorShardingParam()</code>：执行器分片参数（分片任务用到）。</li><li><code>log.getExecutorParam()</code>：执行器执行参数。</li></ul><p>关于任务调度执行本篇文章不做详细介绍，只需知道这里触发了任务执行，并将减一后的重试次数存入了日志，若这次执行仍然失败，则可被重新查出并根据剩余重试次数进行处理。</p><p>重试完成后更新本条记录的调度日志<code>trigger_msg</code>字段。</p><p>然后进行告警处理，无论是否有重试都会进行告警处理。</p><p>我们来看告警的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> newAlarmStatus = <span class="number">0</span>;<span class="comment">// 告警状态：0-默认、-1=锁定状态、1-无需告警、2-告警成功、3-告警失败</span></span><br><span class="line"><span class="keyword">if</span> (info!=<span class="keyword">null</span> &amp;&amp; info.getAlarmEmail()!=<span class="keyword">null</span> &amp;&amp; info.getAlarmEmail().trim().length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> alarmResult = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        alarmResult = failAlarm(info, log);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        alarmResult = <span class="keyword">false</span>;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    newAlarmStatus = alarmResult?<span class="number">2</span>:<span class="number">3</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    newAlarmStatus = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateAlarmStatus(failLogId, -<span class="number">1</span>, newAlarmStatus);</span><br></pre></td></tr></table></figure><p>只有配置了告警邮箱才进行告警，核心逻辑是调用了私有成员方法<code>failAlarm</code>，根据调用情况得到新的告警状态，最后使用<code>CAS</code>的方式更新日志记录表，将<code>alarm_status</code>字段从<code>-1</code>更新为新的告警状态。</p><p>最后阻塞当前子线程<code>10</code>秒，一次循环就结束了。</p><p>而私有成员方法<code>failAlarm</code>的主要逻辑是发送邮件，调度中心<code>xxl-job-admin</code>项目配置文件中可配置告警发件邮箱，<code>Web</code>管理后台界面添加任务时可填写告警收件人邮箱。该方法有一行代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; emailSet = <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(info.getAlarmEmail().split(<span class="string">","</span>)));</span><br></pre></td></tr></table></figure><p>从而得知在管理后台界面添加任务时可填写多个告警收件人邮箱，用英文逗号分隔即可，会自动去重。</p><p>我们可在该方法中实现自定义的告警方式，例如钉钉机器人等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用以下一张图来对失败任务管理中心进行归纳总结。<br><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/xxl-job/job-fail-monitor.png"  alt="job-fail-monitor"></p>]]></content>
    
    <summary type="html">
    
      修炼xxl-job之调度中心—初始化失败任务管理中心
    
    </summary>
    
    
      <category term="中间件" scheme="https://lilu.org.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="定时任务" scheme="https://lilu.org.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
    
      <category term="xxl-job" scheme="https://lilu.org.cn/tags/xxl-job/"/>
    
  </entry>
  
  <entry>
    <title>修炼xxl-job之调度中心—初始化注册中心“心跳续约”服务</title>
    <link href="https://lilu.org.cn/2020/02/29/middleware/xxl-job/registry-center-heartbeat-renewal/"/>
    <id>https://lilu.org.cn/2020/02/29/middleware/xxl-job/registry-center-heartbeat-renewal/</id>
    <published>2020-02-29T13:37:31.090Z</published>
    <updated>2020-02-29T13:13:31.663Z</updated>
    
    <content type="html"><![CDATA[<p>调度中心启动时主要执行了<code>XxlJobScheduler.init()</code>方法，该方法中有六个初始化动作，这篇文章来分析第二个初始化动作：初始化注册中心“心跳续约”服务。其关键调用代码为：<code>JobRegistryMonitorHelper.getInstance().start();</code></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>来看<code>com.xxl.job.admin.core.thread.JobRegistryMonitorHelper</code>类的源码。</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>先看类的成员变量：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/xxl-job/JobRegistryMonitorHelper.memberVariables.png"  alt="JobRegistryMonitorHelper.memberVariables"></p><ol><li>私有<code>slf4j</code>日志对象；</li><li>私有静态<code>JobRegistryMonitorHelper</code>类实例对象：<code>instance</code>；</li><li>私有成员变量：<code>Thread</code>类对象<code>registryThread</code>；</li><li>私有布尔变量<code>toStop</code>，初始化为<code>false</code>。</li></ol><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><ol><li>实例<code>instance</code>的公有静态访问器<code>getInstance()</code>；</li><li>公有<code>start()</code>方法；</li><li>公有<code>toStop()</code>方法。</li></ol><p>其中公有静态访问器<code>getInstance()</code>和私有静态<code>JobRegistryMonitorHelper</code>类实例对象<code>instance</code>共同形成了饿汉式单例模式。</p><h3 id="start-方法解析"><a href="#start-方法解析" class="headerlink" title="start()方法解析"></a><code>start()</code>方法解析</h3><p>可以发现该类的主要实现是在<code>start()</code>方法中，先折叠一些实现我们来看下整体。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/xxl-job/JobRegistryMonitorHelper.start.png"  alt="JobRegistryMonitorHelper.start"></p><ol><li>给私有成员变量<code>Thread</code>类对象<code>registryThread</code>赋值，即创建一个子线程：实现<code>Runnable</code>接口并重写其<code>run</code>方法；</li><li>将其设置为守护线程；</li><li>设置线程名为：<code>xxl-job, admin JobRegistryMonitorHelper</code>；</li><li>调用线程的<code>start()</code>方法启动线程。</li></ol><p>这其实是一个守护线程。</p><p>我们继续来看子线程重写的<code>run</code>方法的具体实现：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/xxl-job/JobRegistryMonitorHelper.complete.start.png"  alt="JobRegistryMonitorHelper.complete.start"></p><p>看起来实现有点长，我们逐渐将其拆解来分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!toStop) &#123;</span><br></pre></td></tr></table></figure><p>循环，判断的条件为私有布尔变量<code>toStop</code>的非，而<code>toStop</code>被初始化为了<code>false</code>，所以这是一个死循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;XxlJobGroup&gt; groupList = XxlJobAdminConfig.getAdminConfig().getXxlJobGroupDao().findByAddressType(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>从配置“容器”<code>com.xxl.job.admin.core.conf.XxlJobAdminConfig</code>对象中拿到<code>com.xxl.job.admin.dao.XxlJobGroupDao</code>对象，调用<code>findByAddressType(0)</code>方法。这是<code>Mybatis</code>持久层的方法，来看一下其实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Mapper接口 *&#x2F;</span><br><span class="line">public List&lt;XxlJobGroup&gt; findByAddressType(@Param(&quot;addressType&quot;) int addressType);</span><br><span class="line"></span><br><span class="line">&#x2F;* xml实现 *&#x2F;</span><br><span class="line">&lt;select id&#x3D;&quot;findByAddressType&quot; parameterType&#x3D;&quot;java.lang.Integer&quot; resultMap&#x3D;&quot;XxlJobGroup&quot;&gt;</span><br><span class="line">SELECT &lt;include refid&#x3D;&quot;Base_Column_List&quot; &#x2F;&gt;</span><br><span class="line">FROM xxl_job_group AS t</span><br><span class="line">WHERE t.address_type &#x3D; #&#123;addressType&#125;</span><br><span class="line">ORDER BY t.order ASC</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p>传入的参数<code>addressType</code>为<code>0</code>，<code>SQL</code>的含义为：查询<code>xxl_job_group</code>表中<code>address_type</code>字段为<code>0</code>的数据并按<code>order</code>字段升序排序。</p><p>我们可以去初始化<code>sql</code>脚本中寻找该字段的含义：<code>执行器地址类型：0=自动注册、1=手动录入</code>。</p><p>所以此处代码的作用是：查询地址类型为自动注册的执行器信息列表。</p><p>如果查询出的执行器列表不为空则继续往下执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; ids = XxlJobAdminConfig.getAdminConfig()</span><br><span class="line">                                .getXxlJobRegistryDao()</span><br><span class="line">                                .findDead(RegistryConfig.DEAD_TIMEOUT, <span class="keyword">new</span> Date());</span><br><span class="line"><span class="keyword">if</span> (ids!=<span class="keyword">null</span> &amp;&amp; ids.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().removeDead(ids);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>XxlJobRegistryDao</code>的<code>findDead</code>方法，传入的参数为：</p><ul><li><code>RegistryConfig.DEAD_TIMEOUT</code>：超时时间，值为<code>90</code>；</li><li><code>new Date()</code>：当前时间对象。</li></ul><p>来看一下<code>Mybatis</code>的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; findDead(@Param(&quot;timeout&quot;) int timeout,</span><br><span class="line">                              @Param(&quot;nowTime&quot;) Date nowTime);</span><br><span class="line">                                  </span><br><span class="line">&lt;select id&#x3D;&quot;findDead&quot; parameterType&#x3D;&quot;java.util.HashMap&quot; resultType&#x3D;&quot;java.lang.Integer&quot; &gt;</span><br><span class="line">SELECT t.id</span><br><span class="line">FROM xxl_job_registry AS t</span><br><span class="line">WHERE t.update_time &lt;![CDATA[ &lt; ]]&gt; DATE_ADD(#&#123;nowTime&#125;,INTERVAL -#&#123;timeout&#125; SECOND)</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p>查询的是主键<code>id</code>列表，关键的是<code>where</code>条件，<code>xxl_job_registry</code>表的<code>update_time</code>字段小于传入的当前时间减去传入的超时时间<code>90</code>秒。</p><p>其含义为：查询出<code>90</code>秒内未更新时间的任务<code>id</code>集合列表。</p><blockquote><p>思考：这里查询时为什么选择传入<code>Java</code>时间而不是直接用<code>MySQL</code>的<code>NOW()</code>函数获取当前时间？</p><p>解答：防止<code>MySQL</code>服务器和调度中心服务器的时钟不同步。</p></blockquote><p>如果查到了记录，则调用<code>XxlJobRegistryDao</code>的<code>removeDead</code>方法。来看下其<code>Mybatis</code>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int removeDead(@Param(&quot;ids&quot;) List&lt;Integer&gt; ids);</span><br><span class="line">    </span><br><span class="line">&lt;delete id&#x3D;&quot;removeDead&quot; parameterType&#x3D;&quot;java.lang.Integer&quot; &gt;</span><br><span class="line">DELETE FROM xxl_job_registry</span><br><span class="line">WHERE id in</span><br><span class="line">&lt;foreach collection&#x3D;&quot;ids&quot; item&#x3D;&quot;item&quot; open&#x3D;&quot;(&quot; close&#x3D;&quot;)&quot; separator&#x3D;&quot;,&quot; &gt;</span><br><span class="line">#&#123;item&#125;</span><br><span class="line">&lt;&#x2F;foreach&gt;</span><br><span class="line">&lt;&#x2F;delete&gt;</span><br></pre></td></tr></table></figure><p>删除任务<code>id</code>列表对应的<code>xxl_job_registry</code>记录。</p><p>看到这里，我们应该理解到这实际上是“心跳”机制。“心跳”的最长时间间隔为<code>90</code>秒。</p><p>继续往下看，初始化了一个局部<code>HashMap</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, List&lt;String&gt;&gt; appAddressMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">List&lt;XxlJobRegistry&gt; list = XxlJobAdminConfig.getAdminConfig()</span><br><span class="line">                                    .getXxlJobRegistryDao()</span><br><span class="line">                                    .findAll(RegistryConfig.DEAD_TIMEOUT, <span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure><p>随即调用<code>XxlJobRegistryDao</code>的<code>findAll</code>方法查询出了一个<code>List&lt;XxlJobRegistry&gt;</code>集合，我们来看下查询条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;XxlJobRegistry&gt; findAll(@Param(&quot;timeout&quot;) int timeout,</span><br><span class="line">                                    @Param(&quot;nowTime&quot;) Date nowTime);</span><br><span class="line">                                        </span><br><span class="line">&lt;select id&#x3D;&quot;findAll&quot; parameterType&#x3D;&quot;java.util.HashMap&quot; resultMap&#x3D;&quot;XxlJobRegistry&quot;&gt;</span><br><span class="line">SELECT &lt;include refid&#x3D;&quot;Base_Column_List&quot; &#x2F;&gt;</span><br><span class="line">FROM xxl_job_registry AS t</span><br><span class="line">WHERE t.update_time &lt;![CDATA[ &gt; ]]&gt; DATE_ADD(#&#123;nowTime&#125;,INTERVAL -#&#123;timeout&#125; SECOND)</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p>重点是<code>where</code>条件：更新时间<code>update_time</code>大于当前时间减去“死亡”超时时间<code>90</code>秒。</p><p>即：查询上次“心跳”时间在<code>90</code>秒以内的注册列表。</p><p>实际上这是在做执行器“心跳”续约，类似于微服务中的服务续约。</p><p>我们继续往下看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XxlJobRegistry item: list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (RegistryConfig.RegistType.EXECUTOR.name().equals(item.getRegistryGroup())) &#123;</span><br><span class="line">            String appName = item.getRegistryKey();</span><br><span class="line">            List&lt;String&gt; registryList = appAddressMap.get(appName);</span><br><span class="line">            <span class="keyword">if</span> (registryList == <span class="keyword">null</span>) &#123;</span><br><span class="line">                registryList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!registryList.contains(item.getRegistryValue())) &#123;</span><br><span class="line">                registryList.add(item.getRegistryValue());</span><br><span class="line">            &#125;</span><br><span class="line">            appAddressMap.put(appName, registryList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果查询到有未“死亡”的注册列表，则对其进行“续约”：</p><ul><li>遍历查询出的注册列表。</li><li>如果注册组为执行器（这里注意到枚举<code>RegistType</code>有两个值：<code>EXECUTOR</code>（执行器）和<code>ADMIN</code>（调度中心））。</li><li>取出注册表的注册键（<code>xxl_job_registry</code>表中的<code>registry_key</code>字段）：即执行器名称<code>appName</code>。</li><li>先尝试从局部<code>map</code>变量中取出该执行器名称对应注册地址集合，若没有则新建一个空集合（懒加载思想）。</li><li>判断从<code>map</code>中取出的注册地址集合是否包含当前遍历的注册表的注册值（<code>xxl_job_registry</code>表中的<code>registry_value</code>字段），若不包含则添加至集合（去重）。</li><li>将执行器名称<code>appName</code>和注册地址集合映射至局部<code>map</code>变量。</li></ul><p>映射至局部<code>map</code>变量后，开始执行真正的“续约”动作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (XxlJobGroup group: groupList) &#123;</span><br><span class="line">    List&lt;String&gt; registryList = appAddressMap.get(group.getAppName());</span><br><span class="line">    String addressListStr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (registryList!=<span class="keyword">null</span> &amp;&amp; !registryList.isEmpty()) &#123;</span><br><span class="line">        Collections.sort(registryList);</span><br><span class="line">        addressListStr = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (String item:registryList) &#123;</span><br><span class="line">            addressListStr += item + <span class="string">","</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addressListStr = addressListStr.substring(<span class="number">0</span>, addressListStr.length()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    group.setAddressList(addressListStr);</span><br><span class="line">    XxlJobAdminConfig.getAdminConfig().getXxlJobGroupDao().update(group);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历从<code>xxl_job_group</code>表中查询出的自动注册执行器的信息列表。</li><li>从局部<code>map</code>变量中取出当前遍历执行器对应的“心跳续约”注册地址集合。</li><li>组装执行器注册地址列表，多地址逗号分隔；如果“续约”的地址集合为空，则代表当前执行器已“死亡”。</li><li>更新执行器“续约”的地址信息至<code>DB</code>：更新<code>xxl_job_group</code>表的<code>address_list</code>字段。</li></ul><p>至此，任务注册中心“心跳”机制就已完成。</p><blockquote><p>到这里我们或许有了一个疑问？<code>xxl_job_registry</code>任务注册表的记录是何时存在的？即任务是何时被注册的？<br>我们也许会在后面的文章中有所发现。</p></blockquote><p>最后，阻塞当前子线程<code>30</code>秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(RegistryConfig.BEAT_TIMEOUT);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">        logger.error(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job registry monitor thread error:&#123;&#125;"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用<code>java.util.concurrent</code>包下的枚举<code>TimeUnit</code>类的<code>sleep</code>方法进行睡眠，先指定时间单位，再指定时间大小，代码可读性更高；如果直接使用传统<code>Thread.sleep()</code>方法，传给<code>sleep</code>方法的值的单位是毫秒，即需传入<code>30*1000</code>，代码可读性不高。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用以下一副图来对注册中心“心跳续约”服务进行归纳总结。<br><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/xxl-job/registry-center-heartbeat-renewal.png"  alt="registry-center-heartbeat-renewal"></p>]]></content>
    
    <summary type="html">
    
      修炼xxl-job之调度中心—初始化注册中心“心跳续约”服务
    
    </summary>
    
    
      <category term="中间件" scheme="https://lilu.org.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="定时任务" scheme="https://lilu.org.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
    
      <category term="xxl-job" scheme="https://lilu.org.cn/tags/xxl-job/"/>
    
  </entry>
  
  <entry>
    <title>修炼xxl-job之调度中心—初始化国际化组件</title>
    <link href="https://lilu.org.cn/2020/02/27/middleware/xxl-job/initI18n/"/>
    <id>https://lilu.org.cn/2020/02/27/middleware/xxl-job/initI18n/</id>
    <published>2020-02-27T13:37:02.468Z</published>
    <updated>2020-02-27T13:13:13.420Z</updated>
    
    <content type="html"><![CDATA[<p>调度中心启动时主要执行了<code>XxlJobScheduler.init()</code>方法，该方法中有六个初始化动作，这篇文章来分析第一个初始化动作：初始化国际化组件。其关键调用代码为：<code>initI18n();</code></p><h2 id="国际化简介"><a href="#国际化简介" class="headerlink" title="国际化简介"></a>国际化简介</h2><p>国际化又称为<code>i18n</code>，来源于国际化的英文单词<code>internationalization</code>从<code>i</code>到<code>n</code>之间有<code>18</code>个英文字母。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>我们来看一下<code>initI18n()</code>方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initI18n</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ExecutorBlockStrategyEnum item:ExecutorBlockStrategyEnum.values()) &#123;</span><br><span class="line">        item.setTitle(I18nUtil.getString(<span class="string">"jobconf_block_"</span>.concat(item.name())));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环迭代枚举<code>com.xxl.job.core.enums.ExecutorBlockStrategyEnum</code>，该枚举是执行器阻塞策略枚举。只有一个<code>title</code>属性，提供了三个枚举对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ExecutorBlockStrategyEnum &#123;</span><br><span class="line"></span><br><span class="line">    SERIAL_EXECUTION(<span class="string">"Serial execution"</span>),</span><br><span class="line">    <span class="comment">/*CONCURRENT_EXECUTION("并行"),*/</span></span><br><span class="line">    DISCARD_LATER(<span class="string">"Discard Later"</span>),</span><br><span class="line">    COVER_EARLY(<span class="string">"Cover Early"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>循环中调用变异器<code>setTitle()</code>方法给每个枚举对象的<code>title</code>属性重新赋值。</p><p>工具类<code>I18nUtil</code>的<code>getString()</code>方法获取到以<code>jobconf_block_</code>开头，以枚举对象名结尾的属性值。</p><p>我们来看一下工具类<code>getString()</code>方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadI18nProp().getProperty(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了静态成员方法<code>loadI18nProp()</code>得到一个<code>Properties</code>对象，再调用其<code>getProperty()</code>方法从资源文件中获取对应<code>key</code>的值。</p><p>来看一下<code>loadI18nProp()</code>方法的实现：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/xxl-job/I18nUtil.loadI18nProp.png"  alt="I18nUtil.loadI18nProp"></p><ul><li>读取<code>application.properties</code>配置文件的<code>xxl.job.i18n</code>配置项的值;</li><li><code>build</code>组装，得到<code>i18n</code>文件路径。即<code>resources\i18n</code>目录下的<code>Resource Bundle &#39;message&#39;</code>资源包文件;</li><li>使用<code>Spring</code>提供的<code>PropertiesLoaderUtils</code>工具类加载对应资源文件。</li></ul><p>我们可以从这里知道调度中心<code>application.properties</code>的配置项<code>xxl.job.i18n</code>有两种配置，一是缺省不填，为中文；二是设置为<code>en</code>，即英文。</p><p>去<code>resources\i18n</code>目录看下资源包文件：<code>message.properties</code>和<code>message_en.properties</code>。搜索<code>jobconf_block_</code>，得到以下内容：</p><p><code>message.properties</code>：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## job conf</span></span><br><span class="line"><span class="attr">jobconf_block_SERIAL_EXECUTION</span>=<span class="string">单机串行</span></span><br><span class="line"><span class="attr">jobconf_block_DISCARD_LATER</span>=<span class="string">丢弃后续调度</span></span><br><span class="line"><span class="attr">jobconf_block_COVER_EARLY</span>=<span class="string">覆盖之前调度</span></span><br></pre></td></tr></table></figure><p><code>message_en.properties</code>：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## job conf</span></span><br><span class="line"><span class="attr">jobconf_block_SERIAL_EXECUTION</span>=<span class="string">Serial execution</span></span><br><span class="line"><span class="attr">jobconf_block_DISCARD_LATER</span>=<span class="string">Discard Later</span></span><br><span class="line"><span class="attr">jobconf_block_COVER_EARLY</span>=<span class="string">Cover Early</span></span><br></pre></td></tr></table></figure><p>可以发现键中<code>jobconf_block_</code>后接的内容即为<code>ExecutorBlockStrategyEnum</code>枚举的<code>name</code>值。一共有三个阻塞策略：单机串行、丢弃后续调度和覆盖之前调度。</p><p><code>initI18n()</code>方法的迭代完成后，枚举的<code>title</code>属性值就变成了对应的国际化设置。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要是分析了调度中心国际化组件的初始化原理。接下来我们将继续分析调度中心启动的其它初始化动作。</p>]]></content>
    
    <summary type="html">
    
      修炼xxl-job之调度中心—初始化国际化组件
    
    </summary>
    
    
      <category term="中间件" scheme="https://lilu.org.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="定时任务" scheme="https://lilu.org.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
    
      <category term="xxl-job" scheme="https://lilu.org.cn/tags/xxl-job/"/>
    
  </entry>
  
  <entry>
    <title>修炼xxl-job之调度中心启动流程解析</title>
    <link href="https://lilu.org.cn/2020/02/26/middleware/xxl-job/dispatch-center-start-process-analysis/"/>
    <id>https://lilu.org.cn/2020/02/26/middleware/xxl-job/dispatch-center-start-process-analysis/</id>
    <published>2020-02-26T13:36:46.443Z</published>
    <updated>2020-02-26T13:12:57.392Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要是解析调度中心<code>xxl-job-admin</code>启动流程。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>我们先来看一下调度中心项目的<code>maven</code>依赖。依赖了<code>Spring Boot</code>的一些<code>starter</code>依赖：<code>web</code>、<code>test</code>、<code>freemarker</code>、<code>mail</code>、<code>actuator</code>和<code>mybatis</code>等，最后依赖了<code>xxl-job-core</code>包。</p><p>还记得我们在 <a href="/2020/02/13/middleware/xxl-job/build-local-dispatch-platform/">修炼xxl-job之搭建本地调度平台</a> 时启动调度中心过程中控制台输出的一句日志吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13:01:40.001 logback [xxl-job, admin JobScheduleHelper#scheduleThread] INFO  c.x.j.a.c.thread.JobScheduleHelper - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin scheduler success.</span><br></pre></td></tr></table></figure><p><code>JobScheduleHelper</code>类打印了<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin scheduler success.</code>。表示初始化任务调度器成功。</p><h2 id="启动分析"><a href="#启动分析" class="headerlink" title="启动分析"></a>启动分析</h2><p>我们找到<code>com.xxl.job.admin.core.thread.JobScheduleHelper</code>类中打印启动日志的代码，发现其在该类的<code>start</code>方法中，<code>start</code>方法初始化了一个子线程，在子线程中打印了日志。</p><p>那么该<code>start</code>方法是何时被执行的呢？我们发现该类并未交由<code>Spring</code>管理，借助于<code>IDEA</code>的快捷键<code>Ctrl+Alt+H</code>查看该方法的调用处，发现其在<code>XxlJobScheduler.init()</code>方法中被调用了，来看一下<code>init</code>方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// init i18n</span></span><br><span class="line">    initI18n();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// admin registry monitor run</span></span><br><span class="line">    JobRegistryMonitorHelper.getInstance().start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// admin monitor run</span></span><br><span class="line">    JobFailMonitorHelper.getInstance().start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// admin trigger pool start</span></span><br><span class="line">    JobTriggerPoolHelper.toStart();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// admin log report start</span></span><br><span class="line">    JobLogReportHelper.getInstance().start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start-schedule</span></span><br><span class="line">    JobScheduleHelper.getInstance().start();</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin success."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JobScheduleHelper.getInstance().start();</code>这一行代码使用“饿汉式”单例模式得到<code>JobScheduleHelper</code>类对象并随之调用了其<code>start</code>方法，然后打印了一行日志：<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin success.</code>。</p><p>思考：既然<code>JobScheduleHelper</code>类中的子线程中的日志都进行了打印，那么在其之后的日志打印在了何处呢？</p><p>我们复制代码中的日志信息，前往调度中心启动的控制台中按下<code>Ctrl+F</code>搜索相关信息，发现确实打印了，并且打印的位置非常靠前。</p><p>再来看一下<code>init()</code>方法的写法，几乎都是调用某个<code>XxxxxHelper</code>类的<code>getInstance()</code>方法然后再调用其<code>start()</code>方法。</p><p>猜想：这里所有的<code>XxxxxHelper</code>类的<code>start()</code>方法都是开启子线程执行相关任务，才导致<code>init()</code>方法中的日志打印位置非常靠前。</p><p>实际上这是全异步化设计思想的体现。</p><p>我们发现<code>init()</code>方法所在的类<code>XxlJobScheduler</code>也未交由<code>Spring</code>管理，继续借助<code>IDEA</code>的快捷键<code>Ctrl+Alt+H</code>查看<code>init()</code>方法的调用处，发现是在<code>XxlJobAdminConfig.afterPropertiesSet()</code>方法中被调用的。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/xxl-job/XxlJobAdminConfig.afterPropertiesSet.png"  alt="XxlJobAdminConfig.afterPropertiesSet"></p><p><code>XxlJobAdminConfig</code>类使用<code>@Component</code>注解交由<code>Spring</code>进行管理，并实现了<code>InitializingBean</code>和<code>DisposableBean</code>这两个接口，重写的<code>afterPropertiesSet()</code>方法中只有简单的三行代码，第二行使用<code>new</code>关键字创建了<code>XxlJobScheduler</code>对象赋给私有成员变量<code>xxlJobScheduler</code>，随后第三行调用了其<code>init()</code>方法。</p><p>至此，我们找到了启动的起点，不妨先来分析一下这个“起点类”。</p><p>从类名来看，它是一个配置类。其第一个静态成员变量<code>adminConfig</code>是它本身，并在<code>afterPropertiesSet()</code>方法的第一行将<code>this</code>关键字赋给了该变量。</p><p>这是什么意思？“自身包含自身”吗？在该静态成员变量下还提供了一个静态方法<code>getAdminConfig()</code>用来获取该静态成员变量的引用。那我可以无限链式调用静态方法<code>getAdminConfig()</code>了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XxlJobAdminConfig.getAdminConfig().getAdminConfig().getAdminConfig().......getAdminConfig();</span><br></pre></td></tr></table></figure><p>只有第一次调用是通过类名.静态方法名，第一次调用返回了类的实例对象<code>adminConfig</code>，所以第二次以及之后的每次链式调用都是通过实例对象.静态方法名。这是不被建议和认可的，编译器也发出了黄色警告。所以每次使用时建议是只调用一次，调用一次就拿到了<code>XxlJobAdminConfig</code>类的对象，多次链式调用并无任何作用。</p><p>再来看一下<code>XxlJobAdminConfig</code>类的其它成员变量，发现是一些通过<code>@Value</code>注解获取的一些配置信息，还有一些是通过<code>@Resource</code>注解注入的<code>XxxxxxDao</code>类和其它业务类，同时提供了每个成员变量的访问器（<code>getter</code>方法）。</p><p>为什么这么做呢？为什么要将这些<code>XxxxxxDao</code>等类放到这里并提供访问器呢？</p><p>简单猜想：实际上<code>XxlJobAdminConfig</code>可以看做是一个简单的“容器”，调度中心在启动时将整个系统需要用到的配置信息和<code>XxxxxxDao</code>类对象初始化到该“容器”中，在需要使用某个<code>XxxxxxDao</code>类时，不使用<code>Spring</code>的依赖注入，而是从该“容器”中拿，还记得前面分析过的静态方法<code>getAdminConfig()</code>，它返回了<code>XxlJobAdminConfig</code>类的对象，我们可以这样来使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XxlJobAdminConfig.getAdminConfig().getXxxxxxDao()</span><br></pre></td></tr></table></figure><p>这样做有什么好处呢？</p><p>猜想：这样做对系统的配置信息和依赖信息进行了统一管理，有一种全局配置感。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要分析了调度中心项目<code>xxl-job-admin</code>的启动流程。发现主要执行了<code>XxlJobScheduler.init()</code>方法，该方法中有六个初始化动作，接下来我们会逐个进行分析。</p><ul><li><a href="/2020/02/27/middleware/xxl-job/initI18n/">初始化国际化组件</a></li></ul>]]></content>
    
    <summary type="html">
    
      修炼xxl-job之调度中心启动流程解析
    
    </summary>
    
    
      <category term="中间件" scheme="https://lilu.org.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="定时任务" scheme="https://lilu.org.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
    
      <category term="xxl-job" scheme="https://lilu.org.cn/tags/xxl-job/"/>
    
  </entry>
  
  <entry>
    <title>Docker常用命令</title>
    <link href="https://lilu.org.cn/2020/02/19/docker/docker-common-commands/"/>
    <id>https://lilu.org.cn/2020/02/19/docker/docker-common-commands/</id>
    <published>2020-02-19T13:33:57.247Z</published>
    <updated>2020-02-19T13:12:12.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>yum install -y yum-utils device-mapper-persistent-data lvm2</code></p><p><code>yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code></p><p><code>yum install docker-ce docker-ce-cli containerd.io</code></p><h2 id="设为开机启动"><a href="#设为开机启动" class="headerlink" title="设为开机启动"></a>设为开机启动</h2><p><code>systemctl enable docker</code></p><p>非常重要！！！否则可能重启机器后再次启动<code>docker</code>时会出现以下错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to start docker: Unit docker is masked.</span><br></pre></td></tr></table></figure><h2 id="查看运行状态"><a href="#查看运行状态" class="headerlink" title="查看运行状态"></a>查看运行状态</h2><p><code>systemctl status docker</code></p><h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2><p><code>systemctl stop docker</code></p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p><code>systemctl start docker</code></p><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><p><code>systemctl restart docker</code></p><h2 id="查看版本信息"><a href="#查看版本信息" class="headerlink" title="查看版本信息"></a>查看版本信息</h2><p><code>docker version</code></p><h2 id="查看命令帮助"><a href="#查看命令帮助" class="headerlink" title="查看命令帮助"></a>查看命令帮助</h2><p><code>docker --help</code></p><h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><p><code>docker images</code></p><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p><code>docker pull [OPTIONS] NAME[:tag]</code></p><h2 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h2><p>参考 <a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener">阿里云容器镜像加速器服务</a></p><h2 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h2><p><code>docker search NAME</code></p><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><p><code>docker rmi NAME1/ID1 NAME2/ID2</code></p><h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><ul><li>查看正在运行的容器：<code>docker ps</code></li><li>查看所有容器：<code>docker ps -a</code></li><li>查看最后一次运行的容器：<code>docker ps -l</code></li></ul><h2 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h2><p><code>exit</code></p><h2 id="创建交互式容器"><a href="#创建交互式容器" class="headerlink" title="创建交互式容器"></a>创建交互式容器</h2><p><code>docker run -i -t --name=[NAME] IMAGE /bin/bash</code></p><ul><li><code>-i</code>：交互式操作</li><li><code>-t</code>：分配一个可操作容器的终端</li><li><code>--name=[NAME]</code>：指定容器名称（唯一）</li></ul><p>可选参数可合并：<br><code>docker run -it --name [NAME] IMAGE /bin/bash</code></p><p>交互式容器<code>exit</code>退出后容器自动关闭。</p><h2 id="创建守护式容器"><a href="#创建守护式容器" class="headerlink" title="创建守护式容器"></a>创建守护式容器</h2><p><code>docker run -itd --name NAME IMAGE /bin/bash</code></p><p><code>-d</code>：指定容器运行模式</p><h2 id="进入守护式容器"><a href="#进入守护式容器" class="headerlink" title="进入守护式容器"></a>进入守护式容器</h2><p><code>docker exec -it [CONTAINER ID] /bin/bash</code></p><p>守护式容器<code>exit</code>退出后容器继续运行。</p><h2 id="启动已停止运行的容器"><a href="#启动已停止运行的容器" class="headerlink" title="启动已停止运行的容器"></a>启动已停止运行的容器</h2><p><code>docker start [CONTAINER ID]</code></p><h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><p><code>docker stop [CONTAINER ID]</code></p><h2 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h2><p><code>docker restart [CONTAINER ID]</code></p><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p><code>docker rm -f [CONTAINER ID]</code></p><p>删除时容器必须是停止状态。</p><p>删除全部容器（先查询出所有容器再删除）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm &#96;docker ps -a -q&#96;</span><br></pre></td></tr></table></figure><h2 id="查看容器详细信息"><a href="#查看容器详细信息" class="headerlink" title="查看容器详细信息"></a>查看容器详细信息</h2><p><code>docker inspect [CONTAINER NAME]</code></p><h2 id="查看容器详细信息中某个属性的详细信息"><a href="#查看容器详细信息中某个属性的详细信息" class="headerlink" title="查看容器详细信息中某个属性的详细信息"></a>查看容器详细信息中某个属性的详细信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#96;docker inspect -f&#x3D;&#39;&#123;&#123;.[属性名]&#125;&#125;&#39; [CONTAINER NAME]&#96;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">&#96;docker inspect --format&#x3D;&#39;&#123;&#123;.[属性名]&#125;&#125;&#39; [CONTAINER NAME]&#96;</span><br></pre></td></tr></table></figure><h2 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h2><p><code>docker cp source target</code></p><p>可将宿主机的文件/目录拷贝至容器或将容器内的文件/目录拷贝至宿主机。</p><p><code>example</code>：</p><p>从宿主机（source）拷贝至容器内（target）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp .&#x2F;1.txt container1:&#x2F;root</span><br></pre></td></tr></table></figure><p>从容器内（source）拷贝至宿主机（target）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp container1:&#x2F;root .&#x2F;1.txt</span><br></pre></td></tr></table></figure><h2 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h2><p>创建容器时指定<code>-p</code>参数将容器内端口映射到宿主机的端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name&#x3D;NAME -p 宿主机端口:容器端口 IMAGE &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><h2 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h2><p>创建容器时指定<code>-v</code>参数进行目录挂载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name&#x3D;NAME -v 宿主机目录:容器目录 IMAGE &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><h2 id="镜像打包"><a href="#镜像打包" class="headerlink" title="镜像打包"></a>镜像打包</h2><p><code>docker save -o [dir/NAME.tar] IMAGE_NAME</code></p><h2 id="将打包的镜像上传至其它服务器"><a href="#将打包的镜像上传至其它服务器" class="headerlink" title="将打包的镜像上传至其它服务器"></a>将打包的镜像上传至其它服务器</h2><p><code>scp ./NAME.tar ip:/root/dir</code></p><h2 id="导入打包镜像"><a href="#导入打包镜像" class="headerlink" title="导入打包镜像"></a>导入打包镜像</h2><p><code>docker load -i /root/dir/NAME.tar</code></p><h2 id="容器打包"><a href="#容器打包" class="headerlink" title="容器打包"></a>容器打包</h2><p><code>docker export -o /root/CONTAINER_NAME.tar CONTAINER_NAME</code></p><h2 id="导入打包容器"><a href="#导入打包容器" class="headerlink" title="导入打包容器"></a>导入打包容器</h2><p><code>docker import CONTAINER_NAME.tar CONTAINER_NAME</code></p>]]></content>
    
    <summary type="html">
    
      记录Docker常用命令
    
    </summary>
    
    
      <category term="Docker" scheme="https://lilu.org.cn/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://lilu.org.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>创建mysql5.7的Docker容器</title>
    <link href="https://lilu.org.cn/2020/02/19/docker/create-mysql-container/"/>
    <id>https://lilu.org.cn/2020/02/19/docker/create-mysql-container/</id>
    <published>2020-02-19T13:33:57.244Z</published>
    <updated>2020-02-19T13:12:09.325Z</updated>
    
    <content type="html"><![CDATA[<h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure><h2 id="创建挂载目录"><a href="#创建挂载目录" class="headerlink" title="创建挂载目录"></a>创建挂载目录</h2><p>如果不创建挂载目录，一旦容器重启，则数据会全部丢失。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;software&#x2F;mysql&#x2F;data &#x2F;usr&#x2F;local&#x2F;software&#x2F;mysql&#x2F;logs &#x2F;usr&#x2F;local&#x2F;software&#x2F;mysql&#x2F;conf</span><br></pre></td></tr></table></figure><h2 id="创建mysql配置文件"><a href="#创建mysql配置文件" class="headerlink" title="创建mysql配置文件"></a>创建<code>mysql</code>配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;software&#x2F;mysql</span><br><span class="line">touch my.cnf</span><br><span class="line">vim my.cnf</span><br></pre></td></tr></table></figure><p>配置文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">user&#x3D;mysql</span><br><span class="line">character-set-server&#x3D;utf8</span><br><span class="line">default_authentication_plugin&#x3D;mysql_native_password</span><br><span class="line">secure_file_priv&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">expire_logs_days&#x3D;7</span><br><span class="line">sql_mode&#x3D;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span><br><span class="line">max_connections&#x3D;1000</span><br><span class="line"> </span><br><span class="line">[client]</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line"> </span><br><span class="line">[mysql]</span><br><span class="line">default-character-set&#x3D;utf8</span><br></pre></td></tr></table></figure><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --restart&#x3D;always -p 3306:3306 --name mysql5.7 -v &#x2F;usr&#x2F;local&#x2F;software&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql -v &#x2F;usr&#x2F;local&#x2F;software&#x2F;mysql&#x2F;logs:&#x2F;var&#x2F;log&#x2F;mysql -v &#x2F;usr&#x2F;local&#x2F;software&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql -v &#x2F;usr&#x2F;local&#x2F;software&#x2F;mysql&#x2F;my.cnf:&#x2F;etc&#x2F;mysql&#x2F;my.cnf -e MYSQL_ROOT_PASSWORD&#x3D;123456 -d mysql:5.7</span><br></pre></td></tr></table></figure><ul><li><code>--restart=always</code>：当docker重启时，容器也重启。</li><li><code>--name</code>：容器名称。</li><li><code>-p 3306:3306</code>：宿主机：容器端口映射。</li><li><code>-v source:target</code>：目录挂载。</li><li><code>-e</code>：设置环境变量（<code>mysql</code>密码）。</li><li><code>-d</code>：后台启动。</li></ul>]]></content>
    
    <summary type="html">
    
      创建mysql5.7的Docker容器
    
    </summary>
    
    
      <category term="Docker" scheme="https://lilu.org.cn/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://lilu.org.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>修炼xxl-job之执行器项目七大配置项解析</title>
    <link href="https://lilu.org.cn/2020/02/13/middleware/xxl-job/demo-executor-xxljobconfig-sourcecode-analysis/"/>
    <id>https://lilu.org.cn/2020/02/13/middleware/xxl-job/demo-executor-xxljobconfig-sourcecode-analysis/</id>
    <published>2020-02-13T13:36:28.532Z</published>
    <updated>2020-02-13T13:11:34.669Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要是解析执行器项目七大配置项作用和原理。我们以示例执行器<code>xxl-job-executor-sample-springboot</code>项目为例。</p><h2 id="工程结构介绍"><a href="#工程结构介绍" class="headerlink" title="工程结构介绍"></a>工程结构介绍</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">├─java</span><br><span class="line">│  └─com</span><br><span class="line">│      └─xxl</span><br><span class="line">│          └─job</span><br><span class="line">│              └─executor</span><br><span class="line">│                  │  XxlJobExecutorApplication.java  ------启动类</span><br><span class="line">│                  │</span><br><span class="line">│                  ├─core</span><br><span class="line">│                  │  └─config</span><br><span class="line">│                  │          XxlJobConfig.java       ------XxlJobSpringExecutor配置类</span><br><span class="line">│                  │</span><br><span class="line">│                  ├─mvc</span><br><span class="line">│                  │  └─controller</span><br><span class="line">│                  │          IndexController.java    ------空文件</span><br><span class="line">│                  │</span><br><span class="line">│                  └─service</span><br><span class="line">│                      └─jobhandler</span><br><span class="line">│                              SampleXxlJob.java      ------示例执行器类</span><br><span class="line">│</span><br><span class="line">└─resources</span><br><span class="line">        application.properties                        ------项目配置文件</span><br><span class="line">        logback.xml                                   ------日志配置文件</span><br></pre></td></tr></table></figure><h2 id="com-xxl-job-executor-core-config-XxlJobConfig配置类解读"><a href="#com-xxl-job-executor-core-config-XxlJobConfig配置类解读" class="headerlink" title="com.xxl.job.executor.core.config.XxlJobConfig配置类解读"></a><code>com.xxl.job.executor.core.config.XxlJobConfig</code>配置类解读</h2><p>由于是<code>SpringBoot</code>项目，该类采用<code>@Configuration</code>注解添加配置。</p><h3 id="成员变量简介"><a href="#成员变量简介" class="headerlink" title="成员变量简介"></a>成员变量简介</h3><p>该配置类一共包含八个成员变量。</p><h4 id="日志对象"><a href="#日志对象" class="headerlink" title="日志对象"></a>日志对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(XxlJobConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p><code>slf4j</code>的日志对象，用来打印关键日志。</p><h4 id="七大核心属性变量"><a href="#七大核心属性变量" class="headerlink" title="七大核心属性变量"></a>七大核心属性变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;xxl.job.admin.addresses&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String adminAddresses;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;xxl.job.executor.appname&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String appName;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;xxl.job.executor.ip&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String ip;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;xxl.job.executor.port&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;xxl.job.accessToken&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String accessToken;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;xxl.job.executor.logpath&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String logPath;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;xxl.job.executor.logretentiondays&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> logRetentionDays;</span><br></pre></td></tr></table></figure><p>使用<code>Spring</code>提供的<code>@Value</code>注解来注入配置文件<code>application.properties</code>中的配置信息。</p><p>我们打开<code>resources</code>目录下的<code>application.properties</code>文件查看，默认配置信息如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### xxl-job admin address list, such as "http://address" or "http://address01,http://address02"</span></span><br><span class="line"><span class="meta">xxl.job.admin.addresses</span>=<span class="string">http://127.0.0.1:8080/xxl-job-admin</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### xxl-job executor address</span></span><br><span class="line"><span class="meta">xxl.job.executor.appname</span>=<span class="string">xxl-job-executor-sample</span></span><br><span class="line"><span class="meta">xxl.job.executor.ip</span>=<span class="string"></span></span><br><span class="line"><span class="meta">xxl.job.executor.port</span>=<span class="string">9999</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### xxl-job, access token</span></span><br><span class="line"><span class="meta">xxl.job.accessToken</span>=<span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="comment">### xxl-job log path</span></span><br><span class="line"><span class="meta">xxl.job.executor.logpath</span>=<span class="string">/data/applogs/xxl-job/jobhandler</span></span><br><span class="line"><span class="comment">### xxl-job log retention days</span></span><br><span class="line"><span class="meta">xxl.job.executor.logretentiondays</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure><p>根据配置文件中的相关注释我们来解释七大核心属性的含义：</p><ul><li><code>adminAddresses</code>：<ul><li>配置项：<code>xxl.job.admin.addresses</code>，选填。</li><li>含义：调度中心部署根地址。</li><li>作用：执行器会使用该地址进行“执行器心跳注册”和任务结果回调。</li><li>注意事项：如调度中心集群部署，存在多个根地址，则用逗号分隔。为空不填则关闭自动注册功能。</li></ul></li><li><code>appName</code>：<ul><li>配置项：<code>xxl.job.executor.appname</code>，选填。</li><li>含义：是每个执行器集群的唯一标示AppName。</li><li>作用：执行器心跳注册分组依据。</li><li>注意事项：为空不填表示关闭自动注册功能。</li></ul></li><li><code>ip</code>：<ul><li>配置项：<code>xxl.job.executor.ip</code>，选填。</li><li>含义：执行器<code>IP</code>。</li><li>作用：适用于多网卡时手动设置指定<code>IP</code>，该<code>IP</code>不会绑定<code>Host</code>仅作为通讯使用；用于“执行器注册”和“调度中心请求并触发任务”。</li><li>注意事项：为空不填表示自动获取<code>IP</code>。</li></ul></li><li><code>port</code>：<ul><li>配置项：<code>xxl.job.executor.port</code>，选填。</li><li>含义：执行器端口号。执行器实际是一个内嵌的<code>Server</code>，默认端口<code>9999</code>。</li><li>作用：用于“执行器注册”和“调度中心请求并触发任务”时通讯。</li><li>注意事项：小于等于<code>0</code>时自动获取。单机部署多个执行器时，不同执行器端口不能相同。</li></ul></li><li><code>accessToken</code>：<ul><li>配置项：<code>xxl.job.accessToken</code>，选填。</li><li>含义：访问令牌。</li><li>作用：为提升系统安全性，调度中心和执行器进行安全性校验，双方<code>accessToken</code>匹配才允许通讯。</li><li>注意事项：正常通讯只有两种设置；<ul><li>设置一：调度中心和执行器均不设置<code>accessToken</code>，关闭访问令牌校验。</li><li>设置二：调度中心和执行器设置相同的<code>accessToken</code>。</li></ul></li></ul></li><li><code>logPath</code>：<ul><li>配置项：<code>xxl.job.executor.logpath</code>，选填。</li><li>含义：执行器运行日志文件存储磁盘路径。</li><li>作用：设置执行器运行日志文件存储磁盘路径。</li><li>注意事项：需要对设置的路径拥有读写权限；为空则使用默认路径（<code>/data/applogs/xxl-job/jobhandler</code>）。</li></ul></li><li><code>logRetentionDays</code>：<ul><li>配置项：<code>xxl.job.executor.logretentiondays</code>，选填。</li><li>含义：执行器日志文件保存天数。</li><li>作用：设置过期日志自动清理。</li><li>注意事项：设置的值大于等于<code>3</code>时生效；否则日志自动清理功能关闭。</li></ul></li></ul><h3 id="com-xxl-job-executor-core-config-XxlJobConfig-xxlJobExecutor方法作用"><a href="#com-xxl-job-executor-core-config-XxlJobConfig-xxlJobExecutor方法作用" class="headerlink" title="com.xxl.job.executor.core.config.XxlJobConfig#xxlJobExecutor方法作用"></a><code>com.xxl.job.executor.core.config.XxlJobConfig#xxlJobExecutor</code>方法作用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> XxlJobSpringExecutor <span class="title">xxlJobExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init."</span>);</span><br><span class="line">    XxlJobSpringExecutor xxlJobSpringExecutor = <span class="keyword">new</span> XxlJobSpringExecutor();</span><br><span class="line">    xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">    xxlJobSpringExecutor.setAppName(appName);</span><br><span class="line">    xxlJobSpringExecutor.setIp(ip);</span><br><span class="line">    xxlJobSpringExecutor.setPort(port);</span><br><span class="line">    xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">    xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">    xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上一部分列举出的七大属性最终设置给了<code>com.xxl.job.core.executor.impl.XxlJobSpringExecutor</code>这个类的对象，并使用<code>@Bean</code>注解交由<code>Spring</code>进行管理。该方法中打印的日志信息 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.</code> 我们在启动执行器时控制台有输出。</p><h2 id="七大属性配置详解"><a href="#七大属性配置详解" class="headerlink" title="七大属性配置详解"></a>七大属性配置详解</h2><p>上一部分列举出了每个属性的注意事项等，这一部分我们去源码中验证上一部分的内容。</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>我们要找到上述七大属性在设置给<code>com.xxl.job.core.executor.impl.XxlJobSpringExecutor</code>这个类的对象时是如何以及怎样进行条件限制的。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>从<code>com.xxl.job.executor.core.config.XxlJobConfig#xxlJobExecutor</code>方法来看，这些配置从配置文件中读到值后是直接使用变异器（<code>setter</code>方法）设置给<code>xxlJobSpringExecutor</code>这个对象，然后就把这个对象交给<code>Spring</code>进行管理了，所以只有两种可能，第一是在变异器中进行了逻辑处理，第二是在<code>Spring</code>加载<code>bean</code>的过程中进行了逻辑处理。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>我们首先看一下<code>com.xxl.job.core.executor.impl.XxlJobSpringExecutor</code>这个类的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XxlJobSpringExecutor</span> <span class="keyword">extends</span> <span class="title">XxlJobExecutor</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>该类继承了<code>com.xxl.job.core.executor.XxlJobExecutor</code>父类并实现了<code>Spring</code>的三个接口；我们在该类中未找属性对应的变异器，所以我们几乎可以断定这些属性是定义在父类中。</p><p>我们来看父类的代码</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/Xg4kodaAcUKtLG9.jpg"  alt="XxlJobExecutor变异器.png"></p><p>变异器只是单纯的把传入的值设置给对象，所以排除了第一种可能，情况只能是第二种：在<code>Spring</code>加载<code>bean</code>的过程中进行了逻辑处理。</p><p>我们继续往下看父类<code>XxlJobExecutor</code>的代码，发现<code>start</code>方法中用到了这些属性，接下来我们来仔细阅读以下该方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---------------------- start + stop ----------------------</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init logpath</span></span><br><span class="line">    XxlJobFileAppender.initLogPath(logPath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init invoker, admin-client</span></span><br><span class="line">    initAdminBizList(adminAddresses, accessToken);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// init JobLogFileCleanThread</span></span><br><span class="line">    JobLogFileCleanThread.getInstance().start(logRetentionDays);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init TriggerCallbackThread</span></span><br><span class="line">    TriggerCallbackThread.getInstance().start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init executor-server</span></span><br><span class="line">    port = port&gt;<span class="number">0</span>?port: NetUtil.findAvailablePort(<span class="number">9999</span>);</span><br><span class="line">    ip = (ip!=<span class="keyword">null</span>&amp;&amp;ip.trim().length()&gt;<span class="number">0</span>)?ip: IpUtil.getIp();</span><br><span class="line">    initRpcProvider(ip, port, appName, accessToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共有七行核心代码，我们一行一行的来解读：</p><ol><li><code>XxlJobFileAppender.initLogPath(logPath);</code></li></ol><p>从方法名来看显然是初始化日志存储路径，我们进入<code>XxlJobFileAppender</code>类查看<code>initLogPath(logPath)</code>方法，代码如下：</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/DswcF91RrLxi4Ca.jpg"  alt="XxlJobFileAppender_initLogPath.png"></p><p>我们可以看到静态成员变量<code>logBasePath</code>的值为<code>/data/applogs/xxl-job/jobhandler</code>，当<code>logPath</code>属性未配置时该路径即为日志存盘的默认路径。</p><p>该方法的实现思路如下：</p><ul><li>如果配置的<code>logPath</code>不为空则覆盖静态成员变量<code>logBasePath</code>的值。</li><li>以静态成员变量<code>logBasePath</code>的值调用<code>File</code>类的<code>mkdirs</code>方法创建多级文件目录。</li><li>调用<code>File</code>类的<code>getPath</code>方法将创建好的文件夹的路径重新赋值给静态成员变量<code>logBasePath</code>。</li></ul><p>以上就是属性<code>logPath</code>的配置方式。</p><ol start="2"><li><code>initAdminBizList(adminAddresses, accessToken);</code></li></ol><p>从方法名来看该方法的作用是初始化调度中心部署根地址集合，其参数是配置项<code>adminAddresses</code>和<code>accessToken</code>的值。我们来看该方法的具体实现：</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/KANYOLTaBfeh3mx.jpg"  alt="initAdminBizList.png"></p><p>该方法的实现思路如下：</p><ul><li>判断传入的配置项<code>adminAddresses</code>的值是否为<code>null</code>并且去除两端空格后的长度是否大于零。</li><li>如果不满足第一步的条件则什么也不做，即关闭自动注册功能；如果满足第一步的条件，则去除两端空格后调用<code>split</code>方法以英文逗号<code>,</code>分割成字符串数组进行遍历，遍历的第一步是限制数组中的单个地址值不为<code>null</code>并且去除两端空格后的长度大于零，这一步是为了防止<code>,http://127.0.0.1:8080/xxl-job-admin,</code>等类似误配置。</li><li>一切限制条件通过后开始创建<code>com.xxl.job.core.biz.client.AdminBizClient</code>类的对象，并添加至静态成员变量<code>adminBizList</code>集合中。这里是在第一次循环时才使用<code>new</code>关键字创建<code>ArrayList</code>集合对象，其思想是“懒加载”，用时才去创建对象。由于<code>Spring</code>的<code>bean</code>的默认作用域是单例的，所以保证了该初始化方法只会执行一次。</li></ul><p>我们来看一下<code>com.xxl.job.core.biz.client.AdminBizClient</code>类的构造方法：</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/on4UPLwMYal8jsm.png"  alt="AdminBizClient_AdminBizClient.png"></p><p>构造方法中对传入的<code>addressUrl</code>进行了简单的<code>valid</code>校验，如果不是以<code>/</code>结尾则将<code>/</code>拼接至末尾。此处可看出我们的<code>adminAddresses</code>配置实际会变成类似<code>http://127.0.0.1:8080/xxl-job-admin/</code>这样的字符串。至于该类对象什么时候使用我们暂时没有线索，大可先不关注这个。</p><ol start="3"><li><code>JobLogFileCleanThread.getInstance().start(logRetentionDays);</code></li></ol><p>调用<code>JobLogFileCleanThread</code>类的<code>getInstance</code>方法取得该类对象再调用其<code>start(final long logRetentionDays)</code>方法。</p><p>从类名来看是清除日志文件的线程。</p><p>我们前往<code>com.xxl.job.core.thread.JobLogFileCleanThread</code>类看一下<code>getInstance</code>方法，会发现有如下两行关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> JobLogFileCleanThread instance = <span class="keyword">new</span> JobLogFileCleanThread();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobLogFileCleanThread <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是“饿汉式”单例模式的写法，创建了单例的<code>JobLogFileCleanThread</code>对象。</p><p>接下来看一下<code>start</code>方法：</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/V7KL4TDFZdYaqrj.png"  alt="JobLogFileCleanThread_start.png"></p><p>首先第一步检查设置的<code>logRetentionDays</code>属性是否小于<code>3</code>，小于则直接<code>return</code>；这里说明了配置文件中的值设置小于<code>3</code>时关闭日志自动清理功能。</p><p>该方法中实例化了成员变量<code>private Thread localThread;</code>，调用了<code>setDaemon(true)</code>方法将该线程设置为守护线程，并调用<code>setName</code>方法将线程名设为了<code>xxl-job, executor JobLogFileCleanThread</code>。</p><p>线程中运行的<code>run</code>方法逻辑大致如下：</p><ul><li>调用<code>XxlJobFileAppender.getLogPath()</code>方法获取设置的日志存盘路径</li><li>遍历该路径下所有文件夹，判断当前时间与文件夹的创建时间之差是否大于等于设置的<code>logRetentionDays</code>天数，如果大于则调用工具类<code>com.xxl.job.core.util.FileUtil</code>的<code>deleteRecursively</code>方法递归删除文件夹下的所有文件。</li><li>删除逻辑完成后，有这样一行代码：<code>TimeUnit.DAYS.sleep(1);</code>，线程睡眠一天。这里调用并发包下的<code>TimeUnit</code>类的<code>sleep</code>方法让代码可读性更高，如果直接使用传统<code>Thread.sleep()</code>方法，传给<code>sleep</code>方法的值的单位是毫秒，即需传入<code>24*60*60*1000</code>，代码可读性不高。</li></ul><ol start="4"><li><code>TriggerCallbackThread.getInstance().start();</code></li></ol><p>从类名<code>TriggerCallbackThread</code>来看，这是执行器回调线程，由于未使用到配置参数，这篇文章不对其进行展开解读。</p><ol start="5"><li><code>port = port&gt;0?port: NetUtil.findAvailablePort(9999);</code></li></ol><p>初始化<code>port</code>端口号。</p><p>如果配置文件中设置的端口号大于零，则使用配置文件中的值；</p><p>否则执行代码<code>NetUtil.findAvailablePort(9999);</code>，我们进入<code>NetUtil</code>类查看<code>findAvailablePort</code>方法，发现这个类属于<code>com.xxl.rpc.util</code>包，可见，<code>xxl-job</code>依赖了<code>xxl-rpc</code>（这是作者许雪里开源的<code>rpc</code>框架）。</p><p>从方法名来看作用是“寻找可用端口”，我们来看一下<code>findAvailablePort</code>方法的具体实现逻辑：</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/Y6MigAsaEbWwLxv.png"  alt="NetUtil_findAvailablePort.png"></p><ul><li>传入的<code>9999</code>作为默认端口，首先循环<code>9999</code>到<code>65534</code>端口，逐个进行<code>!isPortUsed(portTmp)</code>判断，如果返回<code>true</code>则表示当前端口号未被使用，返回赋值给属性<code>port</code>。</li><li>如果上述循环未找到可使用的端口，则再循环<code>9999</code>到<code>1</code>端口，同样逐个进行<code>!isPortUsed(portTmp)</code>判断，如果还未找到可用端口，则抛出<code>XxlRpcException</code>异常，异常信息为<code>no available port.</code>。</li></ul><p>我们来看一下<code>isPortUsed</code>方法是如何判断端口是否被使用的：</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/jy9bL4ZIrwB7shd.png"  alt="NetUtil_isPortUsed.png"></p><p>实际是尝试去创建一个<code>ServerSocket</code>客户端并与传入的端口号进行绑定，如端口被占用则绑定时会抛出<code>IOException</code>，由此来确定端口是否被使用，从而在未配置端口号时选出一个可用端口。最终<code>finally</code>代码块中调用了<code>close</code>方法关闭资源。</p><ol start="6"><li><code>ip = (ip!=null&amp;&amp;ip.trim().length()&gt;0)?ip: IpUtil.getIp();</code></li></ol><p>作用：确定<code>ip</code>地址。示例执行器的配置中是未进行配置的，所以会执行<code>IpUtil.getIp()</code>方法，该方法中最后会调用<code>java.net.InetAddress#getHostAddress</code>方法，该方法返回<code>null</code>，所以属性<code>ip</code>会被设置成<code>null</code>。</p><ol start="7"><li><code>initRpcProvider(ip, port, appName, accessToken);</code></li></ol><p>传入了四个参数：<code>ip</code>、<code>port</code>、<code>appName</code>和<code>accessToken</code>用来初始化<code>Rpc</code>服务提供者。这部分属于<code>xxl-rpc</code>的内容，目前我们可以简单看看，大致内容是创建出<code>XxlRpcProviderFactory</code>类的对象，给该对象设置相关属性，添加<code>com.xxl.job.core.biz.impl.ExecutorBizImpl</code>服务至<code>rpc</code>服务提供者<code>map</code>容器中，最后调用<code>start</code>方法启动服务提供者（这里实际是一个<code>NettyServer</code>）。</p><p>现在我们大可不必去关注<code>xxl-rpc</code>是怎么实现的，这篇文章的目的是搞清楚七大核心配置的工作原理。</p><p>父类<code>XxlJobExecutor</code>的<code>start</code>方法我们看完了，那么它是什么时机执行的呢？</p><p>我们注意到<code>XxlJobSpringExecutor</code>类实现了<code>Spring</code>的<code>InitializingBean</code>接口，该接口提供了<code>afterPropertiesSet</code>方法供子类实现，在<code>bean</code>加载过程中会执行该方法。</p><p>接下来我们来看一下<code>XxlJobSpringExecutor</code>类中重写的<code>afterPropertiesSet</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init JobHandler Repository</span></span><br><span class="line">    initJobHandlerRepository(applicationContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init JobHandler Repository (for method)</span></span><br><span class="line">    initJobHandlerMethodRepository(applicationContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// refresh GlueFactory</span></span><br><span class="line">    GlueFactory.refreshInstance(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// super start</span></span><br><span class="line">    <span class="keyword">super</span>.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前三行代码是初始化一些东西，暂时不去关注；最后一行<code>super.start()</code>是我们的关键，调用了父类的<code>start</code>方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们知道了七大配置项的基本原理，对我们使用<code>xxl-job</code>有了一些帮助。例如配置项<code>logretentiondays</code>不能小于<code>3</code>，否则日志文件不会自动清理等。</p>]]></content>
    
    <summary type="html">
    
      修炼xxl-job之执行器项目七大配置项解析
    
    </summary>
    
    
      <category term="中间件" scheme="https://lilu.org.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="定时任务" scheme="https://lilu.org.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
    
      <category term="xxl-job" scheme="https://lilu.org.cn/tags/xxl-job/"/>
    
  </entry>
  
  <entry>
    <title>修炼xxl-job之搭建本地调度平台</title>
    <link href="https://lilu.org.cn/2020/02/13/middleware/xxl-job/build-local-dispatch-platform/"/>
    <id>https://lilu.org.cn/2020/02/13/middleware/xxl-job/build-local-dispatch-platform/</id>
    <published>2020-02-13T13:36:17.188Z</published>
    <updated>2020-02-13T13:11:10.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p><code>xxl-job</code>目前最新<code>master</code>分支的代码为<code>v2.2.0</code>，官网显示仍在迭代中（该版本目前发布的更新内容主要是调度中心升级<code>SpringBoot</code>版本为<code>2.x</code>），所以本次修炼我们采用最近稳定版<code>v2.1.2</code>，发布日期为<code>2019-12-12</code>。</p><p>源码地址：<a href="https://github.com/xuxueli/xxl-job" target="_blank" rel="noopener">GitHub</a>/<a href="https://gitee.com/xuxueli0323/xxl-job" target="_blank" rel="noopener">Gitee</a></p><h2 id="工程简介"><a href="#工程简介" class="headerlink" title="工程简介"></a>工程简介</h2><p>源码结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xxl-job-admin：调度中心</span><br><span class="line">xxl-job-core：公共依赖</span><br><span class="line">xxl-job-executor-samples：执行器Sample示例（选择合适的版本执行器，可直接使用，也可以参考其并将现有项目改造成执行器）</span><br><span class="line">    ：xxl-job-executor-sample-springboot：Springboot版本，通过Springboot管理执行器，推荐这种方式；</span><br><span class="line">    ：xxl-job-executor-sample-spring：Spring版本，通过Spring容器管理执行器，比较通用；</span><br><span class="line">    ：xxl-job-executor-sample-frameless：无框架版本；</span><br><span class="line">    ：xxl-job-executor-sample-jfinal：JFinal版本，通过JFinal管理执行器；</span><br><span class="line">    ：xxl-job-executor-sample-nutz：Nutz版本，通过Nutz管理执行器；</span><br><span class="line">    ：xxl-job-executor-sample-jboot：jboot版本，通过jboot管理执行器；</span><br></pre></td></tr></table></figure><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>基础环境：</p><ul><li><code>Maven3+</code></li><li><code>JDK7+</code></li><li><code>MySQL5.7+</code></li></ul><h3 id="搭建调度中心"><a href="#搭建调度中心" class="headerlink" title="搭建调度中心"></a>搭建调度中心</h3><p>调度中心项目：<code>xxl-job-admin</code>。</p><p>作用：统一管理任务调度平台上调度任务，负责触发调度执行，并且提供任务管理平台。</p><h4 id="初始化“调度数据库”"><a href="#初始化“调度数据库”" class="headerlink" title="初始化“调度数据库”"></a>初始化“调度数据库”</h4><p>源码下载后获取初始化数据库<code>SQL</code>脚本并在<code>MySQL</code>中执行。</p><p>调度数据库初始化<code>SQL</code>脚本地址为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;xxl-job&#x2F;doc&#x2F;db&#x2F;tables_xxl_job.sql</span><br></pre></td></tr></table></figure><h4 id="修改调度中心配置"><a href="#修改调度中心配置" class="headerlink" title="修改调度中心配置"></a>修改调度中心配置</h4><p>将整个项目工程导入<code>IDEA</code>中，等待<code>maven</code>依赖下载完毕，修改调度中心配置。</p><p>调度中心配置文件地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;xxl-job&#x2F;xxl-job-admin&#x2F;src&#x2F;main&#x2F;resources&#x2F;application.properties</span><br></pre></td></tr></table></figure><p>需要修改的配置项有以下三个：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string"></span></span><br></pre></td></tr></table></figure><p>将数据源信息修改为上一步中导入脚本的数据库信息。</p><h4 id="启动调度中心"><a href="#启动调度中心" class="headerlink" title="启动调度中心"></a>启动调度中心</h4><p>在<code>IDEA</code>中运行<code>com.xxl.job.admin.XxlJobAdminApplication#main</code>方法，启动调度中心。</p><p>如果一切配置正常，可在控制台看到以下三行关键日志信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">13:01:37.678 logback [main] INFO  o.s.b.c.e.t.TomcatEmbeddedServletContainer - Tomcat started on port(s): 8080 (http)</span><br><span class="line">13:01:37.690 logback [main] INFO  c.x.job.admin.XxlJobAdminApplication - Started XxlJobAdminApplication in 6.976 seconds (JVM running for 8.944)</span><br><span class="line">13:01:40.001 logback [xxl-job, admin JobScheduleHelper#scheduleThread] INFO  c.x.j.a.c.thread.JobScheduleHelper - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin scheduler success.</span><br></pre></td></tr></table></figure><p><code>Tomcat</code>容器监听<code>8080</code>端口启动；</p><p><code>JVM</code>启动；</p><p><code>JobScheduleHelper</code>这个类打印了<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin scheduler success.</code>这句话。</p><h4 id="访问调度中心地址"><a href="#访问调度中心地址" class="headerlink" title="访问调度中心地址"></a>访问调度中心地址</h4><p>如已正确进行前述步骤，则可访问调度中心。</p><p>调度中心访问地址：<code>http://localhost:8080/xxl-job-admin</code></p><p>该地址执行器将会使用到，作为回调地址。</p><p>默认管理员账号密码为<code>admin/123456</code>。登录成功后可看到如下界面：</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/oZum5VbtTvH1SeY.png"  alt="xxl-job-index.png"></p><p>至此调度中心搭建完毕。</p><h3 id="搭建执行器"><a href="#搭建执行器" class="headerlink" title="搭建执行器"></a>搭建执行器</h3><p>“执行器”示例项目：<code>xxl-job-executor-sample</code>，该模块下包含多个版本的执行器示例，我们选用<code>xxl-job-executor-sample-springboot</code>版本。</p><p>作用：负责接收“调度中心”的调度并执行；可直接部署执行器项目，也可以将执行器集成到现有业务项目中。</p><h4 id="启动执行器"><a href="#启动执行器" class="headerlink" title="启动执行器"></a>启动执行器</h4><p>在<code>IDEA</code>中运行<code>com.xxl.job.executor.XxlJobExecutorApplication#main</code>方法，启动示例执行器。</p><p>如果一切运行正常，可在控制台看到以下关键日志信息（这将作为我们后续解析源码的思路）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">16:47:51.370 logback [main] INFO  c.x.j.e.core.config.XxlJobConfig - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.</span><br><span class="line">16:47:51.425 logback [main] INFO  c.x.job.core.executor.XxlJobExecutor - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job register jobhandler success, name:httpJobHandler, jobHandler:com.xxl.job.core.handler.impl.MethodJobHandler@1c32886a[class com.xxl.job.executor.service.jobhandler.SampleXxlJob#httpJobHandler]</span><br><span class="line">16:47:51.426 logback [main] INFO  c.x.job.core.executor.XxlJobExecutor - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job register jobhandler success, name:demoJobHandler, jobHandler:com.xxl.job.core.handler.impl.MethodJobHandler@3a4b0e5d[class com.xxl.job.executor.service.jobhandler.SampleXxlJob#demoJobHandler]</span><br><span class="line">16:47:51.426 logback [main] INFO  c.x.job.core.executor.XxlJobExecutor - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job register jobhandler success, name:demoJobHandler2, jobHandler:com.xxl.job.core.handler.impl.MethodJobHandler@10b892d5[class com.xxl.job.executor.service.jobhandler.SampleXxlJob#demoJobHandler2]</span><br><span class="line">16:47:51.427 logback [main] INFO  c.x.job.core.executor.XxlJobExecutor - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job register jobhandler success, name:commandJobHandler, jobHandler:com.xxl.job.core.handler.impl.MethodJobHandler@3d3f761a[class com.xxl.job.executor.service.jobhandler.SampleXxlJob#commandJobHandler]</span><br><span class="line">16:47:51.427 logback [main] INFO  c.x.job.core.executor.XxlJobExecutor - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job register jobhandler success, name:shardingJobHandler, jobHandler:com.xxl.job.core.handler.impl.MethodJobHandler@3546d80f[class com.xxl.job.executor.service.jobhandler.SampleXxlJob#shardingJobHandler]</span><br><span class="line">......</span><br><span class="line">16:47:52.172 logback [main] INFO  c.x.r.r.p.XxlRpcProviderFactory - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-rpc, provider factory add service success. serviceKey &#x3D; com.xxl.job.core.biz.ExecutorBiz, serviceBean &#x3D; class com.xxl.job.core.biz.impl.ExecutorBizImpl</span><br><span class="line">......</span><br><span class="line">16:48:02.189 logback [Thread-10] INFO  com.xxl.rpc.remoting.net.Server - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-rpc remoting server start success, nettype &#x3D; com.xxl.rpc.remoting.net.impl.netty_http.server.NettyHttpServer, port &#x3D; 9999</span><br></pre></td></tr></table></figure><p>启动成功后，点击任务调度中心后台导航-执行器管理菜单，可看到如下图所示：<code>OnLine</code>机器地址中已显示我们运行的执行器地址。</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/2iUXThLzZHMkP9w.png"  alt="xxl-job-executor-online.png"></p><p>点击任务管理菜单可看到示例执行器的测试任务1；</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/DjYCsoTmGf3zknV.png"  alt="xxl-job-demo-executor.png"></p><p>点击右侧[操作]-&gt;[执行一次]，弹出的模态框中无需输入任务参数，直接点击[保存]即可执行任务；</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/tq754auXjG1NP3f.png"  alt="xxl-job-executor-one-times.png"></p><p>点击[查询日志]，可进入调度日志列表页，点击右侧[执行日志]，可看到任务在执行器一侧运行输出的日志信息。</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/3WUBxcaE8YZMG6i.png"  alt="xxl-job-executor-log.png"></p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/nVaF4GzW2LsUYxC.jpg"  alt="xxl-job-executor-log-page.png"></p><p>至此，我们已经完成了任务的调度和执行。</p>]]></content>
    
    <summary type="html">
    
      修炼xxl-job之搭建本地调度平台
    
    </summary>
    
    
      <category term="中间件" scheme="https://lilu.org.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="定时任务" scheme="https://lilu.org.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
    
      <category term="xxl-job" scheme="https://lilu.org.cn/tags/xxl-job/"/>
    
  </entry>
  
  <entry>
    <title>Windows 10下IntelliJ IDEA 2019.3.2安装和常用配置</title>
    <link href="https://lilu.org.cn/2020/02/07/installed/install-idea/"/>
    <id>https://lilu.org.cn/2020/02/07/installed/install-idea/</id>
    <published>2020-02-07T13:35:10.572Z</published>
    <updated>2020-02-07T13:10:01.080Z</updated>
    
    <content type="html"><![CDATA[<p>以下教程基于<code>windows 10</code>和<code>IntelliJ IDEA 2019.3.2</code>。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>可从 <a href="https://www.jetbrains.com/idea/download/#section=windows" target="_blank" rel="noopener">IntelliJ IDEA官网</a> 下载最新安装包。</p><p>这里我提供 <a href="https://pan.baidu.com/s/14P-cczbbA-o8N6CdCsQe6w" target="_blank" rel="noopener">百度云盘</a> 供大家下载，提取码：<code>v9oj</code>。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li><p>双击<code>.exe</code>安装文件-&gt;<code>Next</code>-&gt;指定安装路径（可直接填写，不存在会自动创建）-&gt;<code>Next</code>-&gt;<code>Next</code>-&gt;<code>Install</code>；等待安装完成。</p></li><li><p>勾选<code>Run IntelliJ IDEA</code>-&gt;<code>Finish</code></p></li><li><p><code>Do not import settings</code>-&gt;<code>OK</code>-&gt;勾选<code>I confirm that...</code>-&gt;<code>Continue</code>-&gt;<code>Don&#39;t Send</code></p></li><li><p>选择界面主题-&gt;<code>Next: Default plugins</code>-&gt;<code>Next: Featured plugins</code>-&gt;<code>Start using IntelliJ IDEA</code>（这一系列推荐按默认配置）</p></li><li><p><code>Evaluate for free</code>-&gt;<code>Evaluate</code>-&gt;<code>Continue</code></p></li></ul><h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><p>由于法律关系，请大家尽量支持正版。</p><h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><p>点击<code>File</code>-&gt;<code>Close Project</code>，关闭主界面进入选择项目窗口（这样设置是全局设置，而不是单对于某个项目设置）。</p><p>点击右下角<code>Configure</code>-&gt;<code>Settings</code>，打开设置面板。</p><h3 id="设置每次打开都是选择项目界面。"><a href="#设置每次打开都是选择项目界面。" class="headerlink" title="设置每次打开都是选择项目界面。"></a>设置每次打开都是选择项目界面。</h3><p><code>Appearance &amp; Behavior</code>-&gt;<code>System Settings</code>-&gt;取消勾选<code>Reopen last project on startup</code></p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/ARP29OHgBo7cfdb.png"  alt="show_project_select.png"></p><h3 id="取消自动检查更新。"><a href="#取消自动检查更新。" class="headerlink" title="取消自动检查更新。"></a>取消自动检查更新。</h3><p><code>Appearance &amp; Behavior</code>-&gt;<code>System Settings</code>-&gt;<code>Updates</code>-&gt;取消勾选<code>Automatically check updates for</code></p><h3 id="设置鼠标放到类或方法上自动显示注释文档。"><a href="#设置鼠标放到类或方法上自动显示注释文档。" class="headerlink" title="设置鼠标放到类或方法上自动显示注释文档。"></a>设置鼠标放到类或方法上自动显示注释文档。</h3><p><code>Editor</code>-&gt;<code>General</code>-&gt;勾选<code>Show quick documentation on mouse move</code></p><p>可在下方设置显示的延迟毫秒数<code>Tooltip delay</code></p><h3 id="设置字体和字体大小"><a href="#设置字体和字体大小" class="headerlink" title="设置字体和字体大小"></a>设置字体和字体大小</h3><p><code>Editor</code>-&gt;<code>Font</code></p><h3 id="设置创建Java类时的头部注释模板。"><a href="#设置创建Java类时的头部注释模板。" class="headerlink" title="设置创建Java类时的头部注释模板。"></a>设置创建<code>Java</code>类时的头部注释模板。</h3><p><code>Editor</code>-&gt;<code>File and Code Templates</code>-&gt;<code>Includes</code>-&gt;<code>File Header</code></p><p>右侧输入注释模板，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author sunchaser</span><br><span class="line"> * @date $&#123;DATE&#125;</span><br><span class="line"> * @description</span><br><span class="line"> * @since 1.0</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><h3 id="设置文件编码字符集。"><a href="#设置文件编码字符集。" class="headerlink" title="设置文件编码字符集。"></a>设置文件编码字符集。</h3><p><code>Editor</code>-&gt;<code>File Encodings</code></p><p>统一选择<code>UTF-8</code>/<code>with NO BOM</code>。</p><h3 id="设置Git及GitHub。"><a href="#设置Git及GitHub。" class="headerlink" title="设置Git及GitHub。"></a>设置<code>Git</code>及<code>GitHub</code>。</h3><p><code>Version Control</code>-&gt;<code>Git</code>/<code>GitHub</code></p><p>选择<code>Git</code>安装目录下的<code>bin\git.exe</code>文件。有关<code>Git</code>的安装配置，可参考 <a href="/2020/02/07/installed/install-git/">这篇文章</a></p><p>输入用户名/密码登录<code>GitHub</code>。</p><h3 id="设置Maven。"><a href="#设置Maven。" class="headerlink" title="设置Maven。"></a>设置<code>Maven</code>。</h3><p><code>Build,Execution,Deployment</code>-&gt;<code>Build Tools</code>-&gt;<code>Maven</code></p><p>选择<code>Maven home directory</code>为我们自己安装的<code>Maven</code>目录，点击<code>Override</code>覆盖默认的<code>User settings file</code>和<code>Local repository</code>。</p><p>有关<code>Maven</code>的安装和配置，可参考 <a href="/2020/02/07/installed/install-maven/">这篇文章</a> 。</p><p><code>Build,Execution,Deployment</code>-&gt;<code>Build Tools</code>-&gt;<code>Maven</code>-&gt;<code>Importing</code>/<code>Runner</code></p><p>选择<code>JDK for importer</code>/<code>JRE</code>为<code>Use JAVA_HOME</code></p><h3 id="设置序列化UID生成快捷键"><a href="#设置序列化UID生成快捷键" class="headerlink" title="设置序列化UID生成快捷键"></a>设置序列化<code>UID</code>生成快捷键</h3><p>设置实现了<code>Serializable</code>序列化接口的类中未定义<code>serialVersionUID</code>属性时类名处报黄色警告，按快捷键<code>alt</code>+<code>enter</code>有快捷生成序列化<code>UID</code>的选项。</p><p><code>Editor</code>-&gt;<code>Inspections</code></p><p>搜索<code>Serializable</code>，找到<code>Serializable class without &#39;serialVersionUID&#39;</code>，右侧进行勾选。</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/u5Cjxqkdo79TDFr.jpg"  alt="serializable.png"></p><p>所有设置完成后点击右下角<code>Apply</code>-&gt;<code>OK</code>，完成设置。</p>]]></content>
    
    <summary type="html">
    
      Windows 10下IntelliJ IDEA 2019.3.2安装和常用配置。
    
    </summary>
    
    
      <category term="安装配置" scheme="https://lilu.org.cn/categories/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="IntelliJ IDEA" scheme="https://lilu.org.cn/tags/IntelliJ-IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Windows 10下Git安装及SSH公私钥配置</title>
    <link href="https://lilu.org.cn/2020/02/07/installed/install-git/"/>
    <id>https://lilu.org.cn/2020/02/07/installed/install-git/</id>
    <published>2020-02-07T13:35:10.570Z</published>
    <updated>2020-02-07T13:09:57.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>可从 <a href="https://git-scm.com/" target="_blank" rel="noopener">Git官网</a> 下载最新<code>Windows</code>安装文件（下载速度有点感人）。</p><p>这里我提供<code>64</code>位的<code>Git 2.25.0</code>版本的 <a href="https://pan.baidu.com/s/1pAYF4SQDs2KF750rokTJgA" target="_blank" rel="noopener">百度网盘</a> 供大家下载，提取码：<code>uzs6</code>。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>双击安装包文件进行安装，自定义安装位置，其余保持默认一直<code>next</code>下去。</p><p>按下<code>win+R</code>键，输入<code>cmd</code>，回车，输入命令<code>git --version</code>，出现下图所示内容即表示安装成功。</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/2RBSQYq6VMND5br.png"  alt="git_version.png"></p><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><p>全局配置用户名和邮箱，否则无法进行下一步的<code>SSH</code>公私钥配置。鼠标右击桌面空白处-&gt;选择<code>Git Bash Here</code>打开。分别输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure><p>用户名可随意指定，一般是自己名字或简称，<code>git</code>提交代码到远程时会使用该名称。邮箱填自己喜欢的邮箱即可。</p><h2 id="SSH公私钥配置"><a href="#SSH公私钥配置" class="headerlink" title="SSH公私钥配置"></a><code>SSH</code>公私钥配置</h2><ol><li>鼠标右击桌面空白处-&gt;选择<code>Git Bash Here</code>打开。</li><li>使用<code>cd ~/.ssh</code>切换到公私钥目录。</li><li>执行命令<code>ssh-keygen -t rsa</code>生成公私钥，回车<code>3</code>次（这里回车会让你输入一些配置，比如密码，如果设置了密码则每次使用<code>git</code>命令都会要求输入密码，不推荐），会在<code>C:\Users\Administrator\.ssh</code>目录下生成一个私钥<code>id_rsa</code>和一个公钥<code>id_rsa.pub</code>。</li></ol><h2 id="Gitlab配置"><a href="#Gitlab配置" class="headerlink" title="Gitlab配置"></a><code>Gitlab</code>配置</h2><p>上述配置完成之后即可在全球最大的开源项目托管平台<code>Github</code>上进行代码版本控制。</p><p>但一般企业都会有自己的<code>Gitlab</code>代码托管平台，这时如果没有在<code>Gitlab</code>上配置公私钥则不能上传/下载代码。</p><p>登录企业的<code>Gitlab</code>平台-&gt;右上角个人头像-&gt;<code>Settings</code>-&gt;<code>SSH Keys</code>-&gt;粘贴<code>.ssh</code>文件夹下的<code>id_rsa.pub</code>公钥内容-&gt;确认添加。</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/g6BT2HSfZOLaWnV.png"  alt="add_ssh_pub_key.png"></p><p>配置完成后即可在企业的<code>Gitlab</code>平台上传/下载代码。</p>]]></content>
    
    <summary type="html">
    
      Windows 10下Git安装及SSH公私钥配置
    
    </summary>
    
    
      <category term="安装配置" scheme="https://lilu.org.cn/categories/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="Git" scheme="https://lilu.org.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>重装Windows10系统</title>
    <link href="https://lilu.org.cn/2020/02/07/installed/install-windows10/"/>
    <id>https://lilu.org.cn/2020/02/07/installed/install-windows10/</id>
    <published>2020-02-07T13:35:10.568Z</published>
    <updated>2020-02-07T13:10:14.054Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>制作重装启动<code>U</code>盘，推荐 <a href="http://www.bigbaicai.com/" target="_blank" rel="noopener">大白菜</a> U盘制作工具。</p></li><li><p>下载<code>win10</code>镜像文件，一般去 <a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">MSDN我告诉你</a> 下载。大家都是<code>64</code>位的<code>CPU</code>，你应该下载<code>64</code>位版本的镜像。</p></li><li><p>百度搜索对应机型U盘启动快捷键，进行重装。</p></li><li><p>重装系统启动过程中有一些可选配置项，一般都不勾选，没有必要。在创建用户界面请使用脱机账户登录，脱机账户可手动设置用户名。不要使用<code>outlook</code>邮箱登录，原因是使用<code>outlook</code>邮箱登录的话，由于用户名设置规则，只会取邮箱的前五个字符，作为微软用户绑定的系统管理员用户名。可能会造成<code>C:\Users</code>目录下的用户名不是你想要的。重装完成后再到设置中使用<code>outlook</code>邮箱登录即可。这样系统用户名就是我们自定义的名称。</p></li><li><p>重装完成后系统会自动进行一些基本设置，然后进入桌面会提示等待系统部署完成。这时等待一会即可。一般会安装一些第三方软件，例如<code>360</code>/爱奇艺/淘宝等，大可不必觉得“恶心”，稍后我们会进行清理。</p></li><li><p>一般<code>win10</code>系统安装完成后桌面上没有我的电脑/控制面板等图标，只有一个回收站。可以鼠标右键点击桌面空白处-&gt;个性化设置-&gt;主题-&gt;相关的设置（桌面图标设置），勾选计算机/控制面板等，点击确定即可。这时发现桌面图标排列顺序有点不好，可鼠标右键点击刷新桌面，如果还不行则鼠标右键点击桌面空白处-&gt;排序方式-&gt;名称，重复两遍即可。</p></li><li><p>激活<code>Windows</code>，建议在某宝购买支持重装的激活码，一次购买，多次使用。不推荐使用第三方激活工具激活。</p></li><li><p>开始清理系统初始第三方软件，可利用自动安装的<code>360</code>软件管家，卸载这些应用。最后在卸载<code>360</code>。在卸载应用时注意勾选删除在本机保存的个人配置数据等类似选项。</p></li><li><p>点击开始菜单，在左侧菜单和动态磁贴中一般会有一些没什么用的<code>Windows</code>应用，例如一些游戏等，如果不需要<code>office</code>等也可以进行卸载。点击鼠标右键即有卸载按钮。</p></li><li><p>这时系统基本清理完成，但还是会有一些残留文件夹存在，进入<code>C:/Program Files (x86)</code>目录，如果看到一些<code>360/tencent</code>等文件夹可直接删除，如果提示操作无法完成，因为其中的文件夹或文件已在另一程序中打开，则可先放着，等将其它类似文件夹删除后，稍后重启电脑即可删除。</p></li><li><p>打开我的电脑，点击上方查看，勾选文件扩展名/隐藏的项目。重启电脑，重启完成后即可删除上述所说无法删除的文件夹。</p></li><li><p>下面开始安装我们的个人软件，首先安装<code>360</code>。</p></li></ol><ul><li>为什么安装<code>360</code>？</li></ul><p>有些人觉得<code>360</code>是流氓软件，影响电脑运行速度，但我觉得<code>360</code>有些功能还是可以的，比如清理垃圾/禁止开机启动项等。</p><ul><li>为什么卸载系统安装完成后自带的<code>360</code>？</li></ul><p>因为自带的<code>360</code>安装在<code>C</code>盘，不好。去 <a href="https://www.360.cn/" target="_blank" rel="noopener">360官网</a> 下载最新的安装包。双击安装包，选择自定义安装，选择安装路径为自定义盘（非<code>C</code>盘）。</p><ul><li>进行清理优化</li></ul><p>安装完成后打开<code>360</code>主界面，点击功能大全-&gt;我的工具，删除一些没用的自带工具。一般只留一个软件管家即可。点击电脑清理清理系统垃圾。勾选一些痕迹信息和<code>Cookie</code>信息等。点击优化加速禁用一些开机启动项。扫描完成后勾选一些需要优化的项，点击立即优化。</p><ul><li>安装驱动大师更新驱动</li></ul><p>在功能大全中搜索找到<code>360</code>驱动大师，点击安装，进行系统驱动更新。驱动大师会自动进行备份下载更新，备份的目录可在驱动大师的设置中指定，默认与<code>360</code>安装目录在同一盘符下。</p><p>驱动更新完成后重启电脑，重启后删除驱动大师。在<code>360</code>安全卫士中-&gt;功能大全-&gt;我的工具中删除驱动大师，可选择勾选删除已备份和下载的驱动。</p><ul><li>安装其它软件（可选）<ul><li><code>360</code>压缩：解压缩软件有很多选择，比如<code>WinR/7z</code>等，这里由于安装了<code>360</code>，选择<code>360</code>压缩即可。进入<code>360</code>安全卫士主界面-&gt;功能大全-&gt;搜索选择<code>360</code>压缩-&gt;点击进行安装-&gt;安装完成后会弹出主界面-&gt;点击右上角工具-&gt;设置-&gt;取消勾选常规中的开启自动升级/改善计划中的参与“<code>360</code>用户体验改善计划”-&gt;确定。对于右下角可能出现的弹窗，请点击弹窗右上角的<code>×</code>进行关闭。</li><li>搜狗输入法：前往 <a href="https://pinyin.sogou.com/" target="_blank" rel="noopener">搜狗输入法官网</a> 下载最新安装包，下载完成后双击运行-&gt;选择自定义安装-&gt;选择安装目录-&gt;点击安装-&gt;取消勾选完成界面的一些捆绑安装的选项。安装完成后进行搜狗输入法的一些基本设置即可，搜狗输入法每天会在右下角弹出一个弹窗，不要点击不在提示，请点击右上角的<code>×</code>，不然会下载搜狗浏览器。</li><li>有道云笔记：前往 <a href="http://note.youdao.com/" target="_blank" rel="noopener">有道云笔记官网</a> 下载最新安装包-&gt;双击运行-&gt;自定义安装-&gt;指定安装目录-&gt;取消勾选有道翻译安装。安装完成后进行登录，登录后点击右上角-&gt;设置，取消勾选启动<code>windows</code>时启动有道云笔记/自动检查客户端更新。默认情况下本地文件会保存在<code>C:\Users\用户名\AppData\Local\YNote</code>相关目录下，在安装时指定可能没有效果。如果想让本地文件不保存在<code>C</code>盘可在设置中进行指定，有道云笔记会自动进行数据迁移。</li><li>百度网盘：前往 <a href="https://pan.baidu.com/" target="_blank" rel="noopener">百度云网盘官网</a> 下载最新安装包-&gt;双击运行-&gt;自定义安装-&gt;指定安装目录-&gt;完成后登录-&gt;进入主界面后点击右上角设置-&gt;取消勾选开机时启动百度网盘(推荐)。</li></ul></li></ul><p>至此，电脑重装系统基本完成，接下来就可以进行应用软件安装了。</p>]]></content>
    
    <summary type="html">
    
      重装Windows10系统流程
    
    </summary>
    
    
      <category term="安装配置" scheme="https://lilu.org.cn/categories/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="Windows10" scheme="https://lilu.org.cn/tags/Windows10/"/>
    
  </entry>
  
  <entry>
    <title>Windows 10下Node.js安装与配置</title>
    <link href="https://lilu.org.cn/2020/02/07/installed/install-nodejs/"/>
    <id>https://lilu.org.cn/2020/02/07/installed/install-nodejs/</id>
    <published>2020-02-07T13:35:10.564Z</published>
    <updated>2020-02-07T13:10:10.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>可从 <a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js中文官网</a> 下载最新长期支持版安装包。</p><p>这里我提供<code>12.15.0</code>长期支持版 <a href="https://pan.baidu.com/s/1GQZYcUpMsBBA0nU20CJplg" target="_blank" rel="noopener">百度云盘</a> 供大家下载，提取码：<code>itoe</code>。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>双击安装包文件进行安装，自定义安装位置，其余保持默认一直<code>next</code>下去。</p><p>按下<code>win+R</code>键，输入<code>cmd</code>，回车，分别输入命令<code>node -v</code>和<code>npm -v</code>，出现下图所示内容即表示安装成功。</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/cEe7vjnkqC9m8Ol.png"  alt="node_npm_v.png"></p><p>说明：新版本<code>Node.js</code>自带<code>npm</code>，安装<code>Node.js</code>时会一起安装，<code>npm</code>是<code>Node.js</code>的依赖包管理工具，可大致理解成<code>maven</code>/<code>Composer</code>等。</p><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><p>在执行类似：<code>npm install express [-g]</code> （后面的可选参数<code>-g</code>，<code>g</code>代表<code>global</code>全局安装的意思）的安装语句时，默认会将安装的模块安装到<code>C:\Users\用户名\AppData\Roaming\npm</code>路径中，占用<code>C</code>盘空间。</p><p>我们希望将全局模块路径和缓存路径放置在自定义目录（非C盘）中。这里我在<code>Node.js</code>安装目录下新建两个文件夹<code>node_global</code>和<code>node_cache</code>。如下图：</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/3Ccqt2zyMBjxPVH.png"  alt="node_global_cache.png"></p><p>空文件夹创建完成后，按下<code>win+R</code>键，输入<code>cmd</code>，回车，分别输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm config set prefix &quot;E:\develop\nodejs\node_global&quot;</span><br><span class="line"></span><br><span class="line">npm config set cache &quot;E:\develop\nodejs\node_cache&quot;</span><br></pre></td></tr></table></figure><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>鼠标右击我的电脑-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量</p><p>在系统变量处点击新建，输入变量名：<code>NODE_HOME</code>，变量值为<code>E:\develop\nodejs\node_global\node_modules</code>：上述全局配置中的<code>node_global</code>路径后再加一个<code>node_modules</code>文件夹（不用手动创建），点击确定。</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/tshAB4IbjM6FuZC.png"  alt="node_home.png"></p><p>选中用户变量<code>Path</code>，点击编辑，将默认的<code>C:\Users\用户名\AppData\Roaming\npm</code>改为<code>E:\develop\nodejs\node_global</code>：上述全局配置中的<code>node_global</code>，点击确定。</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/OfKmAPBJXRbyVsd.png"  alt="user_node_path.png"></p><p>最后一直确定下去至所有窗口关闭即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，删除默认的<code>C:\Users\lilu\AppData\Roaming\npm</code>文件夹。</p><p>至此<code>Node.js</code>的安装和配置就已完成，可使用<code>npm install -g</code>命令下载任意<code>js</code>依赖检验是否将包下载至了我们指定的路径下。</p>]]></content>
    
    <summary type="html">
    
      Windows 10下Node.js安装与配置
    
    </summary>
    
    
      <category term="安装配置" scheme="https://lilu.org.cn/categories/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="Node.js" scheme="https://lilu.org.cn/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Windows 10下Maven安装及配置</title>
    <link href="https://lilu.org.cn/2020/02/07/installed/install-maven/"/>
    <id>https://lilu.org.cn/2020/02/07/installed/install-maven/</id>
    <published>2020-02-07T13:35:10.562Z</published>
    <updated>2020-02-07T13:10:07.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>可从 <a href="http://maven.apache.org/download.cgi/" target="_blank" rel="noopener">Maven官网</a> 下载<code>Binary zip archive</code>最新压缩包。</p><p>这里我提供 <a href="https://pan.baidu.com/s/1QMUbAxNFTKTPwktK1-v1qg" target="_blank" rel="noopener">百度云盘</a> 供大家下载，提取码：<code>olx2</code>。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>maven</code>为绿色安装，下载完成后解压至自定义目录即可。</p><p>注意：解压路径不要包含中文。</p><h2 id="安装文件简介"><a href="#安装文件简介" class="headerlink" title="安装文件简介"></a>安装文件简介</h2><p>解压目录包含<code>4</code>个文件夹<code>bin/boot/conf/lib</code>，其存放的文件分别为：</p><ul><li><code>bin</code>：<code>maven</code>的一些可执行程序。</li><li><code>boot</code>：一些启动引导程序，例如类加载器等。</li><li><code>conf</code>：配置文件。</li><li><code>lib</code>：<code>maven</code>自身运行依赖的库。</li></ul><h2 id="配置maven"><a href="#配置maven" class="headerlink" title="配置maven"></a>配置<code>maven</code></h2><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>右击我的电脑-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量</p><p>在系统变量处点击新建，输入变量名：<code>MAVEN_HOME</code>，变量值上述<code>maven</code>的解压目录，点击确定。</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/Trs4I5pO7ZhlxQk.png"  alt="maven_home.png"></p><p>选中系统<code>Path</code>变量，点击编辑-&gt;新建，输入<code>%MAVEN_HOME%\bin\</code>，点击确定。</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/pmsHLowja4OdWDu.png"  alt="maven_home_path.png"><br><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/NcxXsZK68laoOfm.png"  alt="maven_home_path_bin.png"></p><p>最后一直确定下去至窗口关闭即可。</p><p>按下<code>win+R</code>键，输入<code>cmd</code>，回车，输入命令<code>mvn -v</code>，出现下图所示内容即表示配置成功。</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/meD3iLrZOnCNpyz.png"  alt="mvn_v.png"></p><h3 id="配置本地仓库"><a href="#配置本地仓库" class="headerlink" title="配置本地仓库"></a>配置本地仓库</h3><p>新建一个自定义目录<code>repository</code>作为本地仓库，一般和<code>Maven</code>的解压目录在同级。</p><p>然后在<code>Maven</code>的安装目录下找到<code>conf</code>目录下的<code>settings.xml</code>配置文件，用文本编辑器打开，找到大概第<code>55</code>行的位置，输入以下标签指定本地仓库的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;localRepository&gt;E:\develop\maven\repository&lt;&#x2F;localRepository&gt;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/nAo7qkhJQZgEOjy.png"  alt="local_repository.png"></p><p>根据个人安装位置输入仓库路径。</p><h3 id="配置阿里云镜像仓库"><a href="#配置阿里云镜像仓库" class="headerlink" title="配置阿里云镜像仓库"></a>配置阿里云镜像仓库</h3><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/81W7sY9LOk5T6XD.jpg"  alt="aliyun_mirror.png"></p><p>在<code>settings.xml</code>文件大约<code>160</code>行的地方，输入以下内容配置阿里云<code>Maven</code>镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这个是配置阿里Maven镜像 --&gt;</span><br><span class="line">&lt;mirror&gt;</span><br><span class="line">  &lt;id&gt;alimaven&lt;&#x2F;id&gt;</span><br><span class="line">  &lt;name&gt;aliyun maven&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line">  &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;</span><br><span class="line">&lt;&#x2F;mirror&gt;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，<code>Maven</code>的配置就完成了。</p>]]></content>
    
    <summary type="html">
    
      Windows 10下Maven安装及配置
    
    </summary>
    
    
      <category term="安装配置" scheme="https://lilu.org.cn/categories/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="Maven" scheme="https://lilu.org.cn/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Windows 10下JDK安装及环境变量配置</title>
    <link href="https://lilu.org.cn/2020/02/07/installed/install-jdk/"/>
    <id>https://lilu.org.cn/2020/02/07/installed/install-jdk/</id>
    <published>2020-02-07T13:35:10.560Z</published>
    <updated>2020-02-07T13:10:04.279Z</updated>
    
    <content type="html"><![CDATA[<p>由于<code>JDK</code>开始收费，现在大多数企业使用的<code>Java</code>版本是<code>Java8</code>或者以下，<code>Java8</code>的使用者居多。我们在学习或开发中，下载<code>Java8</code>就足够使用了。</p><h2 id="下载JDK安装包"><a href="#下载JDK安装包" class="headerlink" title="下载JDK安装包"></a>下载<code>JDK</code>安装包</h2><p>可前往 <a href="https://www.oracle.com/technetwork/java/javase/documentation/8u-relnotes-2225394.html" target="_blank" rel="noopener">Oracle官网</a> 下载。</p><p>这里我分享 <a href="https://pan.baidu.com/s/10_chUokZGwpcoCA-nGADOQ" target="_blank" rel="noopener">百度云盘</a> 供大家下载，提取码：<code>5mxh</code>。</p><h2 id="进行安装"><a href="#进行安装" class="headerlink" title="进行安装"></a>进行安装</h2><p>双击运行<code>.exe</code>后缀文件，运行安装程序，注意下图所示地方，去除公共<code>JRE</code>的安装，点击左侧的小图标选择此功能将不可用。点击开发工具更改安装路径，继续下一步直至完成安装即可。</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/nafVXGuSYeIFr8o.png"  alt="java-jre.png"></p><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>右击我的电脑-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量</p><p>在系统变量处点击新建，输入变量名：<code>JAVA_HOME</code>，变量值为上述<code>JDK</code>安装步骤中更改的安装路径，点击确定。</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/WcE1fDZLtdYCgm5.png"  alt="java_home.png"></p><p>选中系统<code>Path</code>变量，点击编辑-&gt;新建，输入<code>%JAVA_HOME%\bin\</code>，点击确定。</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/RShbVoiKCfFg7nI.png"  alt="java_home_path.png"><br><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/GFevdKUXnPjZ8tO.png"  alt="java_home_path_bin.png"></p><p>最后一直确定下去至窗口关闭即可。</p><h2 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h2><p>按下<code>win+R</code>键，输入<code>cmd</code>，回车，输入命令<code>java -version</code>，出现下图所示内容即表示配置成功。</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/c6OCkniZS8IprxU.png"  alt="java_version.png"></p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>网上很多老的教程还需要配置<code>CLASSPATH</code>变量，这个是<code>JDK</code>的历史原因，现在<code>JDK</code>目录下已包含专用的<code>JRE</code>，无需再进行额外配置。</p>]]></content>
    
    <summary type="html">
    
      Windows 10下JDK安装及环境变量配置
    
    </summary>
    
    
      <category term="安装配置" scheme="https://lilu.org.cn/categories/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="JDK" scheme="https://lilu.org.cn/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>方法重载Overload</title>
    <link href="https://lilu.org.cn/2020/01/09/javase/base/method-overload/"/>
    <id>https://lilu.org.cn/2020/01/09/javase/base/method-overload/</id>
    <published>2020-01-09T13:41:56.559Z</published>
    <updated>2020-01-09T13:09:30.216Z</updated>
    
    <content type="html"><![CDATA[<p>在日常生活中，相同的词可以表达多种不同的含义——它们被“重载了”。例如：“冬天能穿多少穿多少。夏天能穿多少穿多少。”、“中国足球谁也打不过。中国乒乓球谁也打不过。”。相同的名字但表达出了不同的含义，这就是方法重载。</p><h2 id="构造器重载"><a href="#构造器重载" class="headerlink" title="构造器重载"></a>构造器重载</h2><p>我们知道类的构造器名字必须与类名完全相同，不接受任何参数的构造器叫做默认构造器，同其它方法一样，构造器也能带有形式参数，以便指定如何创建对象。这里就体现了方法重载，它们都有相同的名字，即类名，但形式参数不同。</p><h2 id="区分方法重载"><a href="#区分方法重载" class="headerlink" title="区分方法重载"></a>区分方法重载</h2><p>如果有几个名字相同的方法，Java如何进行区分呢？</p><p>请记住方法重载的概念：方法名相同，但形参列表不同。</p><p>即使形参顺序不同也足以区分两个方法。但是最好别这样做，细想一下，如果只是参数顺序不同，有什么实际的意义呢？这样的重载也会让代码难以琢磨。</p><h2 id="基本数据类型的重载"><a href="#基本数据类型的重载" class="headerlink" title="基本数据类型的重载"></a>基本数据类型的重载</h2><h3 id="传入的实际参数范围小于重载方法声明的形式参数范围"><a href="#传入的实际参数范围小于重载方法声明的形式参数范围" class="headerlink" title="传入的实际参数范围小于重载方法声明的形式参数范围"></a>传入的实际参数范围小于重载方法声明的形式参数范围</h3><p>我们知道Java中有自动类型转换（隐式转换）的概念，基本数据类型能从一个范围“较小”的类型自动转换至一个范围“较大”的类型，此过程一旦涉及到方法重载，可能会造成一些混淆。</p><p>我们来进行一些测试。</p><p>foo1方法包含char/byte/short/int/long/float/double这7种基本数据类型的重载；</p><p>foo2方法包含byte/short/int/long/float/double这6种基本数据类型的重载；</p><p>foo3方法包含short/int/long/float/double这5种基本数据类型的重载；</p><p>foo4方法包含int/long/float/double这4种基本数据类型的重载；</p><p>foo5方法包含long/float/double这3种基本数据类型的重载；</p><p>foo6方法包含float/double这2种基本数据类型的重载；</p><p>foo7方法只有一个double类型参数的方法；</p><p>分别使用常量值6、char类型的’x’、byte类型的1、short类型的1、int类型的1、long类型的1、float类型的1和double类型的1分别调用foo系列的方法，观察输出结果。完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.overload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/8</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * 基本数据类型重载的测试：基本数据类型范围较小的会被自动类型转换（隐式转换）成范围较大的类型。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 基本数据类型（除去boolean）范围如下：</span></span><br><span class="line"><span class="comment"> * '[' 和 ']' 表示闭区间。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * byte   |  8 bits | [-128, +127]</span></span><br><span class="line"><span class="comment"> * char   | 16 bits | ['\u0000', '\uFFFF']</span></span><br><span class="line"><span class="comment"> * short  | 16 bits | [-2^15, +2^15 - 1]</span></span><br><span class="line"><span class="comment"> * int    | 32 bits | [-2^31, +2^31 - 1]</span></span><br><span class="line"><span class="comment"> * float  | 32 bits | IEEE754范围</span></span><br><span class="line"><span class="comment"> * double | 64 bits | IEEE754范围</span></span><br><span class="line"><span class="comment"> * long   | 64 bits | [-2^63, +2^63 - 1]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallToBigDataTypeOverloadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * print:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * const: 6</span></span><br><span class="line"><span class="comment">     * foo1(int x)</span></span><br><span class="line"><span class="comment">     * foo2(int x)</span></span><br><span class="line"><span class="comment">     * foo3(int x)</span></span><br><span class="line"><span class="comment">     * foo4(int x)</span></span><br><span class="line"><span class="comment">     * foo5(long x)</span></span><br><span class="line"><span class="comment">     * foo6(float x)</span></span><br><span class="line"><span class="comment">     * foo7(double x)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 常量值6被当做int值进行处理。如果没有int类型的重载方法，则自动类型转换成“较大”的类型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConstValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"const: 6"</span>);</span><br><span class="line">        foo1(<span class="number">6</span>);</span><br><span class="line">        foo2(<span class="number">6</span>);</span><br><span class="line">        foo3(<span class="number">6</span>);</span><br><span class="line">        foo4(<span class="number">6</span>);</span><br><span class="line">        foo5(<span class="number">6</span>);</span><br><span class="line">        foo6(<span class="number">6</span>);</span><br><span class="line">        foo7(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * print:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * char: x</span></span><br><span class="line"><span class="comment">     * foo1(char x)</span></span><br><span class="line"><span class="comment">     * foo2(int x)</span></span><br><span class="line"><span class="comment">     * foo3(int x)</span></span><br><span class="line"><span class="comment">     * foo4(int x)</span></span><br><span class="line"><span class="comment">     * foo5(long x)</span></span><br><span class="line"><span class="comment">     * foo6(float x)</span></span><br><span class="line"><span class="comment">     * foo7(double x)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 除foo1外，char类型的'x'被自动类型转换成了“较大”的类型。</span></span><br><span class="line"><span class="comment">     * 在foo2、foo3和foo4中，char类型被直接转换成了int类型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c = <span class="string">'x'</span>;</span><br><span class="line">        System.out.println(<span class="string">"char: "</span> + c);</span><br><span class="line">        foo1(c);</span><br><span class="line">        foo2(c);</span><br><span class="line">        foo3(c);</span><br><span class="line">        foo4(c);</span><br><span class="line">        foo5(c);</span><br><span class="line">        foo6(c);</span><br><span class="line">        foo7(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * print:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * byte: 1</span></span><br><span class="line"><span class="comment">     * foo1(byte x)</span></span><br><span class="line"><span class="comment">     * foo2(byte x)</span></span><br><span class="line"><span class="comment">     * foo3(short x)</span></span><br><span class="line"><span class="comment">     * foo4(int x)</span></span><br><span class="line"><span class="comment">     * foo5(long x)</span></span><br><span class="line"><span class="comment">     * foo6(float x)</span></span><br><span class="line"><span class="comment">     * foo7(double x)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 除foo1和foo2外，byte类型的1被自动类型转换成了“较大”的类型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testByte</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> b = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"byte: "</span> + b);</span><br><span class="line">        foo1(b);</span><br><span class="line">        foo2(b);</span><br><span class="line">        foo3(b);</span><br><span class="line">        foo4(b);</span><br><span class="line">        foo5(b);</span><br><span class="line">        foo6(b);</span><br><span class="line">        foo7(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * print:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * short: 1</span></span><br><span class="line"><span class="comment">     * foo1(short x)</span></span><br><span class="line"><span class="comment">     * foo2(short x)</span></span><br><span class="line"><span class="comment">     * foo3(short x)</span></span><br><span class="line"><span class="comment">     * foo4(int x)</span></span><br><span class="line"><span class="comment">     * foo5(long x)</span></span><br><span class="line"><span class="comment">     * foo6(float x)</span></span><br><span class="line"><span class="comment">     * foo7(double x)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 除foo1、foo2和foo3外，short类型的1被自动类型转换成了“较大”的类型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testShort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">short</span> s = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"short: "</span> + s);</span><br><span class="line">        foo1(s);</span><br><span class="line">        foo2(s);</span><br><span class="line">        foo3(s);</span><br><span class="line">        foo4(s);</span><br><span class="line">        foo5(s);</span><br><span class="line">        foo6(s);</span><br><span class="line">        foo7(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * print:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * int: 1</span></span><br><span class="line"><span class="comment">     * foo1(int x)</span></span><br><span class="line"><span class="comment">     * foo2(int x)</span></span><br><span class="line"><span class="comment">     * foo3(int x)</span></span><br><span class="line"><span class="comment">     * foo4(int x)</span></span><br><span class="line"><span class="comment">     * foo5(long x)</span></span><br><span class="line"><span class="comment">     * foo6(float x)</span></span><br><span class="line"><span class="comment">     * foo7(double x)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * foo5、foo6和foo7方法，int类型的1都被自动类型转换成了“较大”的类型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"int: "</span> + i);</span><br><span class="line">        foo1(i);</span><br><span class="line">        foo2(i);</span><br><span class="line">        foo3(i);</span><br><span class="line">        foo4(i);</span><br><span class="line">        foo5(i);</span><br><span class="line">        foo6(i);</span><br><span class="line">        foo7(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * print:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * long: 1</span></span><br><span class="line"><span class="comment">     * foo1(long x)</span></span><br><span class="line"><span class="comment">     * foo2(long x)</span></span><br><span class="line"><span class="comment">     * foo3(long x)</span></span><br><span class="line"><span class="comment">     * foo4(long x)</span></span><br><span class="line"><span class="comment">     * foo5(long x)</span></span><br><span class="line"><span class="comment">     * foo6(float x)</span></span><br><span class="line"><span class="comment">     * foo7(double x)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * foo6和foo7方法，long类型的1L被自动类型转换成了“较大”的类型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> l = <span class="number">1L</span>;</span><br><span class="line">        System.out.println(<span class="string">"long: "</span> + l);</span><br><span class="line">        foo1(l);</span><br><span class="line">        foo2(l);</span><br><span class="line">        foo3(l);</span><br><span class="line">        foo4(l);</span><br><span class="line">        foo5(l);</span><br><span class="line">        foo6(l);</span><br><span class="line">        foo7(l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * print:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * float: 1.0</span></span><br><span class="line"><span class="comment">     * foo1(float x)</span></span><br><span class="line"><span class="comment">     * foo2(float x)</span></span><br><span class="line"><span class="comment">     * foo3(float x)</span></span><br><span class="line"><span class="comment">     * foo4(float x)</span></span><br><span class="line"><span class="comment">     * foo5(float x)</span></span><br><span class="line"><span class="comment">     * foo6(float x)</span></span><br><span class="line"><span class="comment">     * foo7(double x)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * foo7方法中，float类型的1F被自动类型转换成了“较大”的类型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFloat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> f = <span class="number">1F</span>;</span><br><span class="line">        System.out.println(<span class="string">"float: "</span> + f);</span><br><span class="line">        foo1(f);</span><br><span class="line">        foo2(f);</span><br><span class="line">        foo3(f);</span><br><span class="line">        foo4(f);</span><br><span class="line">        foo5(f);</span><br><span class="line">        foo6(f);</span><br><span class="line">        foo7(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * print:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * double: 1.0</span></span><br><span class="line"><span class="comment">     * foo1(double x)</span></span><br><span class="line"><span class="comment">     * foo2(double x)</span></span><br><span class="line"><span class="comment">     * foo3(double x)</span></span><br><span class="line"><span class="comment">     * foo4(double x)</span></span><br><span class="line"><span class="comment">     * foo5(double x)</span></span><br><span class="line"><span class="comment">     * foo6(double x)</span></span><br><span class="line"><span class="comment">     * foo7(double x)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDouble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">1</span>D;</span><br><span class="line">        System.out.println(<span class="string">"double: "</span> + d);</span><br><span class="line">        foo1(d);</span><br><span class="line">        foo2(d);</span><br><span class="line">        foo3(d);</span><br><span class="line">        foo4(d);</span><br><span class="line">        foo5(d);</span><br><span class="line">        foo6(d);</span><br><span class="line">        foo7(d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo1 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo1(char x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo1(byte x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo1(short x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo1(int x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo1(long x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo1(float x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo1(double x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo2 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo2(byte x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo2(short x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo2(int x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo2(long x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo2(float x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo2(double x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo3 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo3</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo3(short x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo3(int x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo3</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo3(long x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo3</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo3(float x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo3</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo3(double x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo4 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo4</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo4(int x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo4</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo4(long x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo4</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo4(float x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo4</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo4(double x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo5 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo5</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo5(long x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo5</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo5(float x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo5</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo5(double x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo6 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo6</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo6(float x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo6</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo6(double x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo7 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo7</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo7(double x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会发现常量值6被foo1/foo2/foo3/foo4方法当做int值进行处理，foo5/foo6/foo7没有int类型的重载方法，被自动类型转换成了“较大”的类型（long/float/double）。</p><p>对于char类型的’x’，foo1方法包含对应类型的重载，剩余6种方法不包含char类型的重载，但foo2/foo3/foo4直接将char类型自动类型转换成了int类型。foo5/foo6/foo7分别将char类型隐式转换成了long/float/double类型。</p><blockquote><p>char类型是不会被自动类型转换成byte/short类型的。其原因可查看这篇文章：<a href="/2020/01/09/javase/base/why-char-cannot-be-converted-to-byte-or-short/">传送门</a></p></blockquote><p>对于byte类型的1，foo1/foo2方法包含对应类型的重载；剩余5种方法不包含char类型的重载，被分别隐式转换成了short/int/long/float/double类型。</p><p>对于short类型的1，foo1/foo2/foo3方法包含对应类型的重载；剩余4种方法不包含short类型的重载，被分别隐式转换成了int/long/float/double类型。</p><p>对于int类型的1，foo1/foo2/foo3/foo4方法包含对应类型的重载；foo5/foo6/foo7不包含int类型的重载，被分别隐式转换成了long/float/double类型。</p><p>对于long类型的1，foo1/foo2/foo3/foo4/foo5方法包含对应类型的重载；foo6/foo7不包含long类型的重载，被分别隐式转换成了float/double类型。</p><p>对应float类型的1，foo7不包含float类型的重载，被隐式转换成了double类型；而其它6种方法包含对应类型的重载。</p><p>对于double类型的1,7种方法都有对应类型的重载。</p><p>数值基本类型隐式转换图如下：</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/OeS472iBMyCUz9n.png"  alt="basic-data-type-conversion.png"></p><p>实线箭头无精度丢失，虚线箭头可能丢失精度。</p><h3 id="传入的实际参数范围大于重载方法声明的形式参数范围"><a href="#传入的实际参数范围大于重载方法声明的形式参数范围" class="headerlink" title="传入的实际参数范围大于重载方法声明的形式参数范围"></a>传入的实际参数范围大于重载方法声明的形式参数范围</h3><p>反过来，如果传入的实际参数范围大于重载方法声明的形式参数，会是什么情况呢？我们再来测试一下。</p><p>foo1方法包含char/byte/short/int/long/float/double这7种基本数据类型的重载；</p><p>foo2方法包含char/byte/short/int/long/float这6种基本数据类型的重载；</p><p>foo3方法包含char/byte/short/int/long这5种基本数据类型的重载；</p><p>foo4方法包含char/byte/short/int这4种基本数据类型的重载；</p><p>foo5方法包含char/byte/short这3种基本数据类型的重载；</p><p>foo6方法包含char/byte这2种基本数据类型的重载；</p><p>foo7方法只有一个char类型参数的方法；</p><p>使用double类型的3.1415926分别调用foo系列的方法。我们可以看到编译器提示了错误：<code>Cannot resolve method &#39;foo2(double)&#39;</code>等。除了foo1方法外，其余foo系列的方法都不包含double类型的重载，编译器也不会隐式将double类型自动转换成其它基本类型，其原因在于double类型的取值范围（二进制位数）是最大的，如果将double类型的数据隐式转换成其它基本类型，可能会出现精度丢失的问题，这是有风险的，编译器不会自动帮我们做。</p><p>我们需要强制类型转换（显式转换）进行窄化处理，这样做可能会丢失精度。但如果不这样做，我们无法正常进行方法的调用。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.overload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/8</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * 基本数据类型重载的测试：基本数据类型范围较大的需要强制类型转换（显式转换）进行窄化处理，转换成范围较小的类型。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 基本数据类型（除去boolean）范围如下：</span></span><br><span class="line"><span class="comment"> * '[' 和 ']' 表示闭区间。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * byte   |  8 bits | [-128, +127]</span></span><br><span class="line"><span class="comment"> * char   | 16 bits | ['\u0000', '\uFFFF']</span></span><br><span class="line"><span class="comment"> * short  | 16 bits | [-2^15, +2^15 - 1]</span></span><br><span class="line"><span class="comment"> * int    | 32 bits | [-2^31, +2^31 - 1]</span></span><br><span class="line"><span class="comment"> * float  | 32 bits | IEEE754范围</span></span><br><span class="line"><span class="comment"> * double | 64 bits | IEEE754范围</span></span><br><span class="line"><span class="comment"> * long   | 64 bits | [-2^63, +2^63 - 1]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigToSmallDataTypeOverloadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * print:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * double: 3.1415926</span></span><br><span class="line"><span class="comment">     * foo1(double x)</span></span><br><span class="line"><span class="comment">     * foo2(float x)</span></span><br><span class="line"><span class="comment">     * foo3(long x)</span></span><br><span class="line"><span class="comment">     * foo4(int x)</span></span><br><span class="line"><span class="comment">     * foo5(short x)</span></span><br><span class="line"><span class="comment">     * foo6(byte x)</span></span><br><span class="line"><span class="comment">     * foo7(char x)</span></span><br><span class="line"><span class="comment">     * (float) d：3.1415925  // 可看到精度已经丢失</span></span><br><span class="line"><span class="comment">     * (long) d：3</span></span><br><span class="line"><span class="comment">     * (int) d：3</span></span><br><span class="line"><span class="comment">     * (short) d：3</span></span><br><span class="line"><span class="comment">     * (byte) d：3</span></span><br><span class="line"><span class="comment">     * (char) d：3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDouble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">3.1415926</span>;</span><br><span class="line">        System.out.println(<span class="string">"double: "</span> + d);</span><br><span class="line">        foo1(d);</span><br><span class="line">        foo2((<span class="keyword">float</span>) d);</span><br><span class="line">        foo3((<span class="keyword">long</span>) d);</span><br><span class="line">        foo4((<span class="keyword">int</span>) d);</span><br><span class="line">        foo5((<span class="keyword">short</span>) d);</span><br><span class="line">        foo6((<span class="keyword">byte</span>) d);</span><br><span class="line">        foo7((<span class="keyword">char</span>) d);</span><br><span class="line">        <span class="keyword">float</span> f = (<span class="keyword">float</span>) d;</span><br><span class="line">        System.out.println(<span class="string">"(float) d："</span> + f);</span><br><span class="line">        <span class="keyword">long</span> l = (<span class="keyword">long</span>) d;</span><br><span class="line">        System.out.println(<span class="string">"(long) d："</span> + l);</span><br><span class="line">        <span class="keyword">int</span> i = (<span class="keyword">int</span>) d;</span><br><span class="line">        System.out.println(<span class="string">"(int) d："</span> + i);</span><br><span class="line">        <span class="keyword">short</span> s = (<span class="keyword">short</span>) d;</span><br><span class="line">        System.out.println(<span class="string">"(short) d："</span> + s);</span><br><span class="line">        <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) d;</span><br><span class="line">        System.out.println(<span class="string">"(byte) d："</span> + b);</span><br><span class="line">        <span class="keyword">char</span> c = (<span class="keyword">char</span>) d;</span><br><span class="line">        System.out.println(<span class="string">"(char) d："</span> + (c + <span class="number">1</span> - <span class="number">1</span>)); <span class="comment">// 查看char表示的数值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo1 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo1(char x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo1(byte x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo1(short x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo1(int x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo1(long x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo1(float x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo1(double x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo2 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo2(char x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo2(byte x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo2(short x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo2(int x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo2(long x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo2(float x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo3 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo3</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo3(char x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo3</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo3(byte x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo3</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo3(short x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo3(int x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo3</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo3(long x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo4 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo4</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo4(char x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo4</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo4(byte x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo4</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo4(short x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo4</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo4(int x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo5 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo5</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo5(char x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo5</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo5(byte x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo5</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo5(short x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo6 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo6</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo6(char x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo6</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo6(byte x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo7 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo7</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo7(char x)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从输出结果中可看到：double类型的3.1415926强制转换成float时变成了3.1415925，精度已经丢失；而强制转换成long/int/short/byte/char时浮点部分直接被舍弃。</p><h2 id="返回值能区分重载方法吗？"><a href="#返回值能区分重载方法吗？" class="headerlink" title="返回值能区分重载方法吗？"></a>返回值能区分重载方法吗？</h2><p>例如有下面两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure><p>我们人用肉眼去看方法的声明很容易分辨这两个同名方法的不同之处。但是当我们去调用foo方法时，如果我们的调用方式是：<code>int x = foo()</code>，那么的确可以明确我们调用的是<code>int foo() {return -1;}</code>；但有时候我们并不在意返回值（只是调用方法去执行某个操作），调用方式为：<code>foo()</code>，这时候Java如何才能判断调用的是哪一个<code>foo()</code>呢？程序员又该如何理解这种代码呢？因此，返回值是不能区分方法重载的。</p><h2 id="int和Integer的形参是重载方法吗？"><a href="#int和Integer的形参是重载方法吗？" class="headerlink" title="int和Integer的形参是重载方法吗？"></a>int和Integer的形参是重载方法吗？</h2><p>例如有下面两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"int"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Integer y)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Integer"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们是重载方法吗？</p><p>即使int和Integer之间存在自动装箱/拆箱操作，但它们仍是重载的方法。</p><p>我们传递int类型的变量给foo，编译器并不会进行装箱操作，因为有对应的int类型重载方法；相应地，我们传递Integer类型的变量给foo，编译器不会进行拆箱操作，而是调用对应Integer类型的重载方法。</p><p>我们传递字面量1给foo方法，编译器会默认当成基本类型int调用foo。</p><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * print:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * int</span></span><br><span class="line"><span class="comment"> * int</span></span><br><span class="line"><span class="comment"> * Integer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 字面量值1是int基本数据类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 是重载方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIntInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    foo(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    foo(x);</span><br><span class="line">    Integer y = <span class="number">1</span>;</span><br><span class="line">    foo(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是方法重载Overload的全部内容，完整示例代码地址见：<a href="https://github.com/sunchaser-lilu/gold-road-to-Java/tree/master/JavaSE/src/main/java/com/sunchaser/javase/base/overload" target="_blank" rel="noopener">传送门</a></p>]]></content>
    
    <summary type="html">
    
      理解方法重载
    
    </summary>
    
    
      <category term="Java SE" scheme="https://lilu.org.cn/categories/Java-SE/"/>
    
    
      <category term="方法重载" scheme="https://lilu.org.cn/tags/%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>基本数据类型char为什么不会被隐式转换成byte或short类型？</title>
    <link href="https://lilu.org.cn/2020/01/09/javase/base/why-char-cannot-be-converted-to-byte-or-short/"/>
    <id>https://lilu.org.cn/2020/01/09/javase/base/why-char-cannot-be-converted-to-byte-or-short/</id>
    <published>2020-01-09T13:39:49.377Z</published>
    <updated>2020-01-08T16:51:03.477Z</updated>
    
    <content type="html"><![CDATA[<p>Java的基本数据类型中的数值类型包括：byte/char/short/int/float/double/long</p><p>其数值范围如下表所示：</p><table><thead><tr><th>基本类型</th><th align="center">大小</th><th align="left">范围</th></tr></thead><tbody><tr><td>byte</td><td align="center">8 bits</td><td align="left">[-128, +127]</td></tr><tr><td>char</td><td align="center">16 bits</td><td align="left">[‘\u0000’, ‘\uFFFF’] 即 [0, 2^16 - 1]</td></tr><tr><td>short</td><td align="center">16 bits</td><td align="left">[-2^15, +2^15 - 1]</td></tr><tr><td>int</td><td align="center">32 bits</td><td align="left">[-2^31, +2^31 - 1]</td></tr><tr><td>float</td><td align="center">32 bits</td><td align="left">IEEE754范围</td></tr><tr><td>double</td><td align="center">64 bits</td><td align="left">IEEE754范围</td></tr><tr><td>long</td><td align="center">64 bits</td><td align="left">[-2^63, +2^63 - 1]</td></tr></tbody></table><p>注：表格中的 ‘[‘ 和 ‘]’ 表示闭区间；IEEE754范围参考<a href="https://en.wikipedia.org/wiki/IEEE_754-1985" target="_blank" rel="noopener">wiki</a></p><p>char类型的表示范围可通过以下代码查看：0-65535</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Character.MIN_VALUE + 1 - 1);</span><br><span class="line">System.out.println(Character.MAX_VALUE + 1 - 1);</span><br></pre></td></tr></table></figure><p>byte类型只占一个字节（8比特），而char和short都占两个字节。char转成byte会出现装不下的情况，精度丢失，所以编译器不会自动进行隐式转换；</p><p>short类型虽然占两个字节，但其最大值是2^15-1，char的最大值是2^16-1，会出现转换不了的情况，所以编译器也不会进行隐式转换。</p><p>int类型是第一个数值范围比char大的类型，所以在涉及到隐式转换时，Java默认将char隐式转换成int。</p>]]></content>
    
    <summary type="html">
    
      基本数据类型char为什么不会被隐式转换成byte或short类型？
    
    </summary>
    
    
      <category term="Java SE" scheme="https://lilu.org.cn/categories/Java-SE/"/>
    
    
      <category term="隐式转换" scheme="https://lilu.org.cn/tags/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>2019年度总结</title>
    <link href="https://lilu.org.cn/2019/12/31/annual-summary/2019/"/>
    <id>https://lilu.org.cn/2019/12/31/annual-summary/2019/</id>
    <published>2019-12-31T13:45:45.300Z</published>
    <updated>2019-12-31T09:14:07.937Z</updated>
    
    <content type="html"><![CDATA[<p>2019是日无暇晷的一年。</p><p>从年初的大四准毕业生到现在半年经验的职场少年，一路走来，从技术菜鸟到小有成就，从稚嫩到沉稳，这是成长的印记。</p><p>2019前3个月是艰难的。犹记得2018年9月秋招经历过的恐惧，大三时“听信了”大学老师的谗言：PHP是世界上最好的语言。大三一整年都在学习PHP，某马程序员官网放出的PHP视频教程看了80%多。但现实终究是残酷的，国内大部分企业后端都还是以Java语言为主（别跟我讲百度用PHP）。秋招的PHP岗位实在是太少了，加上我只是一个双非普通一本学历，又没有什么拿得出手的获奖证书，根本就没有一点竞争力。于是修改了简历，项目经验写上了大学Java Web课程设计写的JSP+Servlet项目，就开始转向投递Java岗。</p><p>终于过了一家深圳互联网公司的笔试，来到面试阶段，跟面试官聊了一下大三学PHP的事情，然后开始问技术方面的问题，现在回想起来，当时的问题算得上是非常基础的知识点了。例如：int和Integer的区别？int和Integer作为同名方法的参数，算不算重载？</p><p>这是我的第一次Java面试，面试过程中满怀信心觉得自己都答对了，面试出来后查了下百度，发现好像一个都没答对。“电子竞技，菜是原罪”。</p><p>当时深刻认识到凭当时的自身技术能力想找Java开发的岗位几乎是不可能的，于是做了一个很果断的决定，停止投递简历，系统学习Java知识体系，等待春招。</p><p>某北大学计算机学院的学生宿舍在校外（俗称“三期”公寓），没有独卫，没有空调，六人间。自学是很考验人的，那个时候刚转向Java，疯狂的找学习资料，某马程序员，某硅谷，某学堂，某客网，某宝…几乎所有的免费视频教程我都下载了。面对几十个G的资源，我陷入了迷茫，该从何学起呢？</p><p>那个时候我的知识体系基本是一片空白，只有大学的Java基础课程和J2EE课程学的一点知识储备。听了同学的建议后，决定从某客网高级项目课开始学起，跟随项目需求，对项目中用到的知识点，技术框架进行细致学习。然而一切都是艰难的，这个项目用的技术栈主要是Spring Boot、Mybatis等，对于当时连Spring都不知道的我，实在是太难了。</p><p>于是我打开了某马程序员的Spring入门到精通视频，从传统的Java Web到引入DI/IOC，大概能听懂一点，我开始打开IDE对着视频敲代码，经常一个视频重复播放三遍甚至更多，第一遍是听大概的内容，第二遍是细听，然后跟着敲代码，第三遍是总结性的听，做一些笔记。</p><p>但是我发现，我对Java语言的一些基础性的语法和概念还不是太熟悉，于是我打开了2018年双十一买的《Java编程思想》，开始了解Java语言的一些特性。同时还看了某马程序员创始人张老师的《Java高新技术》视频课程，对我影响甚大，视频内容基本是JDK5的新特性，包括静态导包、可变参数、增强for循环、自动拆/装箱、享元设计模式、枚举、反射、类加载器、双亲委派模型、注解、泛型和动态代理等。这套视频算得上是彻底改变了我，真正的让我入了Java的门。</p><p>此后，还看了张老师的《Java多线程与并发库》这套视频，这套视频奠定了我的Java基础，视频主要讲解了传统线程同步与互斥技术、ThreadLocal类、Callable和Future类、Timer定时器类、线程池、读写锁、闭锁、栅栏、计数器、阻塞队列、原子操作类和同步集合等内容。</p><p>再之后，我接触到了Spring，Spring MVC，Mybatis，Maven，Spring Boot，Redis…等一些技术栈。</p><p>基本熟悉这些框架之后，我继续了某客网高级项目课，春节在家的一个月，跟着视频把代码写的差不多了。然后把这个项目当做项目经验填充在自己的简历上。</p><p>对于这个项目，我并不是完全照搬视频中所讲，而是采用标准前后端分离开发模式，前端选择了Vue全家桶技术栈，后端则是视频中的Spring Boot技术栈，这对于我的项目经验来说是一个加分项。</p><p>经过为期五个月的学习，我开始春招的步伐，经过二月底三月初一个多月的跑宣讲会，参加笔试面试，最终收获了一家武汉的Offer，一切都挺幸运的，这家公司的薪资，技术栈都比较满意。终于是功夫不负有心人。</p><p>7月，入职。</p><p>进入新公司，新环境，成为了社会人，很激动。</p><p>9月，参与的第一个需求上线。老总请喝酒，喝吐了一片人，我也吐倒在门外。</p><p>10月，开始了今年最大的一个项目，加班通宵了两次。很累。</p><p>12月，出差来到了北京，看了天安门，看了紫禁城，看了恭王府，看了水立方，看了鸟巢。不虚此行。</p><p>末了，12月的最后一天进行了转正答辩，应该是转正了。</p><p>且行且珍惜。</p><p>2020年，希望可以遇见更好的自己，提高时间规划能力与自控力，形成自己的知识体系，并深入到技术中。</p>]]></content>
    
    <summary type="html">
    
      艰难，幸运，艰难-我的2019年度总结
    
    </summary>
    
    
      <category term="年度总结" scheme="https://lilu.org.cn/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="年度总结" scheme="https://lilu.org.cn/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>JavaBucket</title>
    <link href="https://lilu.org.cn/2019/12/13/java-bucket/"/>
    <id>https://lilu.org.cn/2019/12/13/java-bucket/</id>
    <published>2019-12-13T13:39:28.483Z</published>
    <updated>2019-12-13T13:17:07.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java成魔之路"><a href="#Java成魔之路" class="headerlink" title="Java成魔之路"></a>Java成魔之路</h2><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/KqUBzrXAP4JOjHd.png"  alt="gold-road-to-java.png"></p><h2 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h2><ul><li>数据类型</li><li>类和对象</li><li>异常</li><li>反射</li><li>泛型</li><li>容器</li><li>并发</li><li>IO</li><li>JVM</li></ul><h2 id="数据结构-算法"><a href="#数据结构-算法" class="headerlink" title="数据结构-算法"></a>数据结构-算法</h2><h3 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h3><ul><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/%E7%AE%97%E6%B3%95/LeetCode%E9%A2%98%E8%A7%A3/docs/%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.md" target="_blank" rel="noopener">（简单）两数之和</a></li></ul><p>待完善…</p><h2 id="JavaEE"><a href="#JavaEE" class="headerlink" title="JavaEE"></a>JavaEE</h2><p>待完善…</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/String%E5%AD%97%E7%AC%A6%E4%B8%B2.md" target="_blank" rel="noopener">String字符串</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/List%E5%88%97%E8%A1%A8.md" target="_blank" rel="noopener">List列表</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Hash%E5%93%88%E5%B8%8C.md" target="_blank" rel="noopener">Hash哈希</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Set%E9%9B%86%E5%90%88.md" target="_blank" rel="noopener">Set集合</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/ZSet%E9%9B%86%E5%90%88.md" target="_blank" rel="noopener">ZSet集合</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE.md" target="_blank" rel="noopener">Redis集群配置</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E9%80%9A%E7%94%A8Redis%E5%91%BD%E4%BB%A4.md" target="_blank" rel="noopener">通用Redis命令</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86.md" target="_blank" rel="noopener">Redis扩展知识</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E5%85%B6%E5%AE%83Redis%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%91%BD%E4%BB%A4.md" target="_blank" rel="noopener">其它Redis服务器命令</a></li></ul><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><ul><li>Apache ShardingSphere<ul><li><a href="https://lilu.org.cn/2019/12/12/middleware/sharding-sphere/sharding-jdbc-introduction/">分库分表中间件之ShardingSphere-入门案例</a></li></ul></li><li>xxl-job<ul><li><a href="https://lilu.org.cn/2020/02/13/middleware/xxl-job/build-local-dispatch-platform/">修炼xxl-job之搭建本地调度平台</a></li><li><a href="https://lilu.org.cn/2020/02/13/middleware/xxl-job/demo-executor-xxljobconfig-sourcecode-analysis/">修炼xxl-job之示例执行器XxlJobConfig配置类源码解析</a></li><li><a href="https://lilu.org.cn/2020/02/26/middleware/xxl-job/dispatch-center-start-process-analysis/">修炼xxl-job之调度中心启动流程解析</a></li><li><a href="https://lilu.org.cn/2020/02/27/middleware/xxl-job/initI18n/">修炼xxl-job之调度中心—初始化国际化组件</a></li><li><a href="https://lilu.org.cn/2020/02/29/middleware/xxl-job/registry-center-heartbeat-renewal/">修炼xxl-job之调度中心—初始化注册中心“心跳续约”服务</a></li><li><a href="https://lilu.org.cn/2020/03/03/middleware/xxl-job/job-fail-monitor/">修炼xxl-job之调度中心—初始化失败任务管理中心</a><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2>待完善…</li></ul></li></ul><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>待完善…</p><h2 id="项目管理-持续集成"><a href="#项目管理-持续集成" class="headerlink" title="项目管理-持续集成"></a>项目管理-持续集成</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/Linux/Linux%E5%91%BD%E4%BB%A4.md" target="_blank" rel="noopener">Linux命令</a></li></ul><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>待完善…</p><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><p>待完善…</p><h2 id="优秀书籍"><a href="#优秀书籍" class="headerlink" title="优秀书籍"></a>优秀书籍</h2><ul><li>Java 8实战<ul><li><a href="https://lilu.org.cn/2019/12/12/reading-notes/Java8-in-action/Part-I-Basics/">《Java 8实战》读书笔记系列——第一部分：基础知识</a></li><li><a href="https://lilu.org.cn/2019/12/12/reading-notes/Java8-in-action/Part-II-Functional-Data-Processing/">《Java 8实战》读书笔记系列——第二部分：函数式数据处理</a></li><li><a href="https://lilu.org.cn/2019/12/12/reading-notes/Java8-in-action/Part-III-Efficient-Java8-Programming(1)/">《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（一）：接口重构和新特性</a></li><li><a href="https://lilu.org.cn/2019/12/12/reading-notes/Java8-in-action/Part-III-Efficient-Java8-Programming(2)/">《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（二）：优雅的解决NPE问题</a></li><li><a href="https://lilu.org.cn/2019/12/12/reading-notes/Java8-in-action/Part-III-Efficient-Java8-Programming(3)/">《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（三）：从一个生产环境的事故到异步编程思想</a></li><li><a href="https://lilu.org.cn/2019/12/12/reading-notes/Java8-in-action/Part-III-Efficient-Java8-Programming(4)/">《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（四）：使用新的日期时间API</a></li></ul></li></ul><p>待完善…</p><ul><li>《剑指Offer》<ul><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">实现线程安全的单例模式</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%EF%BC%88%E9%A2%98%E7%9B%AE%E4%B8%80%EF%BC%89.md" target="_blank" rel="noopener">数组中重复的数（题目一）</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%EF%BC%88%E9%A2%98%E7%9B%AE%E4%BA%8C%EF%BC%89.md" target="_blank" rel="noopener">数组中重复的数（题目二）</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.md" target="_blank" rel="noopener">二维数组中的查找</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.md" target="_blank" rel="noopener">替换空格</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E9%9D%A2%E8%AF%95%E9%A2%985%EF%BC%88%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%EF%BC%89.md" target="_blank" rel="noopener">面试题5（相关题目）</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.md" target="_blank" rel="noopener">从尾到头打印链表</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.md" target="_blank" rel="noopener">重建二叉树</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9.md" target="_blank" rel="noopener">二叉树的下一个节点</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97.md" target="_blank" rel="noopener">两个栈实现一个队列</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A0%88.md" target="_blank" rel="noopener">两个队列实现一个栈</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E6%96%90%E6%B3%A2%E9%82%A3%E6%A5%94%E6%95%B0%E5%88%97.md" target="_blank" rel="noopener">斐波那楔数列</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98.md" target="_blank" rel="noopener">青蛙跳台阶问题</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98%E6%89%A9%E5%B1%95%EF%BC%88%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6%EF%BC%89.md" target="_blank" rel="noopener">青蛙跳台阶问题扩展（变态跳台阶）</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96.md" target="_blank" rel="noopener">矩形覆盖</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E5%87%A0%E4%B8%87%E4%B8%AA%E5%91%98%E5%B7%A5%E5%B9%B4%E9%BE%84%E6%8E%92%E5%BA%8F.md" target="_blank" rel="noopener">几万个员工年龄排序</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.md" target="_blank" rel="noopener">旋转数组的最小数字</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.md" target="_blank" rel="noopener">矩阵中的路径</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4.md" target="_blank" rel="noopener">机器人的运动范围</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E5%89%AA%E7%BB%B3%E5%AD%90.md" target="_blank" rel="noopener">剪绳子</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.md" target="_blank" rel="noopener">二进制中1的个数</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.md" target="_blank" rel="noopener">数值的整数次方</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0.md" target="_blank" rel="noopener">打印从1到最大的n位数</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E5%9C%A8O(1)%E6%97%B6%E9%97%B4%E5%86%85%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9.md" target="_blank" rel="noopener">在O(1)时间内删除链表节点</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9.md" target="_blank" rel="noopener">删除链表中重复的节点</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D.md" target="_blank" rel="noopener">正则表达式匹配</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.md" target="_blank" rel="noopener">表示数值的字符串</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9.md" target="_blank" rel="noopener">链表中倒数第k个节点</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9.md" target="_blank" rel="noopener">链表中环的入口节点</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.md" target="_blank" rel="noopener">反转链表</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8.md" target="_blank" rel="noopener">合并两个排序的链表</a></li></ul></li></ul><p>待完善…</p><ul><li>《程序员代码面试指南-IT名企算法和数据结构题目最优解》</li></ul><p>待完善…</p>]]></content>
    
    <summary type="html">
    
      Java成魔之路
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（四）：使用新的日期时间API</title>
    <link href="https://lilu.org.cn/2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(4)/"/>
    <id>https://lilu.org.cn/2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(4)/</id>
    <published>2019-12-12T13:38:35.289Z</published>
    <updated>2019-12-12T13:04:54.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第十二章：新的日期时间API"><a href="#第十二章：新的日期时间API" class="headerlink" title="第十二章：新的日期时间API"></a>第十二章：新的日期时间API</h2><p>在Java 8之前，我们常用的日期时间API是<code>java.util.Date</code>和<code>java.util.Calendar</code>这两个类。</p><p>如果我们要构建一个指定年月日的日期时间对象，比如<code>2019-9-2</code>，使用<code>java.util.Date</code>类的构造方法<code>Date(int year, int month, int date)</code>，传入的年份year参数必须是年份2019减去1900，即传入119。每次创建对象前还需要先进行计算，很不方便。</p><p>JDK 1.1提供的<code>java.util.Calendar</code>类在使用时也有很多不方便的地方，比如对一个日期加两天，使用<code>add</code>方法，传入2；对一个日期减两天，也使用<code>add</code>方法，传入-2。还有一点是这个类默认每周第一天是周日。使用起来也有点不方便。</p><p>归根到底，JDK1.8之前的日期时间API都是可变的，是线程不安全的。</p><p>另外，对时间日期进行格式化的类<code>SimpleDateFormat</code>在<code>java.text</code>包下，该类的定义位置不规范。它也是线程不安全的。</p><p>而在Java 8中，时间格式转化器是<code>java.time.format.DateTimeFormatter</code>类，它被声明为<code>final</code>，是不可变的类，线程安全。</p><p>另外，Java 8中提供的新日期时间API包含两类：一个是为了便于人阅读使用，包含<code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>这三个类，它们都是用<code>final</code>修饰的类，是不可变的对象，分别表示<code>ISO-8601</code>日历系统中的日期、时间、日期和时间。另外一个是便于机器处理的类，<code>Instant</code>：用来表示机器的日期和时间格式：时间戳。</p><blockquote><p>ISO-8601日历系统：是国际标准化组织制定的现代公民的日期和时间的表示法。<br>时间戳：从UNIX元年：1970年1月1日 00:00:00到某个时间之间的毫秒值。</p></blockquote><h3 id="传统时间格式转换器SimpleDateFormat线程安全问题演示"><a href="#传统时间格式转换器SimpleDateFormat线程安全问题演示" class="headerlink" title="传统时间格式转换器SimpleDateFormat线程安全问题演示"></a>传统时间格式转换器SimpleDateFormat线程安全问题演示</h3><p>当多个线程同时操作同一个<code>SimpleDateFormat</code>对象时，就会出现线程安全问题。</p><p>演示代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">    &#x2F;&#x2F; 使用线程池模拟多线程</span><br><span class="line">    ExecutorService threadPool &#x3D; Executors.newFixedThreadPool(10);</span><br><span class="line">    &#x2F;&#x2F; 定义解析日期字符串任务：使用SimpleDateFormat对象解析</span><br><span class="line">    Callable&lt;Date&gt; task &#x3D; () -&gt; sdf.parse(&quot;2019-8-29&quot;);</span><br><span class="line">    &#x2F;&#x2F; 存储结果容器</span><br><span class="line">    List&lt;Future&lt;Date&gt;&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 执行得到解析结果</span><br><span class="line">        result.add(threadPool.submit(task));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 遍历输出</span><br><span class="line">    for (Future&lt;Date&gt; r : result) &#123;</span><br><span class="line">        System.out.println(r.get());</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.ExecutionException: java.lang.NumberFormatException: multiple points</span><br></pre></td></tr></table></figure><p>解决方法：<br>1、将<code>SimpleDateFormat</code>定义为方法内的局部变量，且方法中没有多线程的操作。<br>2、使用<code>ThreadLocal</code>进行线程封闭。为每个线程保存一个<code>SimpleDateFormat</code>对象。</p><h3 id="传统时间格式转换器线程安全问题解决方案：使用ThreadLocal进行线程封闭"><a href="#传统时间格式转换器线程安全问题解决方案：使用ThreadLocal进行线程封闭" class="headerlink" title="传统时间格式转换器线程安全问题解决方案：使用ThreadLocal进行线程封闭"></a>传统时间格式转换器线程安全问题解决方案：使用ThreadLocal进行线程封闭</h3><p>线程封闭类代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package cn.org.lilu.chapter12;</span><br><span class="line"></span><br><span class="line">import java.text.DateFormat;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: lilu</span><br><span class="line"> * @Date: 2019&#x2F;8&#x2F;29</span><br><span class="line"> * @Description: 传统时间格式转换器线程安全问题解决方案：使用ThreadLocal进行线程封闭</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class TraditionalSimpleDateFormatThreadLocal &#123;</span><br><span class="line">    private static final ThreadLocal&lt;DateFormat&gt; threadLocal &#x3D; new ThreadLocal&lt;DateFormat&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected DateFormat initialValue() &#123;</span><br><span class="line">            return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static Date convert(String source) throws Exception &#123;</span><br><span class="line">        return threadLocal.get().parse(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>演示代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F; 使用线程池模拟多线程</span><br><span class="line">    ExecutorService threadPool &#x3D; Executors.newFixedThreadPool(10);</span><br><span class="line">    &#x2F;&#x2F; 定义解析日期字符串任务：每个任务都有一份SimpleDateFormat对象的副本</span><br><span class="line">    Callable&lt;Date&gt; task &#x3D; () -&gt; TraditionalSimpleDateFormatThreadLocal.convert(&quot;2019-8-29&quot;);</span><br><span class="line">    &#x2F;&#x2F; 解析结果容器</span><br><span class="line">    List&lt;Future&lt;Date&gt;&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 执行得到解析结果</span><br><span class="line">        result.add(threadPool.submit(task));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 遍历输出</span><br><span class="line">    for (Future&lt;Date&gt; r : result) &#123;</span><br><span class="line">        System.out.println(r.get());</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果正常。</p><h3 id="Java-8新的时间格式转化器DateTimeFormatter"><a href="#Java-8新的时间格式转化器DateTimeFormatter" class="headerlink" title="Java 8新的时间格式转化器DateTimeFormatter"></a>Java 8新的时间格式转化器DateTimeFormatter</h3><p><code>DateTimeFormatter</code>类定义在<code>java.time.format</code>包下，且声明为<code>final</code>类，不可变，线程安全。</p><p>代码演示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F; 按照哪种格式进行格式转换</span><br><span class="line">    &#x2F;&#x2F; DateTimeFormatter dtf &#x3D; DateTimeFormatter.ISO_LOCAL_DATE;</span><br><span class="line">    DateTimeFormatter dtf &#x3D; DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;);</span><br><span class="line">    &#x2F;&#x2F; LocalDate.parse(&quot;20190829&quot;,dtf)：将第一个字符串参数按照第二个参数定义的格式器解析，返回一个LocalDate对象</span><br><span class="line">    Callable&lt;LocalDate&gt; task &#x3D; () -&gt; LocalDate.parse(&quot;20190829&quot;,dtf);</span><br><span class="line">    ExecutorService threadPool &#x3D; Executors.newFixedThreadPool(10);</span><br><span class="line">    List&lt;Future&lt;LocalDate&gt;&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">        result.add(threadPool.submit(task));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 遍历输出</span><br><span class="line">    for (Future&lt;LocalDate&gt; r : result) &#123;</span><br><span class="line">        System.out.println(r.get());</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java-8日期时间API：LocalDate、LocalTime、LocalDateTime"><a href="#Java-8日期时间API：LocalDate、LocalTime、LocalDateTime" class="headerlink" title="Java 8日期时间API：LocalDate、LocalTime、LocalDateTime"></a>Java 8日期时间API：LocalDate、LocalTime、LocalDateTime</h3><p>这三个类的用法几乎一样，<code>LocalDate</code>表示日期，<code>LocalTime</code>表示时间，<code>LocalDateTime</code>包含前两者，表示日期和时间。</p><p>可由前两个类组合出第三个类，也可由第三个类提取出前两个类。</p><h4 id="年月日对象：LocalDate"><a href="#年月日对象：LocalDate" class="headerlink" title="年月日对象：LocalDate"></a>年月日对象：LocalDate</h4><p>可使用静态工厂方法<code>now</code>获取当前日期；</p><p>可使用静态工厂方法<code>of</code>创建一个<code>LocalDate</code>日期对象，可从一个<code>LocalDate</code>日期对象中获取该日期的年份、月份、这个月的第几天、这周的星期几、今年的第几天、这个月的长度（有几天）和是否为闰年等信息。</p><p>代码演示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * LocalDate：年月日</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testLocalDate() &#123;</span><br><span class="line">    &#x2F;&#x2F; 静态工厂方法now获取当前日期</span><br><span class="line">    LocalDate now &#x3D; LocalDate.now();</span><br><span class="line">    &#x2F;&#x2F; 静态工厂方法of创建一个LocalDate实例</span><br><span class="line">    LocalDate date &#x3D; LocalDate.of(2019,8,26);</span><br><span class="line">    &#x2F;&#x2F; 年份</span><br><span class="line">    int year &#x3D; date.getYear();</span><br><span class="line">    &#x2F;&#x2F; 月份</span><br><span class="line">    Month month &#x3D; date.getMonth();</span><br><span class="line">    &#x2F;&#x2F; 这个月第几天</span><br><span class="line">    int dayOfMonth &#x3D; date.getDayOfMonth();</span><br><span class="line">    &#x2F;&#x2F; 这周星期几</span><br><span class="line">    DayOfWeek dayOfWeek &#x3D; date.getDayOfWeek();</span><br><span class="line">    &#x2F;&#x2F; 今年第几天</span><br><span class="line">    int dayOfYear &#x3D; date.getDayOfYear();</span><br><span class="line">    &#x2F;&#x2F; 这个月的长度（有几天）</span><br><span class="line">    int lengthOfMonth &#x3D; date.lengthOfMonth();</span><br><span class="line">    &#x2F;&#x2F; 是否闰年</span><br><span class="line">    boolean leapYear &#x3D; date.isLeapYear();</span><br><span class="line">    System.out.println(now); &#x2F;&#x2F; 2019-09-02</span><br><span class="line">    System.out.println(year); &#x2F;&#x2F; 2019</span><br><span class="line">    System.out.println(month); &#x2F;&#x2F; AUGUST</span><br><span class="line">    System.out.println(dayOfMonth); &#x2F;&#x2F; 26</span><br><span class="line">    System.out.println(dayOfWeek); &#x2F;&#x2F; MONDAY</span><br><span class="line">    System.out.println(dayOfYear); &#x2F;&#x2F; 238</span><br><span class="line">    System.out.println(lengthOfMonth); &#x2F;&#x2F; 31</span><br><span class="line">    System.out.println(leapYear); &#x2F;&#x2F; false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时分秒对象：LocalTime"><a href="#时分秒对象：LocalTime" class="headerlink" title="时分秒对象：LocalTime"></a>时分秒对象：LocalTime</h4><p>可使用静态工厂方法<code>now</code>获取当前时间的时分秒（包含纳秒）。</p><p>可使用静态工厂方法<code>of</code>创建一个<code>LocalTime</code>时间对象，可从一个<code>LocalTime</code>时间对象中获取该时间的时、分、秒和纳秒等信息。</p><p><code>of</code>方法包含三个重载，方法签名如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param hour  the hour-of-day to represent, from 0 to 23</span><br><span class="line"> * @param minute  the minute-of-hour to represent, from 0 to 59</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static LocalTime of(int hour, int minute);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param hour  the hour-of-day to represent, from 0 to 23</span><br><span class="line"> * @param minute  the minute-of-hour to represent, from 0 to 59</span><br><span class="line"> * @param second  the second-of-minute to represent, from 0 to 59</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static LocalTime of(int hour, int minute, int second);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param hour  the hour-of-day to represent, from 0 to 23</span><br><span class="line"> * @param minute  the minute-of-hour to represent, from 0 to 59</span><br><span class="line"> * @param second  the second-of-minute to represent, from 0 to 59</span><br><span class="line"> * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static LocalTime of(int hour, int minute, int second, int nanoOfSecond);</span><br></pre></td></tr></table></figure><p>使用代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * LocalTime：时分秒</span><br><span class="line"> * 一天中的时间，比如：13:45:20，可以使用LocalTime类表示</span><br><span class="line"> * 可以使用of重载的三个静态工厂方法创建LocalTime实例</span><br><span class="line"> * 第一个重载方法接收小时和分钟</span><br><span class="line"> * 第二个重载方法同时还接收秒</span><br><span class="line"> * 第三个重载方法同时还接收纳秒</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testLocalTime() &#123;</span><br><span class="line">    LocalTime now &#x3D; LocalTime.now();</span><br><span class="line">    LocalTime localTime &#x3D; LocalTime.of(13, 45, 20,1);</span><br><span class="line">    int hour &#x3D; localTime.getHour();</span><br><span class="line">    int minute &#x3D; localTime.getMinute();</span><br><span class="line">    int second &#x3D; localTime.getSecond();</span><br><span class="line">    int nano &#x3D; localTime.getNano();</span><br><span class="line">    System.out.println(now); &#x2F;&#x2F; 19:47:51.212</span><br><span class="line">    System.out.println(hour); &#x2F;&#x2F; 13</span><br><span class="line">    System.out.println(minute); &#x2F;&#x2F; 45</span><br><span class="line">    System.out.println(second); &#x2F;&#x2F; 20</span><br><span class="line">    System.out.println(nano); &#x2F;&#x2F; 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="日期时间字符串解析"><a href="#日期时间字符串解析" class="headerlink" title="日期时间字符串解析"></a>日期时间字符串解析</h4><p>LocalDate和LocalTime都可以通过解析代表它们的字符串创建。使用静态方法parse。一旦传递的字符串参数无法被解析为合法的LocalDate或LocalTime对象，这两个parse方法都会抛出一个继承自RuntimeException的DateTimeParseException异常。</p><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * LocalDate和LocalTime都可以通过解析代表它们的字符串创建。使用静态方法parse。</span><br><span class="line"> * 一旦传递的字符串参数无法被解析为合法的LocalDate或LocalTime对象，</span><br><span class="line"> * 这两个parse方法都会抛出一个继承自RuntimeException的DateTimeParseException异常。</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testParse() &#123;</span><br><span class="line">    &#x2F;&#x2F; 小于10的必须在前面补0，否则抛出异常</span><br><span class="line">    LocalDate localDate &#x3D; LocalDate.parse(&quot;2019-08-26&quot;);</span><br><span class="line">    LocalTime localTime &#x3D; LocalTime.parse(&quot;13:45:20&quot;);</span><br><span class="line">    System.out.println(localDate);</span><br><span class="line">    System.out.println(localTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="年月日时分秒对象：LocalDateTime"><a href="#年月日时分秒对象：LocalDateTime" class="headerlink" title="年月日时分秒对象：LocalDateTime"></a>年月日时分秒对象：LocalDateTime</h4><p>可使用静态工厂方法<code>now</code>获取当前时间的年月日时分秒纳秒；</p><p>可使用静态工厂方法<code>of</code>创建一个<code>LocalDateTime</code>日期时间对象；</p><p>可由<code>LocalDate</code>和<code>LocalTime</code>组合出<code>LocalDateTime</code>对象；</p><p>可从<code>LocalDateTime</code>对象中提取出<code>LocalDate</code>和<code>LocalTime</code>。</p><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * LocalDateTime：年月日时分秒</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testLocalDateTime() &#123;</span><br><span class="line">    LocalDateTime localDateTime &#x3D; LocalDateTime.now();</span><br><span class="line">    LocalDateTime localDateTime1 &#x3D; LocalDateTime.of(2019, Month.AUGUST, 26, 10, 47, 20);</span><br><span class="line">    LocalDate localDate &#x3D; LocalDate.now();</span><br><span class="line">    LocalTime localTime &#x3D; LocalTime.now();</span><br><span class="line">    &#x2F;&#x2F; 由LocalDate和LocalTime组合出LocalDateTime</span><br><span class="line">    LocalDateTime localDateTime2 &#x3D; LocalDateTime.of(localDate,localTime);</span><br><span class="line">    LocalDateTime localDateTime3 &#x3D; localDate.atTime(10,51,32);</span><br><span class="line">    LocalDateTime localDateTime4 &#x3D; localDate.atTime(localTime);</span><br><span class="line">    LocalDateTime localDateTime5 &#x3D; localTime.atDate(localDate);</span><br><span class="line">    &#x2F;&#x2F; 由LocalDateTime提取出LocalDate和LocalTime</span><br><span class="line">    LocalDate localDateFromLocalDateTime &#x3D; localDateTime2.toLocalDate();</span><br><span class="line">    LocalTime localTimeFromLocalDateTime &#x3D; localDateTime2.toLocalTime();</span><br><span class="line"></span><br><span class="line">    System.out.println(localDateTime); &#x2F;&#x2F; 2019-09-02T19:57:16.516</span><br><span class="line">    System.out.println(localDateTime1); &#x2F;&#x2F; 2019-08-26T10:47:20</span><br><span class="line">    System.out.println(localDateTime2); &#x2F;&#x2F; 2019-09-02T19:57:16.517</span><br><span class="line">    System.out.println(localDateTime3); &#x2F;&#x2F; 2019-09-02T10:51:32</span><br><span class="line">    System.out.println(localDateTime4); &#x2F;&#x2F; 2019-09-02T19:57:16.517</span><br><span class="line">    System.out.println(localDateTime5); &#x2F;&#x2F; 2019-09-02T19:57:16.517</span><br><span class="line">    System.out.println(localDateFromLocalDateTime); &#x2F;&#x2F; 2019-09-02</span><br><span class="line">    System.out.println(localTimeFromLocalDateTime); &#x2F;&#x2F; 19:57:16.517</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间戳对象：Instant"><a href="#时间戳对象：Instant" class="headerlink" title="时间戳对象：Instant"></a>时间戳对象：Instant</h4><p>机器的日期和时间格式：从UNIX元年时间开始到现在所经过的秒数对时间进行建模。包含的是由秒及纳秒组成的数字。</p><p>使用静态工厂方法<code>now</code>获取当前时刻的时间戳，默认获取的是UTC时区（世界协调时间）所在的时刻，可做时区偏移运算获取带偏移量的日期时间对象<code>OffsetDateTime</code>。可使用<code>toEpochMilli</code>方法获取表示的时间戳秒数。</p><p>可使用静态工厂方法<code>ofEpochSecond</code>等对时间戳进行运算。</p><p><code>Instant</code>的设计初衷是为了便于机器使用。它包含的是由秒及纳秒所构成的数字。所以，它无法处理那些我们非常容易理解的时间单位。比如下面这行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int day &#x3D; Instant.now().get(ChronoField.DAY_OF_MONTH);</span><br></pre></td></tr></table></figure><p>它会抛出如下异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.time.temporal.UnsupportedTemporalTypeException: Unsupported field: DayOfMonth</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Instant：从UNIX元年时间开始到现在所经过的秒数对时间进行建模。包含的是由秒及纳秒组成的数字。</span><br><span class="line"> *</span><br><span class="line"> * 静态工厂方法：ofEpochSecond包含两个重载版本</span><br><span class="line"> * &#x2F;&#x2F; 传入一个代表秒数的值创建一个Instant实例</span><br><span class="line"> * Instant ofEpochSecond(long epochSecond)</span><br><span class="line"> * &#x2F;&#x2F; 第一个参数：代表秒数的值，第二个参数：纳秒数，对第一个参数传入的秒数进行调整，确保保存的纳秒分片在0到999 999 999之间。</span><br><span class="line"> * Instant ofEpochSecond(long epochSecond, long nanoAdjustment)</span><br><span class="line"> *</span><br><span class="line"> * 静态工厂方法：now</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testInstant() &#123;</span><br><span class="line">    Instant instant1 &#x3D; Instant.ofEpochSecond(3);</span><br><span class="line">    Instant instant2 &#x3D; Instant.ofEpochSecond(3, 0);</span><br><span class="line">    Instant instant3 &#x3D; Instant.ofEpochSecond(2, 1_000_000_000);</span><br><span class="line">    Instant instant4 &#x3D; Instant.ofEpochSecond(4, -1_000_000_000);</span><br><span class="line">    System.out.println(instant1);</span><br><span class="line">    System.out.println(instant2);</span><br><span class="line">    System.out.println(instant3);</span><br><span class="line">    System.out.println(instant4);</span><br><span class="line"></span><br><span class="line">    Instant now &#x3D; Instant.now(); &#x2F;&#x2F; 默认获取UTC时区的时间</span><br><span class="line">    System.out.println(now);</span><br><span class="line">    &#x2F;&#x2F; 时区偏移运算：获取偏移8小时的时区的时间。OffsetDateTime：带偏移量的日期时间对象</span><br><span class="line">    OffsetDateTime offsetDateTime &#x3D; now.atOffset(ZoneOffset.ofHours(8));</span><br><span class="line">    System.out.println(offsetDateTime);</span><br><span class="line">    &#x2F;&#x2F; 转化成时间戳</span><br><span class="line">    System.out.println(now.toEpochMilli());</span><br><span class="line">    &#x2F;&#x2F; java.time.temporal.UnsupportedTemporalTypeException: Unsupported field: DayOfMonth</span><br><span class="line">    int day &#x3D; now.get(ChronoField.DAY_OF_MONTH);</span><br><span class="line">    System.out.println(day);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算两个时间之间的间隔：Duration-和计算两个日期之间的间隔：Period"><a href="#计算两个时间之间的间隔：Duration-和计算两个日期之间的间隔：Period" class="headerlink" title="计算两个时间之间的间隔：Duration 和计算两个日期之间的间隔：Period"></a>计算两个时间之间的间隔：Duration 和计算两个日期之间的间隔：Period</h4><p>可以使用<code>Duration</code>类的静态方法<code>between</code>计算两个时间点之间的间隔，<code>between</code>方法接收的参数是两个<code>Temporal</code>对象，虽然<code>LocalDateTime</code>和<code>Instant</code>都是<code>Temporal</code>接口的实现类，但是它们是为不同的目的而设计的，一个是为了便于人阅读使用， 另一个是为了便于机器处理，所以我们不能将它们混用，即不能计算<code>LocalDateTime</code>和<code>Instant</code>对象之间的间隔。</p><p>可以使用<code>Period</code>类的静态方法<code>between</code>计算两个日期之间的间隔。</p><p>也可使用静态工厂方法直接创建<code>Duration</code>和<code>Period</code>类的对象。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 计算两个时间之间的间隔：Duration</span><br><span class="line"> * 计算两个日期之间的间隔：Period</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testDuration() throws Exception &#123;</span><br><span class="line">    LocalTime localTime1 &#x3D; LocalTime.parse(&quot;13:45:20&quot;);</span><br><span class="line">    LocalTime localTime2 &#x3D; LocalTime.parse(&quot;13:45:30&quot;);</span><br><span class="line">    LocalDateTime localDateTime1 &#x3D; LocalDateTime.now();</span><br><span class="line">    Thread.sleep(100);</span><br><span class="line">    LocalDateTime localDateTime2 &#x3D; LocalDateTime.now();</span><br><span class="line">    Instant instant1 &#x3D; Instant.ofEpochSecond(3);</span><br><span class="line">    Instant instant2 &#x3D; Instant.ofEpochSecond(6);</span><br><span class="line">    System.out.println(Duration.between(localTime1,localTime2)); &#x2F;&#x2F; PT10S</span><br><span class="line">    System.out.println(Duration.between(localDateTime1,localDateTime2)); &#x2F;&#x2F; PT0.1S</span><br><span class="line">    System.out.println(Duration.between(instant1,instant2)); &#x2F;&#x2F; PT3S</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 计算两个LocalDate之间的时长</span><br><span class="line">    Period periodBetween &#x3D; Period.between(LocalDate.of(2019, 8, 26), LocalDate.of(2019, 8, 28));</span><br><span class="line">    System.out.println(periodBetween); &#x2F;&#x2F; P1D</span><br><span class="line">    System.out.println(periodBetween.getDays()); &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Duration和Period的静态工厂方法直接创建实例</span><br><span class="line">    Duration durationOfMinutes &#x3D; Duration.ofMinutes(3);</span><br><span class="line">    Duration durationOf &#x3D; Duration.of(3, ChronoUnit.MINUTES);</span><br><span class="line">    Period periodOfDays &#x3D; Period.ofDays(10);</span><br><span class="line">    Period periodOfWeeks &#x3D; Period.ofWeeks(3);</span><br><span class="line">    Period periodOf &#x3D; Period.of(2, 6, 1);</span><br><span class="line">    System.out.println(durationOfMinutes); &#x2F;&#x2F; PT3M</span><br><span class="line">    System.out.println(durationOf); &#x2F;&#x2F; PT3M</span><br><span class="line">    System.out.println(periodOfDays); &#x2F;&#x2F; P10D</span><br><span class="line">    System.out.println(periodOfWeeks); &#x2F;&#x2F; P21D</span><br><span class="line">    System.out.println(periodOf); &#x2F;&#x2F; P2Y6M1D</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="操作、解析和格式化日期"><a href="#操作、解析和格式化日期" class="headerlink" title="操作、解析和格式化日期"></a>操作、解析和格式化日期</h4><p><code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>以及<code>Instant</code>这样表示时间点的日期-时间类提供了很多通用的方法用来操作日期-时间。所有的方法都返回一个修改了属性的对象。它们都不会修改原来的对象。</p><p>最直接也最简单的方法是使用”<code>withAttribute</code>“方法。”<code>withAttribute</code>“方法会创建对象的一个副本，并按照需要修改它的属性。</p><p>也可使用通用的<code>with</code>方法，它接受的第一个参数是一个<code>TemporalField</code>对象，第二个参数是需要修改的值。</p><p><code>with</code>方法还有一个重载的方法，它接收一个日期调整器<code>TemporalAdjuster</code>对象，更加灵活地处理日期。</p><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 操纵、解析和格式化日期</span><br><span class="line"> *</span><br><span class="line"> * LocalDate、LocalTime和LocalDateTime类都为final类，不可变，每次操作后都返回一个新的对应对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testUpdateTime() &#123;</span><br><span class="line">    LocalDate date1 &#x3D; LocalDate.of(2019, 8, 26);</span><br><span class="line">    LocalDate date2 &#x3D; date1.withYear(2020);</span><br><span class="line">    LocalDate date3 &#x3D; date2.withDayOfMonth(25);</span><br><span class="line">    LocalDate date4 &#x3D; date3.with(ChronoField.MONTH_OF_YEAR, 9);</span><br><span class="line">    System.out.println(date1); &#x2F;&#x2F; 2019-08-26</span><br><span class="line">    System.out.println(date2); &#x2F;&#x2F; 2020-08-26</span><br><span class="line">    System.out.println(date3); &#x2F;&#x2F; 2020-08-25</span><br><span class="line">    System.out.println(date4); &#x2F;&#x2F; 2020-09-25</span><br><span class="line"></span><br><span class="line">    LocalDate date5 &#x3D; LocalDate.of(2019,8,26);</span><br><span class="line">    LocalDate date6 &#x3D; date5.plusWeeks(1); &#x2F;&#x2F; 加一周</span><br><span class="line">    LocalDate date7 &#x3D; date6.minusYears(3); &#x2F;&#x2F; 减三年</span><br><span class="line">    LocalDate date8 &#x3D; date7.plus(6, ChronoUnit.MONTHS); &#x2F;&#x2F; 加六月</span><br><span class="line">    System.out.println(date5); &#x2F;&#x2F; 2019-08-26</span><br><span class="line">    System.out.println(date6); &#x2F;&#x2F; 2019-09-02</span><br><span class="line">    System.out.println(date7); &#x2F;&#x2F; 2016-09-02</span><br><span class="line">    System.out.println(date8); &#x2F;&#x2F; 2017-03-02</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="日期调整器：TemporalAdjuster"><a href="#日期调整器：TemporalAdjuster" class="headerlink" title="日期调整器：TemporalAdjuster"></a>日期调整器：TemporalAdjuster</h4><p><code>TemporalAdjuster</code>是一个函数式接口，接口方法签名如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Temporal adjustInto(Temporal temporal);</span><br></pre></td></tr></table></figure><p>接收一个<code>Temporal</code>对象，返回一个<code>Temporal</code>对象。由于所有的日期时间API都实现了<code>Temporal</code>接口，故它可以用来自定义更加复杂的日期时间操作。</p><p>Java 8提供了<code>TemporalAdjusters</code>类，该类通过静态方法提供了大量的常用<code>TemporalAdjuster</code>的实现。</p><p>同时还支持定制<code>TemporalAdjuster</code>，定制的方式有两种：</p><p>一：实现<code>TemporalAdjuster</code>接口；</p><p>二：使用Lambda表达式定制<code>TemporalAdjuster</code>对象，推荐使用<code>TemporalAdjusters</code>类的静态工厂方法<code>ofDateAdjuster</code>，该方法签名如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static TemporalAdjuster ofDateAdjuster(UnaryOperator&lt;LocalDate&gt; dateBasedAdjuster)</span><br></pre></td></tr></table></figure><p>接收一个<code>UnaryOperator</code>函数式接口，返回一个<code>TemporalAdjuster</code>对象。</p><p><code>UnaryOperator</code>函数式接口中方法签名如下，它总是返回它的输入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; UnaryOperator&lt;T&gt; identity() &#123;</span><br><span class="line">    return t -&gt; t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关代码示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 日期调整器</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testTemporalAdjuster() &#123;</span><br><span class="line">    LocalDate date1 &#x3D; LocalDate.of(2019,8,26);</span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster dayOfWeekInMonth(int ordinal, DayOfWeek dayOfWeek)</span><br><span class="line">    &#x2F;&#x2F; dayOfWeek表示星期几</span><br><span class="line">    &#x2F;&#x2F; 如果ordinal为0，则表示本日期所在的月的上一个月的最后一个星期几</span><br><span class="line">    &#x2F;&#x2F; 如果ordinal为正数，则以本日期所在的月从前向后数，第ordinal个星期几</span><br><span class="line">    &#x2F;&#x2F; 如果ordinal为负数，则以本日期所在的月从后往前数，第-ordinal个星期几</span><br><span class="line">    LocalDate date2 &#x3D; date1.with(TemporalAdjusters.dayOfWeekInMonth(1, DayOfWeek.FRIDAY));</span><br><span class="line">    System.out.println(&quot;date2&#x3D;&quot; + date2);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster firstDayOfMonth()：创建一个新的日期，它的值为当月的第一天</span><br><span class="line">    LocalDate date3 &#x3D; date1.with(TemporalAdjusters.firstDayOfMonth());</span><br><span class="line">    System.out.println(&quot;date3&#x3D;&quot; + date3);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster firstDayOfNextMonth()：创建一个新的日期，它的值为下月的第一天</span><br><span class="line">    LocalDate date4 &#x3D; date1.with(TemporalAdjusters.firstDayOfNextMonth());</span><br><span class="line">    System.out.println(&quot;date4&#x3D;&quot; + date4);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster firstDayOfNextYear()：创建一个新的日期，它的值为明年的第一天</span><br><span class="line">    LocalDate date5 &#x3D; date1.with(TemporalAdjusters.firstDayOfNextYear());</span><br><span class="line">    System.out.println(&quot;date5&#x3D;&quot; + date5);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster firstDayOfYear()：创建一个新的日期，它的值为今年的第一天</span><br><span class="line">    LocalDate date6 &#x3D; date1.with(TemporalAdjusters.firstDayOfYear());</span><br><span class="line">    System.out.println(&quot;date6&#x3D;&quot; + date6);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster firstInMonth(DayOfWeek dayOfWeek)：创建一个新的日期，它的值为同一个月中，第一个符合星期几要求的日期（这个月的第一个星期几）</span><br><span class="line">    LocalDate date7 &#x3D; date1.with(TemporalAdjusters.firstInMonth(DayOfWeek.FRIDAY));</span><br><span class="line">    System.out.println(&quot;date7&#x3D;&quot; + date7);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster lastDayOfMonth()：创建一个新的日期，它的值为这个月的最后一天</span><br><span class="line">    LocalDate date8 &#x3D; date1.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">    System.out.println(&quot;date8&#x3D;&quot; + date8);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster lastDayOfYear()：创建一个新的日期，它的值为今年的最后一天</span><br><span class="line">    LocalDate date9 &#x3D; date1.with(TemporalAdjusters.lastDayOfYear());</span><br><span class="line">    System.out.println(&quot;date9&#x3D;&quot; + date9);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster lastInMonth(DayOfWeek dayOfWeek)：创建一个新的日期，它的值为同一个月中，最后一个符合星期几要求的日期</span><br><span class="line">    LocalDate date10 &#x3D; date1.with(TemporalAdjusters.lastInMonth(DayOfWeek.FRIDAY));</span><br><span class="line">    System.out.println(&quot;date10&#x3D;&quot; + date10);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster next(DayOfWeek dayOfWeek)：创建一个新的日期，并将其值设定为指定日期之后第一个符合指定星期几的日期</span><br><span class="line">    LocalDate date11 &#x3D; date1.with(TemporalAdjusters.next(DayOfWeek.MONDAY));</span><br><span class="line">    System.out.println(&quot;date11&#x3D;&quot; + date11);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster nextOrSame(DayOfWeek dayOfWeek)：</span><br><span class="line">    &#x2F;&#x2F; 创建一个新的日期，并将其值设定为指定日期之后第一个符合指定星期几的日期；</span><br><span class="line">    &#x2F;&#x2F; 如果指定日期已符合要求，则直接返回该日期</span><br><span class="line">    LocalDate date12 &#x3D; date1.with(TemporalAdjusters.nextOrSame(DayOfWeek.MONDAY));</span><br><span class="line">    System.out.println(&quot;date12&#x3D;&quot; + date12);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster previous(DayOfWeek dayOfWeek)：创建一个新的日期，并将其值设定为指定日期之前第一个符合指定星期几的日期</span><br><span class="line">    LocalDate date13&#x3D; date1.with(TemporalAdjusters.previous(DayOfWeek.MONDAY));</span><br><span class="line">    System.out.println(&quot;date13&#x3D;&quot; + date13);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster previousOrSame(DayOfWeek dayOfWeek)：</span><br><span class="line">    &#x2F;&#x2F; 创建一个新的日期，并将其值设定为指定日期之前第一个符合指定星期几的日期；</span><br><span class="line">    &#x2F;&#x2F; 如果指定日期已符合要求，则直接返回该日期</span><br><span class="line">    LocalDate date14 &#x3D; date1.with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY));</span><br><span class="line">    System.out.println(&quot;date14&#x3D;&quot; + date14);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 使用Lambda表达式定制TemporalAdjuster对象，推荐使用TemporalAdjusters类的静态工厂方法ofDateAdjuster</span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster ofDateAdjuster(UnaryOperator&lt;LocalDate&gt; dateBasedAdjuster)</span><br><span class="line">    TemporalAdjuster nextWorkingDay &#x3D; TemporalAdjusters.ofDateAdjuster(temporal -&gt; &#123;</span><br><span class="line">        DayOfWeek dayOfWeek &#x3D; DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));</span><br><span class="line">        int dayToAdd &#x3D; 1;</span><br><span class="line">        if (dayOfWeek &#x3D;&#x3D; DayOfWeek.FRIDAY) dayToAdd &#x3D; 3;</span><br><span class="line">        else if (dayOfWeek &#x3D;&#x3D; DayOfWeek.SATURDAY) dayToAdd &#x3D; 2;</span><br><span class="line">        return temporal.plus(dayToAdd,ChronoUnit.DAYS);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 定制TemporalAdjuster</span><br><span class="line"> *</span><br><span class="line"> * 计算下一个工作日</span><br><span class="line"> *&#x2F;</span><br><span class="line">class NextWorkingDay implements TemporalAdjuster &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 周一到周五为工作日</span><br><span class="line">     * 如果是周日到周四，则返回下一天</span><br><span class="line">     * 如果是周五、周六、返回下周周一</span><br><span class="line">     * @param temporal</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Temporal adjustInto(Temporal temporal) &#123;</span><br><span class="line">        &#x2F;&#x2F; 得到今天星期几</span><br><span class="line">        DayOfWeek dayOfWeek &#x3D; DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));</span><br><span class="line">        int dayToAdd &#x3D; 1;</span><br><span class="line">        if (dayOfWeek &#x3D;&#x3D; DayOfWeek.FRIDAY) dayToAdd &#x3D; 3;</span><br><span class="line">        else if (dayOfWeek &#x3D;&#x3D; DayOfWeek.SATURDAY) dayToAdd &#x3D; 2;</span><br><span class="line">        return temporal.plus(dayToAdd,ChronoUnit.DAYS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TemporalAdjusters</code>类中包含的工厂方法列表：</p><table><thead><tr><th align="left">方法签名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>TemporalAdjuster dayOfWeekInMonth(int ordinal, DayOfWeek dayOfWeek)</code></td><td align="left">dayOfWeek表示星期几<br />如果ordinal为0，则表示本日期所在的月的上一个月的最后一个星期几<br />如果ordinal为正数，则以本日期所在的月从前向后数，第ordinal个星期几<br /> 如果ordinal为负数，则以本日期所在的月从后往前数，第-ordinal个星期几</td></tr><tr><td align="left"><code>TemporalAdjuster firstDayOfMonth()</code></td><td align="left">创建一个新的日期，它的值为当月的第一天</td></tr><tr><td align="left"><code>TemporalAdjuster firstDayOfNextMonth()</code></td><td align="left">创建一个新的日期，它的值为下月的第一天</td></tr><tr><td align="left"><code>TemporalAdjuster firstDayOfNextYear()</code></td><td align="left">创建一个新的日期，它的值为明年的第一天</td></tr><tr><td align="left"><code>TemporalAdjuster firstDayOfYear()</code></td><td align="left">创建一个新的日期，它的值为今年的第一天</td></tr><tr><td align="left"><code>TemporalAdjuster firstInMonth(DayOfWeek dayOfWeek)</code></td><td align="left">创建一个新的日期，它的值为同一个月中，第一个符合星期几要求的日期（这个月的第一个星期几）</td></tr><tr><td align="left"><code>TemporalAdjuster lastDayOfMonth()</code></td><td align="left">创建一个新的日期，它的值为这个月的最后一天</td></tr><tr><td align="left"><code>TemporalAdjuster lastDayOfYear()</code></td><td align="left">创建一个新的日期，它的值为今年的最后一天</td></tr><tr><td align="left"><code>TemporalAdjuster lastInMonth(DayOfWeek dayOfWeek)</code></td><td align="left">创建一个新的日期，它的值为同一个月中，最后一个符合星期几要求的日期</td></tr><tr><td align="left"><code>TemporalAdjuster next(DayOfWeek dayOfWeek)</code></td><td align="left">创建一个新的日期，并将其值设定为指定日期之后第一个符合指定星期几的日期</td></tr><tr><td align="left"><code>TemporalAdjuster nextOrSame(DayOfWeek dayOfWeek)</code></td><td align="left">创建一个新的日期，并将其值设定为指定日期之后第一个符合指定星期几的日期；如果指定日期已符合要求，则直接返回该日期</td></tr><tr><td align="left"><code>TemporalAdjuster previous(DayOfWeek dayOfWeek)</code></td><td align="left">创建一个新的日期，并将其值设定为指定日期之前第一个符合指定星期几的日期</td></tr><tr><td align="left"><code>TemporalAdjuster previousOrSame(DayOfWeek dayOfWeek)</code></td><td align="left">创建一个新的日期，并将其值设定为指定日期之前第一个符合指定星期几的日期；如果指定日期已符合要求，则直接返回该日期</td></tr></tbody></table><h4 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h4><p>时区的处理是新版日期和时间API新增加的重要功能，使用新版日期和时间API时区的处理被极大地简化了。新的<code>java.time.ZoneId</code>类是老版<code>java.util.TimeZone</code>的替代品。它的设计目标就是要让你无需为时区处理的复杂和繁琐而操心，跟其他日期和时间类一 样，<code>ZoneId</code>类也是被<code>final</code>修饰而无法修改的。</p><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 带时区的日期时间API</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testZoneLocalDateTime() &#123;</span><br><span class="line">    &#x2F;&#x2F; 查看所有支持的时区</span><br><span class="line">    Set&lt;String&gt; availableZoneIds &#x3D; ZoneId.getAvailableZoneIds();</span><br><span class="line">    for (String s: availableZoneIds) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 通过时区构建LocalDateTime对象</span><br><span class="line">    LocalDateTime localDateTimeNow &#x3D; LocalDateTime.now(ZoneId.of(&quot;Asia&#x2F;Shanghai&quot;));</span><br><span class="line">    &#x2F;&#x2F; 指定时区构建带时区的日期时间对象</span><br><span class="line">    ZonedDateTime zonedDateTime &#x3D; localDateTimeNow.atZone(ZoneId.of(&quot;Asia&#x2F;Shanghai&quot;));</span><br><span class="line">    System.out.println(localDateTimeNow); &#x2F;&#x2F; 2019-09-03T10:35:25.677</span><br><span class="line">    &#x2F;&#x2F; 2019-09-03T10:35:25.677+08:00[Asia&#x2F;Shanghai] 与UTC时间相差8小时</span><br><span class="line">    System.out.println(zonedDateTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="日期时间API的部分UML图"><a href="#日期时间API的部分UML图" class="headerlink" title="日期时间API的部分UML图"></a>日期时间API的部分UML图</h4><p>以上介绍的新的日期时间API相关类的UML图如下：</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/G5oUqew63xHfkup.png"  alt="12-newDateTimeUML.png"></p><p>下面这张图能帮助我们更好的理解LocaleDate、 LocalTime、LocalDateTime以及ZoneId之间的差异。</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/FbwNkXIJVrfBy2z.png"  alt="12-ZonedDateTime组成.png"></p>]]></content>
    
    <summary type="html">
    
      第三部分：高效Java 8编程（四）：新的线程安全的日期时间API
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://lilu.org.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java 8实战" scheme="https://lilu.org.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java-8%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Java8" scheme="https://lilu.org.cn/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（三）：从一个生产环境的事故到异步编程思想</title>
    <link href="https://lilu.org.cn/2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(3)/"/>
    <id>https://lilu.org.cn/2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(3)/</id>
    <published>2019-12-12T13:38:35.285Z</published>
    <updated>2019-12-12T13:04:44.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第十一章：CompletableFuture组合式异步编程"><a href="#第十一章：CompletableFuture组合式异步编程" class="headerlink" title="第十一章：CompletableFuture组合式异步编程"></a>第十一章：CompletableFuture组合式异步编程</h2><p>在介绍这部分内容之前，先介绍一下由于我和另外一位开发人员的考虑不周造成的一次线上事故场景（考虑企业隐私，屏蔽了一些关键词）。</p><h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><p>卡劵系统的后台管理系统，用于处理用户投诉补偿以及发错券补偿的场景。</p><h3 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h3><p>两种情况会使用到这次我们开发的功能。</p><ol><li>可能会出现用户投诉未领取到优惠券的情况，这个时候直接给用户补发一张。避免浪费人力去查线上日志找原因。</li><li>运营人员操作失误发错劵，需要手动给用户补发劵。</li></ol><p>由于功能急需上线，产品经理想尽量简化开发，设计的轻量化一些，不将补发记录入库。每次补发完成页面就显示成功多少个，失败多少个，失败的UIDs是哪些。</p><h3 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h3><ol><li>一个补发劵页面，运营人员首先输入劵ID查询劵信息，包含劵名称和可用库存。</li><li>上传需要进行补发的UIDs到后台进行解析（解析的过程就是去数据库中查是否存在该UID对应的用户）。</li><li>给有效的UIDs对应的用户进行劵补发操作，调用发劵接口。</li><li>等待所有用户全部调用发劵接口完毕，记录失败的UIDs，响应给前端。</li></ol><h3 id="事故分析"><a href="#事故分析" class="headerlink" title="事故分析"></a>事故分析</h3><ul><li><p>事故描述：运营人员上传了250个用户UID进行补发劵，点击补发按钮，等待了约2分钟页面显示失败了215个UID。</p></li><li><p>排查情况：线上环境将应用部署到了2台服务器。我们在A和B两台服务器的日志上都查到了补发请求相关日志。服务器A上的日志显示补发失败35条，服务器B上的日志显示补发失败215条。</p></li><li><p>原因分析：</p><ul><li>A服务器上的日志显示控制器层接收到请求的时刻是：<code>2019-09-06 10:51:19.075</code>，响应请求的时刻是：<code>2019-09-06 10:52:40.171</code>；</li><li>B服务器上的日志显示控制器层接收到请求的时刻是：<code>2019-09-06 10:52:19.061</code>，响应请求的时刻是：<code>2019-09-06 10:52:40.022</code>。</li><li>A服务器上记录的失败的35个UIDs在B服务器上发劵成功；B服务器上记录的失败的215个UIDs在A服务器上发劵成功。另外从日志中可看出发劵接口做了幂等校验。</li></ul></li></ul><p>初步排查：由于后端服务器接收到了两个请求，判断是否运营人员点了两次补发按钮？经过对前端页面的测试，点了一次补发按钮后，页面出现loading遮罩层，不能第二次点击补发按钮。排除运营人员操作的问题。</p><p>进一步分析：A和B两台服务器接收到请求的时间间隔恰好是1分钟左右，是否是前端Ajax请求的响应超时会自动重试？由于前端页面是使用jQuery发送Ajax请求，并且请求类型是POST，浏览器并不会自动重试。</p><p>最终得出结论：在向指导人请教后，推测是线上环境有Nginx进行负载均衡，当ajax请求得到响应的时间超过Nginx默认的60秒时，请求会自动重发到另一台服务器。向部门经理确认系统架构后，线上环境确实存在负载均衡，使用的是阿里的SLB。（由于我们刚接手该项目，对线上环境还不太熟悉）阿里的SLB开启了超时自动重发机制，超时时间是60秒。</p><h3 id="事故结论"><a href="#事故结论" class="headerlink" title="事故结论"></a>事故结论</h3><p>一个补发劵的请求经过SLB负载均衡到后端服务器，后端服务器执行业务代码时间超过了一分钟，过了60秒后，SLB认为该请求超时，触发重试机制，将同样的请求负载到另外一台后端服务器上，两台服务器上的线程开始并发调用发劵接口，由于发劵接口做了接口幂等性校验，所以并未出现发劵重复的情况。最终250个UIDs都成功的完成了补发。</p><ul><li>解决方案：<ul><li>运营人员每次上传少量UIDs，保证响应时间小于60秒。</li><li>产品经理提出迭代需求，版本升级。</li></ul></li></ul><h3 id="值得思考的问题"><a href="#值得思考的问题" class="headerlink" title="值得思考的问题"></a>值得思考的问题</h3><p>产品经理提出需求时，说要简化开发，设计轻量化等。但我们作为Java开发工程师，我们不能和产品经理想的一样，将系统想的过于简化。仍然要从一个程序的角度出发来考虑问题。</p><h3 id="代码升级方案"><a href="#代码升级方案" class="headerlink" title="代码升级方案"></a>代码升级方案</h3><p>我们知道，在原生安卓项目开发中，所有的网络请求都必须在子线程中执行。</p><p>安卓为什么要这样限制呢？我想，安卓一定是考虑到所有的网络请求都是有可能出现超时的，即使网络请求只是去简单的获取一个资源，但仍可能会出现网络延迟的情况。如果在主线程中执行，一旦出现延迟或者超时，给用户的感觉就是界面卡住。于是安卓进行了异步化设计。限制网络请求只能在子线程中执行。</p><p>对于Web应用系统，如果有执行时间较长的请求，我们也要尽量将其放在子线程中执行。避免因为等待远程服务的返回，或者对数据库的查询，而阻塞主线程的执行，浪费宝贵的计算资源，影响用户体验。</p><p>这次线上事故的根本原因就是开发经验不足，考虑不周，不了解线上情况，未进行异步化设计。由于一次请求需要补发较多的用户，导致一次HTTP请求迟迟未完成三次握手四次挥手过程，SLB服务器认为请求超时，触发了重试机制，将同样的请求打到另外一台服务器上。</p><p>在Java语言中，<code>Future</code>接口，尤其是它在Java 8中的新版实现<code>CompletableFuture</code>，是进行异步化设计的利器。</p><h3 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h3><p><code>Future</code>接口在Java 5中被引入，设计初衷是对将来某个时刻会发生的结果进行建模。它建模了一种异步计算，返回一个执行运算结果的引用，当运算结束后，这个引用被返回给调用方。在<code>Future</code>中触发那些潜在耗时的操作把调用线程解放出来，让它能及时响应客户端或者继续执行其它有价值的工作，不再需要呆呆的等到耗时的操作完成。</p><p>上述补发劵业务最初的同步代码大致如下（考虑企业隐私，屏蔽关键词）：</p><p>业务Service层代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 同步 劵补发操作</span><br><span class="line"> * @param uIds 用户UID集合</span><br><span class="line"> * @param couponId 优惠券ID</span><br><span class="line"> * @return 失败的用户UID集合</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public List&lt;String&gt; syncReSupplyCoupon(List&lt;String&gt; uIds, String couponId) &#123;</span><br><span class="line">    List&lt;String&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;UserInfoModel&gt; userInfoModelList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; 循环验证UID有效性</span><br><span class="line">    for (String uId : uIds) &#123;</span><br><span class="line">        &#x2F;&#x2F; 查询UID对应用户信息</span><br><span class="line">        UserInfoModel userInfoModel &#x3D; reSupplyCouponService.queryUserInfo(uId);</span><br><span class="line">        if (userInfoModel !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; UID存在，放入待进行补发用户集合</span><br><span class="line">            userInfoModelList.add(userInfoModel);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; UID不存在，放入返回结果集合</span><br><span class="line">            result.add(uId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 循环进行劵补发</span><br><span class="line">    for (UserInfoModel userInfoModel : userInfoModelList) &#123;</span><br><span class="line">        Boolean flag &#x3D; false;</span><br><span class="line">        try &#123;</span><br><span class="line">            flag &#x3D; reSupplyCouponService.reSupplyCoupon(couponId,userInfoModel.getUid());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            &#x2F;&#x2F; 异常处理</span><br><span class="line">        &#125;</span><br><span class="line">        if (!flag) &#123;</span><br><span class="line">            &#x2F;&#x2F; 补发劵失败，放入返回结果集合</span><br><span class="line">            result.add(userInfoModel.getUid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基础Service层代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 查询用户信息</span><br><span class="line"> * @param uId 用户UID</span><br><span class="line"> * @return 用户信息model</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public UserInfoModel queryUserInfo(String uId) &#123;</span><br><span class="line">    return reSupplyCouponIntegration.queryUserInfo(uId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 补发劵操作</span><br><span class="line"> * @param couponId 优惠券ID</span><br><span class="line"> * @param uId 用户ID</span><br><span class="line"> * @return 补发结果：成功或失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public Boolean reSupplyCoupon(String couponId, String uId) &#123;</span><br><span class="line">    return reSupplyCouponIntegration.reSupplyCoupon(couponId,uId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Integration</code>防腐层代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private static List&lt;UserInfoModel&gt; users &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 初始化操作，模拟远程用户数据</span><br><span class="line"> *&#x2F;</span><br><span class="line">static &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 250; i++) &#123;</span><br><span class="line">        users.add(new UserInfoModel(String.valueOf(i)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 模拟查找用户操作，不存在则UID则新增一个。</span><br><span class="line"> * @param uId 用户UID</span><br><span class="line"> * @return 用户信息model</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public UserInfoModel queryUserInfo(String uId) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 模拟调用远程服务耗时</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return users.get(Integer.valueOf(uId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 模拟补发劵操作</span><br><span class="line"> * @param couponId 优惠券ID</span><br><span class="line"> * @param uId 用户id</span><br><span class="line"> * @return 补发劵结果：成功或失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public Boolean reSupplyCoupon(String couponId, String uId) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 模拟调用远程服务耗时</span><br><span class="line">        Thread.sleep(200);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 模拟成功或失败概率</span><br><span class="line">    return new Random().nextInt(100) &lt; 90;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段同步执行的代码中存在的问题：包含2个for循环中通过RPC调用远程服务提供方进行数据库操作，如果UID集合数据量较大，这个方法的执行时间是非常长的，例如这次事故中运营人员上传了250个UID，执行时间就花了2分钟左右。耗时过长，SLB负载均衡服务器认为请求超时，进行重试。</p><p>使用Future接口进行代码异步化改造：将耗时的操作封装到一个<code>Callable</code>对象中，再将它提交给ExecutorService线程池。</p><p>业务Service层代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 初始化线程池</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 声明Future</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static Future&lt;List&lt;String&gt;&gt; future;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 使用Callable封装耗时操作</span><br><span class="line"> *&#x2F;</span><br><span class="line">class AsyncReSupplyCouponCallable implements Callable&lt;List&lt;String&gt;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 通过构造函数间接传递参数给call方法</span><br><span class="line">    private List&lt;String&gt; uIds;</span><br><span class="line">    private String couponId;</span><br><span class="line">    public AsyncReSupplyCouponCallable(List&lt;String&gt; uIds, String couponId) &#123;</span><br><span class="line">        this.uIds &#x3D; uIds;</span><br><span class="line">        this.couponId &#x3D; couponId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;String&gt; call() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 调用同步的补发劵方法</span><br><span class="line">        return syncReSupplyCoupon(uIds,couponId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 异步 劵补发操作 基于JDK 5的Future接口</span><br><span class="line"> * @param uIds 用户UID集合</span><br><span class="line"> * @param couponId 优惠券ID</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public void asyncFutureReSupplyCoupon(List&lt;String&gt; uIds, String couponId) &#123;</span><br><span class="line">    future &#x3D; executorService.submit(new AsyncReSupplyCouponCallable(uIds,couponId));</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 获取补发劵失败的UIDs在前端显示</span><br><span class="line"> * 由前端控制调用该方法的时机</span><br><span class="line"> * 根据上传的UIDs数量做轮询，时间可以设置久一点。</span><br><span class="line"> * @return 补发失败的UID集合</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public List&lt;String&gt; getFailedUIDs() &#123;</span><br><span class="line">    List&lt;String&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (future !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果调用get方法时，Callable中的任务还未执行完，则线程阻塞在这里。</span><br><span class="line">            &#x2F;&#x2F; 使用重载的get方法设置超时时间为50秒。如果发生阻塞，则最多等待50秒后退出。</span><br><span class="line">            result &#x3D; future.get(50, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        &#x2F;&#x2F; 线程等待过程中被中断</span><br><span class="line">    &#125; catch (ExecutionException e) &#123;</span><br><span class="line">        &#x2F;&#x2F; 计算抛出一个异常</span><br><span class="line">    &#125; catch (TimeoutException e) &#123;</span><br><span class="line">        &#x2F;&#x2F; 在Future对象完成之前超时已过期</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步化改造基本已经完成。以上代码已经能够有效避免这次线上事故再次发生了。</p><h3 id="接口性能提升"><a href="#接口性能提升" class="headerlink" title="接口性能提升"></a>接口性能提升</h3><p>基于<code>Future</code>接口的异步改造已经能够避免事故再次发生，但是耗时的补发劵操作在子线程执行仍然是同步的。子线程中验证同步执行验证250个UIDs是否合法，给250个用户补发劵。耗时仍然很长。如何提升接口的性能呢？如果让不同的UID之间的操作并行，则可显著提升性能。</p><h3 id="方案一：使用Java-8的并行流"><a href="#方案一：使用Java-8的并行流" class="headerlink" title="方案一：使用Java 8的并行流"></a>方案一：使用Java 8的并行流</h3><p>利用Java 8的并行流避免每个UID的顺序执行。</p><p>业务Service层代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 使用并行流 补发劵</span><br><span class="line"> * @param uIds 用户UID集合</span><br><span class="line"> * @param couponId 优惠券ID</span><br><span class="line"> * @return 补发失败的用户UIDs集合</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public List&lt;String&gt; parallelReSupplyCoupon(List&lt;String&gt; uIds, String couponId) &#123;</span><br><span class="line">    List&lt;String&gt; failUidList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; 使用并行流验证UID是否合法，按是否合法进行分区：不存在的为true区</span><br><span class="line">    Map&lt;Boolean, List&lt;UserInfoModel&gt;&gt; userInfoModelMap &#x3D; uIds.parallelStream()</span><br><span class="line">            .map(uId -&gt; reSupplyCouponService.queryUserInfo(uId))</span><br><span class="line">            .collect(Collectors.partitioningBy(Objects::isNull));</span><br><span class="line">    &#x2F;&#x2F; 取出不合法的UID加入补发失败的集合中</span><br><span class="line">    userInfoModelMap.get(true)</span><br><span class="line">            .parallelStream()</span><br><span class="line">            .map(userInfoModel -&gt; failUidList.add(userInfoModel.getUid()))</span><br><span class="line">            .collect(Collectors.toList()); &#x2F;&#x2F; 触发中间操作</span><br><span class="line">    &#x2F;&#x2F; 取出合法的UID进行补发劵操作</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; reSupplyCouponResult &#x3D; userInfoModelMap.get(false)</span><br><span class="line">            .parallelStream()</span><br><span class="line">            .map(userInfoModel -&gt; reSupplyCouponService.reSupplyCouponWithUid(couponId, userInfoModel.getUid()))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    &#x2F;&#x2F; 从补发劵结果中取出补发失败的加入补发失败的集合中</span><br><span class="line">    reSupplyCouponResult.parallelStream()</span><br><span class="line">            .filter(map -&gt; !(Boolean) map.get(&quot;result&quot;))</span><br><span class="line">            .map(map -&gt; failUidList.add(String.valueOf(map.get(&quot;uId&quot;))))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    return failUidList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基础Service层中新增接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 补发劵操作</span><br><span class="line"> * @param couponId 优惠券ID</span><br><span class="line"> * @param uId 用户ID</span><br><span class="line"> * @return [UID,&quot;成功或失败&quot;]，返回对应UID。</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public Map&lt;String, Object&gt; reSupplyCouponWithUid(String couponId, String uId) &#123;</span><br><span class="line">    Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    map.put(&quot;uId&quot;,uId);</span><br><span class="line">    Boolean result &#x3D; reSupplyCouponIntegration.reSupplyCoupon(couponId,uId);</span><br><span class="line">    map.put(&quot;result&quot;,result);</span><br><span class="line">    return map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案二：使用Java-8的CompletableFuture接口"><a href="#方案二：使用Java-8的CompletableFuture接口" class="headerlink" title="方案二：使用Java 8的CompletableFuture接口"></a>方案二：使用Java 8的CompletableFuture接口</h3><p>利用Java 8的<code>CompletableFuture</code>接口异步化。每一个UID的操作之间都是异步的。</p><p>需要对所有的<code>CompletableFuture</code>对象执行<code>join</code>操作，一个一个等待它们执行完毕。<code>CompletableFuture</code>类中的<code>join</code>方法和<code>Future</code>接口中的<code>get</code>方法有相同的含义，并且也声明在<code>Future</code>接口中，唯一的不同是<code>join</code>方法不会抛出任何检测到的异常。所以不会显得Lambda表达式过于臃肿。</p><p>业务Service层代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 异步 劵补发操作 每一个UID之间都是异步的 基于JDK 8的CompletableFuture接口</span><br><span class="line"> * @param uIds</span><br><span class="line"> * @param couponId</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public List&lt;String&gt; asyncCompletableFutureReSupplyCoupon(List&lt;String&gt; uIds, String couponId) &#123; </span><br><span class="line">    List&lt;String&gt; failUidList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; 使用CompletableFuture异步操作：验证UID是否存在系统中</span><br><span class="line">    List&lt;CompletableFuture&lt;UserInfoModel&gt;&gt; list &#x3D; uIds.stream()</span><br><span class="line">            .map(uId -&gt; CompletableFuture.supplyAsync(</span><br><span class="line">                    () -&gt; reSupplyCouponService.queryUserInfo(uId))</span><br><span class="line">            ).collect(Collectors.toList());</span><br><span class="line">    &#x2F;&#x2F; 等待所有异步操作执行结束，分区筛选出存在的UIDs和不存在的UIDs</span><br><span class="line">    Map&lt;Boolean, List&lt;UserInfoModel&gt;&gt; joinMap &#x3D; list.stream()</span><br><span class="line">            .map(CompletableFuture::join)</span><br><span class="line">            .collect(Collectors.partitioningBy(Objects::isNull));</span><br><span class="line">    &#x2F;&#x2F; 将不存在的UIDs加入补发失败的集合中</span><br><span class="line">    joinMap.get(true)</span><br><span class="line">            .stream()</span><br><span class="line">            .map(userInfoModel -&gt; failUidList.add(userInfoModel.getUid()))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    &#x2F;&#x2F; 使用CompletableFuture异步给存在的UIDs补发劵</span><br><span class="line">    List&lt;CompletableFuture&lt;Map&lt;String, Object&gt;&gt;&gt; reSupplyCouponResult &#x3D; joinMap.get(false)</span><br><span class="line">            .stream()</span><br><span class="line">            .map(userInfoModel -&gt; CompletableFuture.supplyAsync(</span><br><span class="line">                    () -&gt; reSupplyCouponService.reSupplyCouponWithUid(couponId, userInfoModel.getUid()))</span><br><span class="line">            ).collect(Collectors.toList());</span><br><span class="line">    &#x2F;&#x2F; 等待所有异步操作执行结束，筛选出补发劵失败的UIDs存入返回结果集合中</span><br><span class="line">    reSupplyCouponResult.stream()</span><br><span class="line">            .map(CompletableFuture::join)</span><br><span class="line">            .filter(r -&gt; !(Boolean) r.get(&quot;result&quot;))</span><br><span class="line">            .map(r -&gt; failUidList.add(String.valueOf(r.get(&quot;uId&quot;))))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    return failUidList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比较并行流和异步接口的快慢"><a href="#比较并行流和异步接口的快慢" class="headerlink" title="比较并行流和异步接口的快慢"></a>比较并行流和异步接口的快慢</h3><p>初始化8个UID进行测试。</p><p>测试代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private static List&lt;String&gt; uIds &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 初始化8个UIDs，模拟待补发用户</span><br><span class="line"> *&#x2F;</span><br><span class="line">static &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 8; i++) &#123;</span><br><span class="line">        uIds.add(String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 测试使用Java 8的并行流进行的补发劵操作</span><br><span class="line"> *</span><br><span class="line"> * 8个UID</span><br><span class="line"> * done in 312msecs</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testParallelReSupplyCoupon() &#123;</span><br><span class="line">    long start &#x3D; System.nanoTime();</span><br><span class="line">    List&lt;String&gt; failedUIDs &#x3D; reSupplyCouponBizService.parallelReSupplyCoupon(uIds, &quot;1&quot;);</span><br><span class="line">    long duration &#x3D; (System.nanoTime() - start) &#x2F; 1_000_000;</span><br><span class="line">    System.out.println(&quot;done in &quot; + duration + &quot;msecs&quot;);</span><br><span class="line">    failedUIDs.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 测试 异步 劵补发操作 每一个UID之间都是异步的 基于JDK 8的CompletableFuture接口</span><br><span class="line"> *</span><br><span class="line"> * 8个UID</span><br><span class="line"> * done in 610msecs</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testAsyncCompletableFutureReSupplyCoupon() &#123;</span><br><span class="line">    long start &#x3D; System.nanoTime();</span><br><span class="line">    List&lt;String&gt; failedUIDs &#x3D; reSupplyCouponBizService.asyncCompletableFutureReSupplyCoupon(uIds, &quot;1&quot;);</span><br><span class="line">    long duration &#x3D; (System.nanoTime() - start) &#x2F; 1_000_000;</span><br><span class="line">    System.out.println(&quot;done in &quot; + duration + &quot;msecs&quot;);</span><br><span class="line">    failedUIDs.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果让人相当失望。使用<code>CompletableFuture</code>新接口的耗时大约是使用并行流版本的两倍。难道这种场景下使用<code>CompletableFuture</code>真的是浪费时间吗？也许我们漏掉了某些很重要的东西？我们运行测试代码的电脑是否足以以并行方式运行8个线程？</p><p>并行流的版本运行的足够快，那是因为它能并行的执行的8个线程，它能为每个UID的操作分配一个线程。但是，如果现在我们初始化9个UID进行测试，我们来看看结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">并行流版本</span><br><span class="line">9个UID</span><br><span class="line">done in 617msecs</span><br><span class="line"></span><br><span class="line">异步接口版本</span><br><span class="line">9个UID</span><br><span class="line">done in 611msecs</span><br></pre></td></tr></table></figure><p>并行流版本9个UID的测试结果比之前大概多消耗了3秒，这个时间间隔刚好是一次模拟调用远程服务接口的耗时。因为可以并行运行的8个线程开始都处于工作状态，都在对前8个UID进行补发劵等操作。第9个UID的操作只能等到前面某个操作完成释放出空闲线程才能继续。</p><p>异步接口版本的测试结果和并行流版本相差无几。究其原因都一样：它们内部采用的是同样的通用线程池，默认都使用固定数量的线程，具体线程数取决于<code>Runtime.getRuntime().availableProcessors()</code>的返回值。然而，<code>CompletableFuture</code>具有一定优势，它可以定制执行器，自定义线程池的大小。这是并行流API无法实现的。</p><h3 id="定制异步接口的执行器"><a href="#定制异步接口的执行器" class="headerlink" title="定制异步接口的执行器"></a>定制异步接口的执行器</h3><p>创建一个配有线程池的执行器很容易，但是我们该如何选择合适的线程数目呢？</p><blockquote><p>《Java并发编程实战》书中介绍到，Brian Goetz和合著者们为线程池大小的优化提供了不少中肯的建议。这非常重要，如果线程池中线程的数量过多，最终它们会竞争稀缺的处理器和内存资源，浪费大量的时间在上下文切换上。反之，如果线程的数目过少，正如你的应用所面临的情况，处理器的一些核可能就无法充分利用。Brian Goetz建议，线程池大小与处理器的利用率之比可以使用下面的公式进行估算：<br><strong>N</strong><sub>threads</sub> = <strong>N</strong><sub>CPU</sub> * <strong>U</strong><sub>CPU</sub> * (1 + <strong>W</strong>/<strong>C</strong>)<br>其中：</p><ul><li><strong>N</strong><sub>threads</sub>是处理器的核的数目，可以通过<code>Runtime.getRuntime().availableProcessors()</code>得到；</li><li><strong>U</strong><sub>CPU</sub>是期望的CPU利用率（该值应该介于0和1之间）</li><li><strong>W</strong>/<strong>C</strong>是等待时间与计算时间的比率</li></ul></blockquote><p>补发劵接口99%的时间都在等待远程服务的响应，所以估算出的W/C的比率为100。如果期望的CPU利用率为100%，则需要创建一个拥有800个线程的线程池。但实际上，线程池中的有些线程根本没机会被使用，反而是一种浪费。所以建议将执行器使用的线程数，与实际需要的线程数（UIDs的数量）设定为同样的值。这样每个UID都对应一个服务线程。但是，当UIDs数量过大时，运行代码的机器必然会因超负荷而崩溃，所以最好还是有一个上限。</p><p>业务Service层相关代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 定制执行器-线程池大小为UIDs的数量：设置为守护线程，当程序退出时，线程也会被回收。</span><br><span class="line"> *&#x2F;</span><br><span class="line">private final Executor executor &#x3D; Executors.newFixedThreadPool(125, r -&gt; &#123;</span><br><span class="line">    Thread t &#x3D; new Thread(r);</span><br><span class="line">    t.setDaemon(true);</span><br><span class="line">    return t;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 异步 劵补发操作 定制CompletableFuture接口的执行器</span><br><span class="line"> * @param uIds 用户UID集合</span><br><span class="line"> * @param couponId 优惠券ID</span><br><span class="line"> * @return 补发失败的用户UID集合</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public List&lt;String&gt; asyncCompletableFutureCustomExecutorReSupplyCoupon(List&lt;String&gt; uIds, String couponId) &#123;</span><br><span class="line">    List&lt;String&gt; failUidList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; 使用定制执行器的CompletableFuture异步操作：验证UID是否存在系统中</span><br><span class="line">    List&lt;CompletableFuture&lt;UserInfoModel&gt;&gt; list &#x3D; uIds.stream()</span><br><span class="line">            .map(uId -&gt; CompletableFuture.supplyAsync(</span><br><span class="line">                    () -&gt; reSupplyCouponService.queryUserInfo(uId),executor)</span><br><span class="line">            ).collect(Collectors.toList());</span><br><span class="line">    &#x2F;&#x2F; 等待所有异步操作执行结束，分区筛选出存在的UIDs和不存在的UIDs</span><br><span class="line">    Map&lt;Boolean, List&lt;UserInfoModel&gt;&gt; joinMap &#x3D; list.stream()</span><br><span class="line">            .map(CompletableFuture::join)</span><br><span class="line">            .collect(Collectors.partitioningBy(Objects::isNull));</span><br><span class="line">    &#x2F;&#x2F; 将不存在的UIDs加入补发失败的集合中</span><br><span class="line">    joinMap.get(true)</span><br><span class="line">            .stream()</span><br><span class="line">            .map(userInfoModel -&gt; failUidList.add(userInfoModel.getUid()))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    &#x2F;&#x2F; 使用定制执行器的CompletableFuture异步给存在的UIDs补发劵</span><br><span class="line">    List&lt;CompletableFuture&lt;Map&lt;String, Object&gt;&gt;&gt; reSupplyCouponResult &#x3D; joinMap.get(false)</span><br><span class="line">            .stream()</span><br><span class="line">            .map(userInfoModel -&gt; CompletableFuture.supplyAsync(</span><br><span class="line">                    () -&gt; reSupplyCouponService.reSupplyCouponWithUid(couponId, userInfoModel.getUid()),executor)</span><br><span class="line">            ).collect(Collectors.toList());</span><br><span class="line">    &#x2F;&#x2F; 等待所有异步操作执行结束，筛选出补发劵失败的UIDs存入返回结果集合中</span><br><span class="line">    reSupplyCouponResult.stream()</span><br><span class="line">            .map(CompletableFuture::join)</span><br><span class="line">            .filter(r -&gt; !(Boolean) r.get(&quot;result&quot;))</span><br><span class="line">            .map(r -&gt; failUidList.add(String.valueOf(r.get(&quot;uId&quot;))))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    return failUidList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用125个UID进行测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private static List&lt;String&gt; uIds &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 初始化操作，模拟待补发用户</span><br><span class="line"> *&#x2F;</span><br><span class="line">static &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 125; i++) &#123;</span><br><span class="line">        uIds.add(String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 测试 异步 劵补发操作 定制CompletableFuture接口的执行器</span><br><span class="line"> *</span><br><span class="line"> * 125个UID</span><br><span class="line"> * done in 369msecs</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testAsyncCompletableFutureCustomExecutorReSupplyCoupon() &#123;</span><br><span class="line">    long start &#x3D; System.nanoTime();</span><br><span class="line">    List&lt;String&gt; failedUIDs &#x3D; reSupplyCouponBizService.asyncCompletableFutureCustomExecutorReSupplyCoupon(uIds, &quot;1&quot;);</span><br><span class="line">    long duration &#x3D; (System.nanoTime() - start) &#x2F; 1_000_000;</span><br><span class="line">    System.out.println(&quot;done in &quot; + duration + &quot;msecs&quot;);</span><br><span class="line">    failedUIDs.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：<code>done in 369msecs</code>，显而易见，耗时和8个UID的并行流版本很接近。性能显著提升。一般而言，随着UID数量继续增多，耗时不会相差太多，直到达到之前计算的阈值800（CPU利用率达到100%）。</p><h3 id="在并行流和CompletableFuture之间进行选择"><a href="#在并行流和CompletableFuture之间进行选择" class="headerlink" title="在并行流和CompletableFuture之间进行选择"></a>在并行流和CompletableFuture之间进行选择</h3><p>并行流底层的Fork/Join框架使用通用的线程池，无法个性化定制。新的<code>CompletableFuture</code>接口可以定制执行器，调整线程池大小，能够更加充分的利用CPU资源。</p><p>建议如下：</p><blockquote><ul><li>如果你进行的是计算密集型的操作，并且没有I/O，那么推荐使用Stream接口，因为实<br>现简单，同时效率也可能是最高的（如果所有的线程都是计算密集型的，那就没有必要<br>创建比处理器核数更多的线程）。</li><li>反之，如果你并行的工作单元还涉及等待I/O的操作（包括网络连接等待），那么使用<br>CompletableFuture灵活性更好，你可以像前文讨论的那样，依据等待/计算，或者<br>W/C的比率设定需要使用的线程数。这种情况不使用并行流的另一个原因是，处理流的<br>流水线中如果发生I/O等待，流的延迟特性会让我们很难判断到底什么时候触发了等待。</li></ul></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>执行比较耗时的操作时，尤其是那些依赖一个或多个远程服务的操作，建议进行异步化设计，使用<code>CompletableFuture</code>类提供的特性可轻松实现异步API。</p>]]></content>
    
    <summary type="html">
    
      第三部分：高效Java 8编程（三）：从一个生产环境的事故逐步引入异步编程思想
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://lilu.org.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java 8实战" scheme="https://lilu.org.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java-8%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Java8" scheme="https://lilu.org.cn/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（二）：优雅的解决NPE问题</title>
    <link href="https://lilu.org.cn/2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(2)/"/>
    <id>https://lilu.org.cn/2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(2)/</id>
    <published>2019-12-12T13:38:35.282Z</published>
    <updated>2019-12-12T13:04:39.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第十章：用Optional取代null"><a href="#第十章：用Optional取代null" class="headerlink" title="第十章：用Optional取代null"></a>第十章：用Optional取代null</h2><p><code>null</code>引用的想法最初由一位英国计算机科学家提出。他认为这是为”不存在的值“建模最容易的方式。设计初衷是通过编译器的自动检测机制，确保所有使用引用的地方都是绝对安全的。近些年出现的现代程序设计语言包括Java在内，都采用了相同的设计方式。</p><h3 id="null-引用带来的问题"><a href="#null-引用带来的问题" class="headerlink" title="null 引用带来的问题"></a>null 引用带来的问题</h3><ul><li>错误之源：程序员对对象的字段进行检查，判断字段的值是否为期望的格式，最终却发现访问的并不是一个对象，而是一个<code>null</code>引用–空指针，于是抛出一个<code>NullPointerException</code>异常。</li><li>代码膨胀：为了防止<code>null</code>，我们经常会写出这样类似的代码：<code>if (xxx != null) { // dosomething}</code>。这样你的代码就会充斥着深度嵌套的<code>null</code>检查，代码可读性极差。</li><li>毫无意义：<code>null</code>自身没有任何的语义，尤其是，它代表的是在静态类型语言中以一种错误的方式对缺失变量值的建模。</li><li>破坏哲学：Java一直试图避免让程序员意识到指针的存在，唯一的例外是：null指针。</li></ul><h3 id="使用防御式编程思想减少NPE问题"><a href="#使用防御式编程思想减少NPE问题" class="headerlink" title="使用防御式编程思想减少NPE问题"></a>使用防御式编程思想减少NPE问题</h3><p><code>NullPointerException</code>简称NPE。</p><p>采用防御式编程–快速失败的思想可以有效减少NPE问题。</p><p>如下的代码是推荐的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (param1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">if (param2 &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; do service</span><br></pre></td></tr></table></figure><p>不要使用<code>try-catch</code>的方式来处理。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    param.function();</span><br><span class="line">&#125; catch (NullPointerException e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种防御式编程的方法能有效解决问题，但仍然极易出错，一旦忘记检查那个可能为null的属性就会埋下一个隐藏的bug。</p><h3 id="优雅的解决方式"><a href="#优雅的解决方式" class="headerlink" title="优雅的解决方式"></a>优雅的解决方式</h3><p>Java 8中引入了一个新的类<code>java.util.Optional&lt;T&gt;</code>来优雅的解决NPE问题。</p><p>假设现在有一个<code>Person</code>类，有一个成员变量：汽车<code>Car</code>类；汽车<code>Car</code>类中又有一个成员变量：保险公司<code>Insurance</code>类；保险公司<code>Insurance</code>类中有一个成员变量：<code>String</code>类型的公司名。你可能会按下面的方式设计。<br><code>Person</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private Car car;</span><br><span class="line">    public Car getCar() &#123;</span><br><span class="line">        return car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Car</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Car &#123;</span><br><span class="line">    private Insurance insurance;</span><br><span class="line">    public Insurance getInsurance() &#123;</span><br><span class="line">        return insurance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Insurance</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Insurance &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们知道一个人可能有车也可能没有车，当一个人没车时需要将<code>null</code>引用赋值给<code>car</code>变量，于是我们应该将<code>car</code>变量声明为<code>Optional&lt;Car&gt;</code>类型；一辆车可能买了保险也可能没买保险，于是<code>Car</code>类中的<code>insurance</code>字段也应该声明为<code>Optional&lt;Insurance&gt;</code>类型；保险公司一定有一个公司名称，所以<code>Insurance</code>类中的<code>name</code>字段不用声明成<code>Optional</code>类型。新的类定义如下：<br><code>Person</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Optional;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    private Optional&lt;Car&gt; car;</span><br><span class="line">    public Optional&lt;Car&gt; getCar() &#123;</span><br><span class="line">        return car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Car</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Optional;</span><br><span class="line"></span><br><span class="line">public class Car &#123;</span><br><span class="line">    private Optional&lt;Insurance&gt; insurance;</span><br><span class="line">    public Optional&lt;Insurance&gt; getInsurance() &#123;</span><br><span class="line">        return insurance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Insurance</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Insurance &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>car</code>变量存在时，<code>Optional</code>类只是对<code>Car</code>类简单封装。当变量不存在时，缺失的值会被建模成一个“空” 的<code>Optional</code>对象，由方法<code>Optional.empty()</code>返回。<code>Optional.empty()</code>方法是一个静态工厂 方法，它返回<code>Optional</code>类的特定单一实例，与<code>null</code>完全不一样。</p><h3 id="何时使用Optional类？"><a href="#何时使用Optional类？" class="headerlink" title="何时使用Optional类？"></a>何时使用Optional类？</h3><p>在实际业务编码中，我们只能靠自己对业务模型的理解进行判断，需要判断出一个<code>null</code>是否属于某个变量的有效范围。</p><p>值得注意的是：如果一个类包含了<code>Optional</code>成员变量，则该类无法进行序列化和反序列化。</p><p>原因是<code>Optional</code>类未实现序列化<code>Serializable</code>接口。所以如果你的类是类似<code>Dubbo</code>服务提供者返回的模型对象，则不能将类成员设计成<code>Optional</code>类型。</p><p>Java语言的架构师Brian Goetz曾经非常明确地陈述过，<code>Optional</code>的设计初衷仅仅是要支持能返回<code>Optional</code>对象的语法。由于<code>Optional</code>类设计时就没特别考虑将其作为类的字段使用，所以它并未实现<code>Serializable</code>接口。</p><h3 id="应用Optional的几种模式"><a href="#应用Optional的几种模式" class="headerlink" title="应用Optional的几种模式"></a>应用Optional的几种模式</h3><h4 id="1-创建Optional对象"><a href="#1-创建Optional对象" class="headerlink" title="1. 创建Optional对象"></a>1. 创建Optional对象</h4><ul><li><p>声明一个空的<code>Optional</code>：通过静态工厂方法<code>Optional.empty</code>，创建一个空的<code>Optional</code>对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Car&gt; optCar &#x3D; Optional.empty();</span><br></pre></td></tr></table></figure></li><li><p>依据一个非空值创建<code>Optional</code>：使用静态工厂方法<code>Optional.of</code>，依据一个非空值创建一个<code>Optional</code>对象：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Car&gt; optCar &#x3D; Optional.of(car);</span><br></pre></td></tr></table></figure><p>如果<code>car</code>变量是一个<code>null</code>值，则这段代码会立即抛出<code>NullPointerException</code>，而不是等到试图访问<code>car</code>的属性时才返回一个错误。</p><ul><li>可接受<code>null</code>的<code>Optional</code>：使用静态工厂方法<code>Optional.ofNullalbe</code>，创建一个允许<code>null</code>值的<code>Optional</code>对象：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Car&gt; optCar &#x3D; Optional.ofNullable(car);</span><br></pre></td></tr></table></figure>如果<code>car</code>变量是一个<code>null</code>值，那么得到的<code>Optional</code>对象就是个空对象。</li></ul><h4 id="2-使用map从Optional对象中提取和转换值"><a href="#2-使用map从Optional对象中提取和转换值" class="headerlink" title="2. 使用map从Optional对象中提取和转换值"></a>2. 使用map从Optional对象中提取和转换值</h4><p><code>Optional</code>类的<code>map</code>方法和<code>Stream</code>类的<code>map</code>方法相差无几。<code>map</code>方法会将流中的每个元素通过提供的函数进行映射。可以把<code>Optional</code>对象看成一个特殊的集合，它最多包含一个元素。如果<code>Optional</code>包含一个值，那map方法就会把该值通过提供的函数映射成其它值，否则什么也不做。</p><h4 id="3-使用flatMap链接Optional对象"><a href="#3-使用flatMap链接Optional对象" class="headerlink" title="3. 使用flatMap链接Optional对象"></a>3. 使用flatMap链接Optional对象</h4><p>同样的，<code>Optional</code>类的<code>flatMap</code>方法和流的用法也类似。<code>flatMap</code>方法接收一个函数作为参数，这个函数的返回值是另一个流。这个函数会应用到流中的每一个元素上，于是每个元素被映射成一个小流，每个小流又形成一个大流作为<code>flatMap</code>方法的返回值。但是<code>flatMap</code>会将这个大流中的小流扁平化成一个单一的流。即流中不包含流，只包含各个元素。</p><h4 id="4-默认行为及解引用Optional对象"><a href="#4-默认行为及解引用Optional对象" class="headerlink" title="4. 默认行为及解引用Optional对象"></a>4. 默认行为及解引用Optional对象</h4><p><code>Optional</code>类提供了多种方法读取<code>Optional</code>实例中的变量值。</p><ul><li><code>get()</code>：如果变量存在，直接返回封装的变量值，否则抛出一个<code>NoSuchElementException</code>异常。</li><li><code>orElse(T other)</code>：允许在<code>Optional</code>对象不包含值时提供一个默认值。</li><li><code>orElseGet(Supplier&lt;? extends T&gt; other)</code>：是<code>orElse</code>方法的延时调用版，<code>Supplier</code>方法只有在<code>Optional</code>对象不含值时才执行调用。如果创建默认值是件耗时操作，考虑使用该方法；或者非常确定某个方法仅在<code>Optional</code>为空时才执行调用，也考虑使用该方法。</li><li><code>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code>：和<code>get</code>方法类似，如果取出的值为空都会抛出一个异常，使用<code>orElseThrow</code>可以定制希望抛出的异常类型。</li><li><code>ifPresent(Consumer&lt;? extends T&gt;)</code>：在变量值存在时执行一个传入的<code>Consumer</code>方法，否则不做任何处理。</li></ul><h4 id="5-使用filter剔除特定的值"><a href="#5-使用filter剔除特定的值" class="headerlink" title="5. 使用filter剔除特定的值"></a>5. 使用filter剔除特定的值</h4><p>我们经常需要调用某个对象的方法，查看它的某些属性。比如，我们可能需要检查保险公司的名称是否为<code>CambridgeInsurance</code>，为了以一种安全的方式进行这些操作，我们首先需要确定引用指向的<code>Insurance</code>对象是否为<code>null</code>，之后再调用它的<code>getName</code>方法。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Insurance insurance &#x3D; ...;</span><br><span class="line">if (insurance !&#x3D; null &amp;&amp; &quot;CambridgeInsurance&quot;.equals(insurance.getName())) &#123;</span><br><span class="line">    System.out.println(&quot;ok&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用<code>Optional</code>对象的<code>filter</code>方法，这段代码可以重构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Insurance&gt; optInsurance &#x3D; ...;</span><br><span class="line">optInsurance.filter(ins -&gt; &quot;CambridgeInsurance&quot;.equals(ins.getName()))</span><br><span class="line">.ifPresent(x -&gt; System.out.println(&quot;ok&quot;));</span><br></pre></td></tr></table></figure><p>如果<code>Optional</code>对象包含的值为空，它不做任何操作；反之，它对<code>Optional</code>对象包含的值添加谓词操作，如果该操作的结果为<code>true</code>，它不做任何改变，直接返回该<code>Optional</code>对象，否则就将该值过滤掉，将<code>Optional</code>的值置为空。</p><h3 id="Optional类的方法"><a href="#Optional类的方法" class="headerlink" title="Optional类的方法"></a>Optional类的方法</h3><table><thead><tr><th align="left">方法名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">empty</td><td align="left">返回一个空的 Optional 实例</td></tr><tr><td align="left">filter</td><td align="left">如果值存在并且满足提供的谓词，就返回包含该值的 Optional 对象；否则返回一个空的 Optional 对象</td></tr><tr><td align="left">flatMap</td><td align="left">如果值存在，就对该值执行提供的mapping映射函数调用，返回一个 Optional 类型的值，否则就返回一个空的 Optional 对象</td></tr><tr><td align="left">get</td><td align="left">如果该值存在，将该值用 Optional 封装返回，否则抛出一个 NoSuchElementException 异常</td></tr><tr><td align="left">ifPresent</td><td align="left">如果值存在，就执行使用该值的方法调用，否则什么也不做</td></tr><tr><td align="left">isPresent</td><td align="left">如果值存在就返回 true，否则返回 false</td></tr><tr><td align="left">map</td><td align="left">如果值存在，就对该值执行提供的 mapping映射函数调用</td></tr><tr><td align="left">of</td><td align="left">将指定值用 Optional 封装之后返回，如果该值为 null，则抛出一个 NullPointerException 异常</td></tr><tr><td align="left">ofNullable</td><td align="left">将指定值用 Optional 封装之后返回，如果该值为 null，则返回一个空的 Optional 对象</td></tr><tr><td align="left">orElse</td><td align="left">如果有值则将其返回，否则返回一个默认值</td></tr><tr><td align="left">orElseGet</td><td align="left">如果有值则将其返回，否则返回一个由指定的 Supplier 接口生成的值</td></tr><tr><td align="left">orElseThrow</td><td align="left">如果有值则将其返回，否则抛出一个由指定的 Supplier 接口生成的异常</td></tr></tbody></table><h3 id="基础类型的Optional对象，以及为什么应该避免使用它们"><a href="#基础类型的Optional对象，以及为什么应该避免使用它们" class="headerlink" title="基础类型的Optional对象，以及为什么应该避免使用它们"></a>基础类型的Optional对象，以及为什么应该避免使用它们</h3><p>与<code>Stream</code>对象一样，<code>Optional</code>也提供了类似的基础类型：<code>OptionalInt</code>、<code>OptionalLong</code>以及<code>OptionalDouble</code>。</p><p>如果<code>Stream</code>对象包含了大量元素，出于性能的考量， 使用基础类型是不错的选择，但对于<code>Optional</code>对象而言，这个理由就不成立了，因为<code>Optional</code>对象多只包含一个值。</p><p>不推荐大家使用基础类型的<code>Optional</code>对象，因为基础类型的<code>Optional</code>不支持<code>map</code>、<code>flatMap</code>和<code>filter</code>等方法。而这些却是<code>Optional</code>类最有用的方法。</p>]]></content>
    
    <summary type="html">
    
      第三部分：高效Java 8编程（二）：Optional类优雅的解决NPE问题
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://lilu.org.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java 8实战" scheme="https://lilu.org.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java-8%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Java8" scheme="https://lilu.org.cn/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（一）：接口重构和新特性</title>
    <link href="https://lilu.org.cn/2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(1)/"/>
    <id>https://lilu.org.cn/2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(1)/</id>
    <published>2019-12-12T13:38:35.279Z</published>
    <updated>2019-12-12T13:04:24.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第八章：重构、测试和调试"><a href="#第八章：重构、测试和调试" class="headerlink" title="第八章：重构、测试和调试"></a>第八章：重构、测试和调试</h2><h3 id="1-为改善可读性和灵活性重构代码"><a href="#1-为改善可读性和灵活性重构代码" class="headerlink" title="1. 为改善可读性和灵活性重构代码"></a>1. 为改善可读性和灵活性重构代码</h3><p>如果方向错了，停下来就是前进。</p><p>看完老员工留下来的代码，无力吐槽。如果以系统稳定可用为原则，不去改善代码可维护性，那等到将来需求变动需要修改时，对我们这些底层码农来说简直是一种折磨。欠下的技术债迟早是要还的。</p><h4 id="1-1-从匿名类到Lambda表达式的转换"><a href="#1-1-从匿名类到Lambda表达式的转换" class="headerlink" title="1.1 从匿名类到Lambda表达式的转换"></a>1.1 从匿名类到Lambda表达式的转换</h4><p>匿名类和Lambda表达式中的<code>this</code>含义是不同的。在匿名类中，this指代的是匿名类本身。但是在Lambda中，<code>this</code>指代的是包含Lambda表达式的类。</p><p>匿名类可以屏蔽包含类的变量，而Lambda表达式不能（编译都不能通过），例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void testAnonymityToLambda() &#123;</span><br><span class="line">    int a &#x3D; 10;</span><br><span class="line">    Runnable r1 &#x3D; () -&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 再次定义a变量会报错</span><br><span class="line">        &#x2F;&#x2F; int a &#x3D; 1;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;;</span><br><span class="line">    Runnable r2 &#x3D; new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int a &#x3D; 2;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-使用Lambda重构设计模式"><a href="#1-2-使用Lambda重构设计模式" class="headerlink" title="1.2 使用Lambda重构设计模式"></a>1.2 使用Lambda重构设计模式</h4><p>Lambda表达式为解决传统设计模式所面对的问题提供了新的解决方案。使用Lambda表达式后， 很多现存的略显臃肿的面向对象设计模式能够用更精简的方式实现了。<br>例如：</p><ul><li>策略模式</li><li>模板方法设计模式</li><li>责任链模式</li><li>工厂模式</li></ul><h3 id="2-测试Lambda表达式"><a href="#2-测试Lambda表达式" class="headerlink" title="2. 测试Lambda表达式"></a>2. 测试Lambda表达式</h3><p>使用Stream接口提供的<code>peek</code>方法可查看流水线中每个操作的中间状态，方便调试排错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void testPeek() &#123;</span><br><span class="line">    List&lt;Integer&gt; nums &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7);</span><br><span class="line">    nums.stream()</span><br><span class="line">            .peek(x -&gt; System.out.println(&quot;before map&quot; + x))</span><br><span class="line">            .map(x -&gt; x + 17)</span><br><span class="line">            .peek(x -&gt; System.out.println(&quot;before filter&quot; + x))</span><br><span class="line">            .filter(x -&gt; x % 2 &#x3D;&#x3D; 0)</span><br><span class="line">            .peek(x -&gt; System.out.println(&quot;before limit&quot; + x))</span><br><span class="line">            .limit(3)</span><br><span class="line">            .peek(x -&gt; System.out.println(&quot;before collect&quot; + x))</span><br><span class="line">            .collect(Collectors.toList())</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第九章：默认方法"><a href="#第九章：默认方法" class="headerlink" title="第九章：默认方法"></a>第九章：默认方法</h2><p>先来回顾一下接口的相关知识。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>使用<code>interface</code>关键字声明，访问修饰符可以为<code>public</code>和默认（不写）；同时可以使用<code>abstract</code>关键字修饰，因为接口可以理解成一种完全抽象。使用<code>abstract</code>关键字编译器会让你通过编译，但一般没有人这样做。</p><h4 id="Java-8-前"><a href="#Java-8-前" class="headerlink" title="Java 8 前"></a>Java 8 前</h4><ul><li>接口中的成员变量的修饰符全部默认为<code>public static final</code>，也可以不是静态<code>static</code>的，但一般没有人这样做。</li><li>接口中的方法只能是抽象方法。</li><li>接口中方法的修饰符全部默认为<code>public abstract</code>。</li></ul><h4 id="Java-8-后"><a href="#Java-8-后" class="headerlink" title="Java 8 后"></a>Java 8 后</h4><ul><li>接口中新增默认方法–使用<code>default</code>关键字声明。</li><li>接口中可以声明静态方法。</li></ul><h3 id="为什么要有默认方法？"><a href="#为什么要有默认方法？" class="headerlink" title="为什么要有默认方法？"></a>为什么要有默认方法？</h3><p>如果原来的接口已经被很多人使用了，现在要在原来的接口中新增一个方法，在Java 8之前，所有的实现类都需要去显式实现这个方法，会造成很多不必要的麻烦，也许有些实现类根本就不需要用到新增的这个方法，反而需要强制在代码中写一个显式的空实现。正是由于这个原因，Java 8提供了默认方法，接口中新增的方法使用<code>default</code>关键字修饰，就可以在接口中提供一个默认实现，实现类不再需要强制显式实现这个新增方法。这个新特性主要是面向类库开发者。</p><h3 id="默认方法引发的多实现冲突问题"><a href="#默认方法引发的多实现冲突问题" class="headerlink" title="默认方法引发的多实现冲突问题"></a>默认方法引发的多实现冲突问题</h3><p>一个类只能继承一个父类，但是可以实现多个接口。由于出现了默认方法，当一个类有多个实现时可能会出现方法继承冲突的问题。</p><h3 id="解决问题的三个原则"><a href="#解决问题的三个原则" class="headerlink" title="解决问题的三个原则"></a>解决问题的三个原则</h3><ul><li><p>类中的方法优先级最高。类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。</p></li><li><p>如果无法依据第一条进行判断，那么子接口的优先级更高：函数签名相同时，优先选择拥有最具体实现的默认方法的接口，即如果B继承了A，那么B就比A更加具体。</p></li><li><p>最后，如果还是无法判断，继承了多个接口的类必须通过显式覆盖和调用期望的方法，显式地选择使用哪一个默认方法的实现。</p></li></ul><h3 id="冲突情况分析"><a href="#冲突情况分析" class="headerlink" title="冲突情况分析"></a>冲突情况分析</h3><h4 id="情形一"><a href="#情形一" class="headerlink" title="情形一"></a>情形一</h4><ul><li>接口<code>InterfaceA</code>中定义了默认方法<code>hello</code>。</li><li>接口<code>InterfaceB</code>继承了接口<code>InterfaceA</code>，同时提供自己的默认<code>hello</code>方法。</li><li>实现类<code>ImplClassC</code>实现<code>InterfaceA</code>接口和<code>InterfaceB</code>接口，没有显式实现<code>hello</code>方法。</li></ul><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/WIXnvM6jawk92zU.png"  alt="9-case1.png"></p><p>接口<code>InterfaceB</code>继承了<code>InterfaceA</code>，接口<code>InterfaceB</code>中的<code>hello</code>方法更具体，所以实现类<code>ImplClassC</code>拥有的是<code>InterfaceB</code>接口中的<code>hello</code>方法。</p><h4 id="情形二"><a href="#情形二" class="headerlink" title="情形二"></a>情形二</h4><ul><li>接口<code>InterfaceA</code>中定义了默认方法<code>hello</code>。</li><li>接口<code>InterfaceB</code>继承了接口<code>InterfaceA</code>，同时提供自己的默认<code>hello</code>方法。</li><li>实现类<code>ImplClassD</code>实现<code>InterfaceA</code>接口，未显式重写接口的<code>hello</code>方法。</li><li>实现类<code>ImplClassC</code>继承<code>ImplClassD</code>类，同时实现<code>InterfaceA</code>和<code>InterfaceB</code>接口，没有显式实现<code>hello</code>方法。</li></ul><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/e4NTXoVklfH18B3.png"  alt="9-case2.png"></p><p><code>ImplClassC</code>和<code>ImplClassD</code>类中都未实现<code>hello</code>方法，<code>InterfaceB</code>继承<code>InterfaceA</code>接口，所以<code>InterfaceB</code>接口中的方法更具体，所以<code>ImplClassC</code>类具有的是<code>InterfaceB</code>中的<code>hello</code>方法。</p><h4 id="情形三"><a href="#情形三" class="headerlink" title="情形三"></a>情形三</h4><ul><li>接口<code>InterfaceA</code>中定义了默认方法<code>hello</code>。</li><li>接口<code>InterfaceB</code>继承了接口<code>InterfaceA</code>，同时提供自己的默认<code>hello</code>方法。</li><li>实现类<code>ImplClassD</code>实现了<code>InterfaceA</code>接口，并显式重写了接口的<code>hello</code>方法。</li><li>实现类<code>ImplClassC</code>继承了<code>ImplClassD</code>实现类，并实现了<code>InterfaceA</code>和<code>InterfaceB</code>接口，没有显式实现<code>hello</code>方法。</li></ul><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/XTn2dPVH6ycYmDJ.png"  alt="9-case3.png"></p><p><code>ImplClassC</code>和<code>ImplClassD</code>类中都未实现<code>hello</code>方法，<code>InterfaceB</code>继承<code>InterfaceA</code>接口，所以<code>InterfaceB</code>接口中的方法更具体，所以<code>ImplClassC</code>类具有的是<code>InterfaceB</code>中的<code>hello</code>方法。</p><h4 id="情形四"><a href="#情形四" class="headerlink" title="情形四"></a>情形四</h4><ul><li>接口<code>InterfaceA</code>中定义了默认方法<code>hello</code>。</li><li>接口<code>InterfaceB</code>中定义了默认方法<code>hello</code>，未继承。</li><li>实现类<code>ImplClassC</code>实现<code>InterfaceA</code>和<code>InterfaceB</code>接口。</li></ul><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/mPzwXtpCIKxqLea.png"  alt="9-case4.png"></p><p>如果实现类<code>ImplClassC</code>不重写<code>hello</code>方法，编译器会抛出编译错误：<br><code>ImplClassC inherits unrelated defaults for hello() from types InterfaceA and InterfaceB</code>。</p><p>可以直接在实现类中重新写一个<code>hello</code>方法的实现，也可以使用<code>super</code>关键字调用父接口的默认实现。</p><h4 id="情形五"><a href="#情形五" class="headerlink" title="情形五"></a>情形五</h4><ul><li>接口<code>InterfaceA</code>中定义了默认方法<code>hello</code>。</li><li>接口<code>InterfaceB</code>继承了接口<code>InterfaceA</code>，未提供任何方法。</li><li>接口<code>InterfaceC</code>继承了接口<code>InterfaceA</code>，未提供任何方法。</li><li>实现类<code>ImplClassD</code>实现<code>InterfaceB</code>和<code>InterfaceC</code>接口。</li></ul><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/DcACmO42doKHy8q.png"  alt="9-case5.png"></p><p><code>InterfaceB</code>和<code>InterfaceC</code>接口中都没有<code>hello</code>实现，它们的父接口<code>InterfaceA</code>中才有<code>hello</code>的默认实现，所以实现类<code>ImplClassD</code>拥有接口<code>InterfaceA</code>中<code>hello</code>方法。</p><h4 id="情形五扩展"><a href="#情形五扩展" class="headerlink" title="情形五扩展"></a>情形五扩展</h4><p>如果<code>InterfaceB</code>中也提供<code>hello</code>默认实现，根据规则第二点，编译器会选择<code>InterfaceB</code>中声明的默认方法。</p><p>如果<code>InterfaceB</code>和<code>InterfaceC</code>都提供<code>hello</code>默认实现，就会出现冲突，<code>ImplClassD</code>实现类必须实现<code>hello</code>方法。</p><p>如果<code>InterfaceC</code>接口中添加非默认抽象方法<code>hello</code>，那么它比继承<code>InterfaceA</code>接口而来的<code>hello</code>优先级高，此时实现类<code>ImplClassD</code>必须显式实现<code>InterfaceC</code>的<code>hello</code>抽象方法。</p>]]></content>
    
    <summary type="html">
    
      第三部分：高效Java 8编程（一）：接口新特性
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://lilu.org.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java 8实战" scheme="https://lilu.org.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java-8%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Java8" scheme="https://lilu.org.cn/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>《Java 8实战》读书笔记系列——第二部分：函数式数据处理</title>
    <link href="https://lilu.org.cn/2019/12/12/reading-notes/java8-in-action/Part-II-Functional-Data-Processing/"/>
    <id>https://lilu.org.cn/2019/12/12/reading-notes/java8-in-action/Part-II-Functional-Data-Processing/</id>
    <published>2019-12-12T13:38:35.276Z</published>
    <updated>2019-12-12T13:04:16.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第四章：引入流"><a href="#第四章：引入流" class="headerlink" title="第四章：引入流"></a>第四章：引入流</h2><h3 id="流的定义"><a href="#流的定义" class="headerlink" title="流的定义"></a>流的定义</h3><p>从支持数据处理操作的源生成的元素序列。</p><h3 id="元素序列"><a href="#元素序列" class="headerlink" title="元素序列"></a>元素序列</h3><p>就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。</p><p>因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元素（如ArrayList 与 LinkedList）。</p><p>但流的目的在于表达计算，比如前面见到的filter、sorted和map。</p><p>集合讲的是数据，流讲的是计算。</p><h3 id="源"><a href="#源" class="headerlink" title="源"></a>源</h3><p>流会使用一个提供数据的源，如集合、数组或输入/输出资源。</p><p>请注意，从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。</p><h3 id="数据处理操作"><a href="#数据处理操作" class="headerlink" title="数据处理操作"></a>数据处理操作</h3><p>流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，</p><p>如filter、map、reduce、find、match、sort等。流操作可以顺序执行，也可并行执行。 </p><h3 id="流操作的特点"><a href="#流操作的特点" class="headerlink" title="流操作的特点"></a>流操作的特点</h3><h4 id="1-流水线"><a href="#1-流水线" class="headerlink" title="1. 流水线"></a>1. 流水线</h4><p>很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。</p><p>这让之后章节中的一些优化成为可能，如延迟和短路。</p><p>流水线的操作可以看作对数据源进行数据库式（链式）查询。</p><h4 id="2-内部迭代"><a href="#2-内部迭代" class="headerlink" title="2. 内部迭代"></a>2. 内部迭代</h4><p>与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的（内部迭代）。</p><h4 id="3-流只能被消费一次"><a href="#3-流只能被消费一次" class="headerlink" title="3. 流只能被消费一次"></a>3. 流只能被消费一次</h4><p>终止操作只能有一次，重复消费会抛出java.lang.IllegalStateException异常。</p><h4 id="4-对流的操作分为两类：中间操作和终止操作"><a href="#4-对流的操作分为两类：中间操作和终止操作" class="headerlink" title="4. 对流的操作分为两类：中间操作和终止操作"></a>4. 对流的操作分为两类：中间操作和终止操作</h4><ul><li>中间操作总是会惰性执行：执行一个中间操作不会在原流上做任何处理，而是创建一个标记了该操作的新流返回。</li><li>终止操作才会进行真实的计算：计算发生时会把所有中间操作积攒的操作以Pipeline的方式执行，这样可以减少迭代次数，计算完成后流即失效。</li></ul><h3 id="集合与流的不同点："><a href="#集合与流的不同点：" class="headerlink" title="集合与流的不同点："></a>集合与流的不同点：</h3><ul><li>无存储：Stream不是一种数据结构，它只是某种数据源的一个视图。数据源可以是一个数组、Java容器或I/O资源等。</li><li>为函数式编程而生：对Stream的任何修改都不会修改背后的数据源，比如对一个流执行filter过滤操作并不会删除被过滤的元素，而是会产生一个新的不包含被过滤元素的新流。</li><li>惰性执行：对流的中间操作并不会立即执行，只有等一个终止操作来临时才会一次性全部执行。</li><li>可消费性：一个流只能被消费一次，一旦产生终止操作，流即被消费。</li></ul><h2 id="第五章：使用流"><a href="#第五章：使用流" class="headerlink" title="第五章：使用流"></a>第五章：使用流</h2><h3 id="1-筛选和切片"><a href="#1-筛选和切片" class="headerlink" title="1.  筛选和切片"></a>1.  筛选和切片</h3><p>选择流中的元素：用谓词筛选，筛选出各不相同的元素，忽略流 中的头几个元素，或将流截短至指定长度。</p><h4 id="1-1-用谓词筛选"><a href="#1-1-用谓词筛选" class="headerlink" title="1.1 用谓词筛选"></a>1.1 用谓词筛选</h4><p>Streams接口支持<code>filter</code>方法。该操作会接受一个谓词（一个返回 boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流。</p><h4 id="1-2-筛选各异的元素"><a href="#1-2-筛选各异的元素" class="headerlink" title="1.2 筛选各异的元素"></a>1.2 筛选各异的元素</h4><p>流支持一个叫作<code>distinct</code>的方法，它会返回一个元素各异（根据流所生成元素的 hashCode和equals方法实现）的流。</p><h4 id="1-3-截短流"><a href="#1-3-截短流" class="headerlink" title="1.3 截短流"></a>1.3 截短流</h4><p>流支持<code>limit(n)</code>方法，该方法会返回一个不超过给定长度的流。</p><p>所需的长度作为参数传递给limit。如果流是有序的，则多会返回前n个元素。</p><h4 id="1-4-跳过元素"><a href="#1-4-跳过元素" class="headerlink" title="1.4 跳过元素"></a>1.4 跳过元素</h4><p>流还支持<code>skip(n)</code>方法，返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一个空流。</p><p>请注意，<code>limit(n)</code>和<code>skip(n)</code>是互补的。</p><h3 id="2-映射"><a href="#2-映射" class="headerlink" title="2. 映射"></a>2. 映射</h3><p>一个非常常见的数据处理套路就是从某些对象中选择信息。</p><p>比如在SQL里，你可以从表中选择一列。Stream API也通过<code>map</code>和<code>flatMap</code>方法提供了类似的工具。</p><h4 id="2-1-对流中每一个元素应用函数"><a href="#2-1-对流中每一个元素应用函数" class="headerlink" title="2.1 对流中每一个元素应用函数"></a>2.1 对流中每一个元素应用函数</h4><p>流支持<code>map</code>方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，</p><p>并将其映射成一个新的元素（使用映射一词，是因为它和转换类似，但其中的细微差别在于它是“创建一个新版本”而不是去“修改”）。</p><h4 id="2-2-流的扁平化"><a href="#2-2-流的扁平化" class="headerlink" title="2.2 流的扁平化"></a>2.2 流的扁平化</h4><p>流支持<code>flatMap</code>方法，将各个单独的流合并起来，扁平化成一个流。</p><p><code>flatMap</code>方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。</p><h3 id="3-查找和匹配"><a href="#3-查找和匹配" class="headerlink" title="3. 查找和匹配"></a>3. 查找和匹配</h3><p>另一个常见的数据处理套路是看看数据集中的某些元素是否匹配一个给定的属性。</p><p>Stream API通过<code>anyMatch</code>、<code>allMatch</code>、<code>noneMatch</code>、<code>findAny</code>和<code>findFirst</code>方法提供了这样的工具。</p><h4 id="3-1-检查谓词是否至少匹配一个元素"><a href="#3-1-检查谓词是否至少匹配一个元素" class="headerlink" title="3.1 检查谓词是否至少匹配一个元素"></a>3.1 检查谓词是否至少匹配一个元素</h4><p><code>anyMatch()</code>：流中是否有一个元素能匹配给定的谓词。</p><p>返回一个boolean，因此是一个终端操作。</p><h4 id="3-2-检查谓词是否匹配所有元素"><a href="#3-2-检查谓词是否匹配所有元素" class="headerlink" title="3.2 检查谓词是否匹配所有元素"></a>3.2 检查谓词是否匹配所有元素</h4><p><code>allMatch()</code>：流中的元素是否都能匹配给定的谓词。是一个终端操作。</p><h4 id="3-3-检查谓词是否不匹配所有元素"><a href="#3-3-检查谓词是否不匹配所有元素" class="headerlink" title="3.3 检查谓词是否不匹配所有元素"></a>3.3 检查谓词是否不匹配所有元素</h4><p><code>noneMatch()</code>：流中没有任何元素与给定的谓词匹配。</p><h4 id="3-4-查找元素"><a href="#3-4-查找元素" class="headerlink" title="3.4 查找元素"></a>3.4 查找元素</h4><p><code>findAny()</code>：将返回当前流中的任意元素。如果流中没有元素，返回值可能为空，于是Java 8引入了<code>Optional&lt;T&gt;</code>类。</p><h3 id="Optional简介"><a href="#Optional简介" class="headerlink" title="Optional简介"></a>Optional简介</h3><p><code>Optional&lt;T&gt;</code>类（<code>java.util.Optional</code>）是一个容器类，代表一个值存在或不存在。</p><p>方法简介：</p><p>1、<code>isPresent()</code>：将在Optional包含值的时候返回true, 否则返回false。</p><p>2、<code>ifPresent(Consumer&lt;T&gt; block)</code>：会在值存在的时候执行给定的代码块。</p><p>3、<code>T get()</code>：会在值存在时返回值，否则抛出一个<code>NoSuchElement</code>异常。</p><p>4、<code>T orElse(T other)</code>：会在值存在时返回值，否则返回一个默认值。 </p><h4 id="3-5-查找第一个元素"><a href="#3-5-查找第一个元素" class="headerlink" title="3.5 查找第一个元素"></a>3.5 查找第一个元素</h4><p><code>findFirst()</code>：返回流中的第一个元素。同样地，如果流中没有元素，返回值可能为空，返回类型为<code>Optional&lt;T&gt;</code>类。</p><p>有些流有一个出现顺序（encounter order）来指定流中项目出现的逻辑顺序（比如由List或排序好的数据列生成的流）。对于这种流，可能想要找到第一个元素。</p><h3 id="4-归约"><a href="#4-归约" class="headerlink" title="4. 归约"></a>4. 归约</h3><p><code>reduce()</code>：将流中所有元素反复结合起来，得到一个值。</p><p><code>reduce()</code>方法有两个重载的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param identity 归约的初始值</span><br><span class="line"> * @param accumulator 归约操作</span><br><span class="line"> *&#x2F;</span><br><span class="line">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param accumulator 归约操作</span><br><span class="line"> * @return Optional&lt;T&gt;对象，由于没有初始值，流中元素可能为空，故返回值会存在空的情况。</span><br><span class="line"> *&#x2F;</span><br><span class="line">Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);</span><br></pre></td></tr></table></figure><p>map和reduce的连接通常称为map-reduce模式，因Google用它来进行网络搜索而出名，因为它很容易并行化。</p><h3 id="5-数值流"><a href="#5-数值流" class="headerlink" title="5. 数值流"></a>5. 数值流</h3><p>流中的元素是数值型的，例如int，long，double。尽管可以把这些数值型元素放入流中，但实际上是暗含了装箱操作，将数值型元素转换成对应的包装类型，从而形成对象流。</p><p>Stream API提供了原始类型流特化，专门支持处理数值流的方法。减去装箱操作的损耗。</p><h4 id="5-1-原始类型流特化"><a href="#5-1-原始类型流特化" class="headerlink" title="5.1 原始类型流特化"></a>5.1 原始类型流特化</h4><p>Java 8引入了三个原始类型特化流接口：<code>IntStream</code>、<code>DoubleStream</code>和<code>LongStream</code>，分别将流中的元素特化为int、long和double，从而避免了暗含的装箱成本。</p><p>每个接口都带来了进行常用数值归约的新方法，比如对数值流求和的sum，找到大元素的max。此外还有在必要时再把它们转换回对象流的方法。</p><h5 id="5-1-1-映射到数值流"><a href="#5-1-1-映射到数值流" class="headerlink" title="5.1.1 映射到数值流"></a>5.1.1 映射到数值流</h5><p>将流转换为特化版本的常用方法是<code>mapToInt</code>、<code>mapToDouble</code>和<code>mapToLong</code>。这些方法map方法的工作方式一样，只是它们返回的是一个特化流，而不是<code>Stream&lt;T&gt;</code>。</p><h5 id="5-1-2-转换回对象流"><a href="#5-1-2-转换回对象流" class="headerlink" title="5.1.2 转换回对象流"></a>5.1.2 转换回对象流</h5><p>一旦有了数值流，可能需要将其转换回非特化流。</p><h5 id="5-1-3-默认值OptionalInt"><a href="#5-1-3-默认值OptionalInt" class="headerlink" title="5.1.3 默认值OptionalInt"></a>5.1.3 默认值OptionalInt</h5><p>对于原始类型特化流接口中的max，min，average等方法的返回值。如果流是空的，这些方法的返回值为空，但不能默认为0。因为可能真实计算的结果恰好为0。</p><p>可以使用Optional类来解决返回值为空的情况。但<code>Optional&lt;T&gt;</code>只能接收包装类型。传递原始类型会触发自动装箱操作，产生损耗。</p><p>Java 8同样引入了Optional原始类型特化版本：<code>OptionalInt</code>、<code>OptionalDouble</code>和<code>OptionalLong</code>，用这些Optional类来解决传递原始类型时自动装箱的问题。</p><h4 id="5-2-数值范围"><a href="#5-2-数值范围" class="headerlink" title="5.2 数值范围"></a>5.2 数值范围</h4><p>和数字打交道时，有一个常用的东西就是数值范围。比如生成1和100之间的所有数字。</p><p>Java 8引入了两个可以用于<code>IntStream</code>和<code>LongStream</code>的静态方法，帮助生成这种范围： <code>range</code>和<code>rangeClosed</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * range方法表示的范围为：[startInclusive,endExclusive)</span><br><span class="line"> * @param startInclusive 数值范围开始</span><br><span class="line"> * @param endExclusive 数值范围结束（不包含该值）</span><br><span class="line"> *&#x2F;</span><br><span class="line">IntStream range(int startInclusive, int endExclusive);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * rangeClosed方法表示的范围为：[startInclusive,endExclusive]</span><br><span class="line"> * @param startInclusive 数值范围开始</span><br><span class="line"> * @param endExclusive 数值范围结束（包含该值）</span><br><span class="line"> *&#x2F;</span><br><span class="line">IntStream rangeClosed(int startInclusive, int endInclusive);</span><br></pre></td></tr></table></figure><p>这两个方法都是第一个参数接受起始值，第二个参数接受结束值。但<code>range</code>是不包含结束值的，而<code>rangeClosed</code>则包含结束值。</p><h3 id="6-构建流"><a href="#6-构建流" class="headerlink" title="6. 构建流"></a>6. 构建流</h3><p>介绍如何从值序列、数组、文件来创建流，甚至由生成函数来创建无限流。</p><h4 id="6-1-由值创建流"><a href="#6-1-由值创建流" class="headerlink" title="6.1 由值创建流"></a>6.1 由值创建流</h4><p>使用静态方法<code>Stream.of(T...values)</code>，通过显式值创建一个流。它可以接受任意数量的参数。</p><p>使用静态方法<code>Stream.empty()</code>，创建一个空流。</p><h4 id="6-2-由数组创建流"><a href="#6-2-由数组创建流" class="headerlink" title="6.2 由数组创建流"></a>6.2 由数组创建流</h4><p>使用静态方法<code>Arrays.stream</code>从数组创建一个流。它接受一个数组作为参数。</p><h4 id="6-3、由文件生成流"><a href="#6-3、由文件生成流" class="headerlink" title="6.3、由文件生成流"></a>6.3、由文件生成流</h4><p>Java中用于处理文件等I/O操作的NIO API（非阻塞 I/O）已更新，以便利用Stream API。</p><p><code>java.nio.file.Files</code>中的很多静态方法都会返回一个流。</p><p>例如，<code>Files.lines</code>，它会返回一个由指定文件中的各行构成的字符串流。</p><h4 id="6-4-由函数生成流：创建无限流"><a href="#6-4-由函数生成流：创建无限流" class="headerlink" title="6.4 由函数生成流：创建无限流"></a>6.4 由函数生成流：创建无限流</h4><p>Stream API提供了两个静态方法来从函数生成流：<code>Stream.iterate</code>和<code>Stream.generate</code>。</p><p>这两个操作可以创建所谓的无限流：不像从固定集合创建的流那样有固定大小的流。</p><p>由<code>iterate</code>和<code>generate</code>产生的流会用给定的函数按需创建值，因此可以无穷无尽地计算下去！</p><p>一般来说，应该使用<code>limit(n)</code>来对这种流加以限制，以避免打印无穷多个值。</p><h2 id="第六章：用流收集数据"><a href="#第六章：用流收集数据" class="headerlink" title="第六章：用流收集数据"></a>第六章：用流收集数据</h2><h3 id="1-汇总"><a href="#1-汇总" class="headerlink" title="1. 汇总"></a>1. 汇总</h3><p><code>Collectors</code>类专门为汇总提供了一个工厂方法：<code>Collectors.summingInt</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? super T&gt; mapper);</span><br></pre></td></tr></table></figure><p>它可接受一个把对象映射为求和所需int的函数，并返回一个收集器，该收集器在传递给普通的collect方法后即执行我们需要的汇总操作。</p><p>类似的还有<code>Collectors.summingDouble</code>方法和<code>Collectors.summingLong</code>方法，汇总为double和long类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collector&lt;T, ?, Long&gt; summingLong(ToLongFunction&lt;? super T&gt; mapper);</span><br><span class="line">Collector&lt;T, ?, Double&gt; summingDouble(ToDoubleFunction&lt;? super T&gt; mapper);</span><br></pre></td></tr></table></figure><p>汇总不仅仅只有求和。</p><p>平均数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collector&lt;T, ?, Double&gt; averagingInt(ToIntFunction&lt;? super T&gt; mapper);</span><br><span class="line">Collector&lt;T, ?, Double&gt; averagingDouble(ToDoubleFunction&lt;? super T&gt; mapper);</span><br><span class="line">Collector&lt;T, ?, Double&gt; averagingLong(ToLongFunction&lt;? super T&gt; mapper);</span><br></pre></td></tr></table></figure><p>一次操作取得多个汇总结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collector&lt;T, ?, IntSummaryStatistics&gt; summarizingInt(ToIntFunction&lt;? super T&gt; mapper);</span><br><span class="line">Collector&lt;T, ?, LongSummaryStatistics&gt; summarizingLong(ToLongFunction&lt;? super T&gt; mapper);</span><br><span class="line">Collector&lt;T, ?, DoubleSummaryStatistics&gt; summarizingDouble(ToDoubleFunction&lt;? super T&gt; mapper);</span><br></pre></td></tr></table></figure><p>可以通过对用getter方法取得汇总结果。</p><h3 id="2-连接字符串"><a href="#2-连接字符串" class="headerlink" title="2. 连接字符串"></a>2. 连接字符串</h3><p><code>joining</code>工厂方法返回的收集器会把对流中每一个对象应用toString方法得到的所有字符串连接成一个字符串。</p><p><code>joining</code>方法有3个重载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 内部使用StringBuilder拼接</span><br><span class="line"> *&#x2F;</span><br><span class="line">Collector&lt;CharSequence, ?, String&gt; joining();</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param delimiter 表示每个字符串连接时的分隔符</span><br><span class="line"> *&#x2F;</span><br><span class="line">Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param delimiter 分隔符</span><br><span class="line"> * @param prefix 字符串前缀</span><br><span class="line"> * @param suffix 字符串后缀</span><br><span class="line"> *&#x2F;</span><br><span class="line">Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,CharSequence prefix,CharSequence suffix);</span><br></pre></td></tr></table></figure><h3 id="3-分组"><a href="#3-分组" class="headerlink" title="3. 分组"></a>3. 分组</h3><p><code>groupingBy</code>：跟数据库中的group by分组操作一样。同时支持多级分组。</p><p><code>groupingBy</code>方法有多个重载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 内部调用的是带两个参数的groupingBy方法，第二个参数传递的是Collectors.toList()。 </span><br><span class="line"> * @param classifier 一个Function函数型接口。</span><br><span class="line"> *&#x2F;</span><br><span class="line">groupingBy(Function&lt;? super T, ? extends K&gt; classifier);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 内部调用的是三个参数的groupingBy方法。</span><br><span class="line"> * @param classifier 一个Function函数型接口</span><br><span class="line"> * @param downstream 一个收集器对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">groupingBy(Function&lt;? super T, ? extends K&gt; classifier,Collector&lt;? super T, A, D&gt; downstream);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 有三个参数，groupingBy分组的具体实现。</span><br><span class="line"> *&#x2F;</span><br><span class="line">groupingBy(Function&lt;? super T, ? extends K&gt; classifier,Supplier&lt;M&gt; mapFactory,Collector&lt;? super T, A, D&gt; downstream);</span><br></pre></td></tr></table></figure><p>可以把第二个<code>groupingBy</code>收集器传递给外层收集器来实现多级分组。 但进一步说，传递给第一个<code>groupingBy</code>的第二个收集器可以是任何类型，而不一定是另一个<code>groupingBy</code>。</p><p>收集器返回的结果可能是Optional包装后的对象，对于多级分组来说，第二个收集器对象参数返回的Optional对象可能没什么用。第一层groupingBy已经把为空的情况给排除掉了。</p><p>Collectors收集器提供了<code>collectingAndThen</code>方法将收集器进行转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 返回转换后的另一个收集器</span><br><span class="line"> * @param downstream 需要转换的收集器</span><br><span class="line"> * @param finisher 转换函数</span><br><span class="line"> *&#x2F;</span><br><span class="line">Collector&lt;T,A,RR&gt; Collectors.collectingAndThen(Collector&lt;T,A,R&gt; downstream,Function&lt;R,RR&gt; finisher);</span><br></pre></td></tr></table></figure><p><code>groupingBy</code>可以联合其它收集器使用，经常使用的是mapping方法。它可以让接受特定类型元素的收集器适应不同类型的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param mapper 一个函数型接口,对流中的元素做映射</span><br><span class="line"> * @param downstream 一个收集器，将映射后的元素收集起来</span><br><span class="line"> *&#x2F;</span><br><span class="line">Collector&lt;T, ?, R&gt; mapping(Function&lt;? super T, ? extends U&gt; mapper,Collector&lt;? super U, A, R&gt; downstream);</span><br></pre></td></tr></table></figure><h3 id="4-分区"><a href="#4-分区" class="headerlink" title="4. 分区"></a>4. 分区</h3><p><code>partitioningBy</code>分区是分组的特殊情况：由一个谓词（返回一个布尔值的函数）作为分类函数，它称分区函数。</p><p>分区函数返回一个布尔值，这意味着得到的分组Map的键类型是Boolean，于是它多可以分为两组——true是一组，false是一组。</p><p><code>partitioningBy</code>收集器有两个重载的方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 内部调用了两个参数的重载方法，第二个参数传递的是一个Collectors.toList()收集器。</span><br><span class="line"> * @param predicate 断言型接口</span><br><span class="line"> *&#x2F;</span><br><span class="line">Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param predicate 断言型接口</span><br><span class="line"> * @param downstream 收集器</span><br><span class="line"> *&#x2F;</span><br><span class="line">Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate,Collector&lt;? super T, A, D&gt; downstream);</span><br></pre></td></tr></table></figure><p>分区也可用相同的谓词使用<code>filter</code>筛选来实现。</p><h4 id="分区的好处："><a href="#分区的好处：" class="headerlink" title="分区的好处："></a>分区的好处：</h4><ul><li>保留了分区函数返回true或false的两套流元素列表。</li><li>使用filter筛选需要操作两次，一次利用谓词，一次利用谓词的非。</li></ul><h2 id="第七章：并行数据处理与性能"><a href="#第七章：并行数据处理与性能" class="headerlink" title="第七章：并行数据处理与性能"></a>第七章：并行数据处理与性能</h2><h3 id="并行处理数据一定比串行处理快吗？"><a href="#并行处理数据一定比串行处理快吗？" class="headerlink" title="并行处理数据一定比串行处理快吗？"></a>并行处理数据一定比串行处理快吗？</h3><p>答案是不一定。</p><p>假设你现在要进行数字累加的操作，例如计算1至100万之间所有数字的和。</p><p>现在有三种方案可供选择。</p><p>方案一：原始迭代方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static long iterateSum(long n) &#123;</span><br><span class="line">    long result &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        result +&#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案二：使用<code>Stream</code>串行流处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static long streamSum(long n) &#123;</span><br><span class="line">    Long result &#x3D; Stream.iterate(0L, i -&gt; i + 1)</span><br><span class="line">            .limit(n)</span><br><span class="line">            .reduce(0L, Long::sum);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案三：使用<code>ParallelStream</code>并行流处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static long parallelSum(long n) &#123;</span><br><span class="line">    Long result &#x3D; Stream.iterate(0L, i -&gt; i + 1)</span><br><span class="line">            .limit(n)</span><br><span class="line">            .parallel()</span><br><span class="line">            .reduce(0L, Long::sum);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原始迭代方案中不需要对原始类型的数字进行装箱操作。</p><p>串行流方案中利用<code>Stream</code>接口的<code>iterate</code>方法生成0到n的自然数流，默认是串行流，然后归约求和。</p><p>并行流方案中利用<code>Stream</code>接口的<code>iterate</code>方法生成0到n的自然数流，使用<code>parallel</code>方法将流转换成并行流，然后归约求和。</p><p>测试方法：运行10次，取最短时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static long measureSumPerf(Function&lt;Long,Long&gt; adder,long n) &#123;</span><br><span class="line">    long fastest &#x3D; Integer.MAX_VALUE;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">        long start &#x3D; System.nanoTime();</span><br><span class="line">        long sum &#x3D; adder.apply(n);</span><br><span class="line">        long duration &#x3D; (System.nanoTime() - start) &#x2F; 1_100_100;</span><br><span class="line">        if (duration &lt; fastest) &#123;</span><br><span class="line">            fastest &#x3D; duration;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return fastest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; test</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F; 原始迭代方式更快，它不需要对原始类型进行装箱&#x2F;拆箱操作</span><br><span class="line">    System.out.println(&quot;iterate sum min time:&quot; + measureSumPerf(</span><br><span class="line">    StreamPerformanceTest::iterateSum, 100000000));</span><br><span class="line">    &#x2F;&#x2F; iterate生成的是装箱的对象，必须拆箱成数字才能求和。</span><br><span class="line">    System.out.println(&quot;stream sum min time:&quot; + measureSumPerf(</span><br><span class="line">    StreamPerformanceTest::streamSum, 100000000));</span><br><span class="line">    &#x2F;&#x2F; 整个数字在过程开始时并没有准备好，无法有效的把流划分为小块来并行处理。</span><br><span class="line">    System.out.println(&quot;parallel stream sum min time:&quot; + measureSumPerf(</span><br><span class="line">    StreamPerformanceTest::parallelSum, 100000000));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原始迭代方案最快：iterate sum min time:11</span><br><span class="line">串行流方案第二快：stream sum min time:198</span><br><span class="line">并行流方案最慢：parallel stream sum min time:267</span><br></pre></td></tr></table></figure><p>可见并行执行并不比串行执行快。但实际上这次试验的很大一部分时间消耗在对原始数据类型进行装箱的操作上。因为<code>Stream</code>接口的<code>iterate</code>方法生成的是包装对象，求和时需要拆箱成数字。同时使用<code>iterate</code>方法在程序开始时并没有把整个数字序列准备好，无法有效的把流划分为小块来并行处理。</p><p>接下来使用原始类型特化流来生成数字流。</p><p>原始类型特化流串行处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static long longStreamSum(long n) &#123;</span><br><span class="line">   long result &#x3D; LongStream.rangeClosed(1, n).reduce(0L, Long::sum);</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原始类型特化流并行处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static long longParallelSum(long n) &#123;</span><br><span class="line">    long result &#x3D; LongStream.rangeClosed(1, n).parallel().reduce(0L, Long::sum);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; LongStream.rangeClosed直接产生原始类型的long数字，没有装箱拆箱的开销。</span><br><span class="line">System.out.println(&quot;long stream sum min time:&quot; + measureSumPerf(</span><br><span class="line">    StreamPerformanceTest::longStreamSum,100000000));</span><br><span class="line">&#x2F;&#x2F; LongStream.rangeClosed在过程开始时就会生成数字范围，很容易拆分为独立的小块进行并行处理。</span><br><span class="line">System.out.println(&quot;long parallel stream sum min time:&quot; +   measureSumPerf(StreamPerformanceTest::longParallelSum,100000000));</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原始类型特化流串行处理：long stream sum min time:7</span><br><span class="line">原始类型特化流并行处理：long parallel stream sum min time:1</span><br></pre></td></tr></table></figure><p><code>LongStream.rangeClosed</code>直接产生原始类型的long数字，没有装箱拆箱的开销。</p><p><code>LongStream.rangeClosed</code>在过程开始时就会生成数字范围，很容易拆分为独立的小块进行并行处理。</p><h3 id="并行流有时候比串行流慢的原因"><a href="#并行流有时候比串行流慢的原因" class="headerlink" title="并行流有时候比串行流慢的原因"></a>并行流有时候比串行流慢的原因</h3><p>并行流有时候比串行流慢的原因：</p><ol><li>没有使用合理的使用数据结构，导致时间浪费在其它非流处理的操作上。</li><li>并行流的底层实现是Fork/Join框架。它是基于多线程的，线程之间进行上下文切换需要耗时。同时线程是操作系统进行调度的。线程自己无法控制时间。</li></ol><h3 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h3><p>Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。体现了分治法的思想。Fork的意思是拆分，Join的意思是合并。比如计算1+2+…+10000，可以分割成10个子任务，每个子任务分别对1000个数进行求和， 最终汇总这10个子任务的结果。Fork/Join框架的运行流程图如下：</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/4YvPn3qOA8BeKtw.jpg"  alt="Fork-Join.png"></p><p>Fork/Join的拆分重点在于任务什么时候足够小或不可分，不可再拆分的任务顺序执行，不同的任务之间并行执行。所有不可拆分的子任务分配到多个任务队列中等待线程去执行，每个队列都有一个单独的线程去执行任务。理想情况下，划分并行任务时，应该让每个任务都用相同的时间完成，让所有的CPU都同样繁忙，充分的利用CPU。但实际中，由于线程是由操作系统根据时间片进行调度的，每个子任务所花的时间可能天差地别。于是会出现一个任务队列的任务全部执行完了，另一个队列中还有很多任务的情况。这个时候CPU的利用率没有最大化。Java 8采用工作窃取算法来解决这一问题。</p><h3 id="工作窃取（work-stealing）算法"><a href="#工作窃取（work-stealing）算法" class="headerlink" title="工作窃取（work-stealing）算法"></a>工作窃取（work-stealing）算法</h3><p>工作窃取算法是指某个线程从其它队列中窃取任务来执行。某个线程，自己队列中的任务执行完了，就去别的还有任务的队列中窃取一个任务来执行。这个时候会存在线程竞争关系，窃取线程和被窃取线程之间同时访问同一个队列。通常使用双端队列来解决。被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p><h4 id="工作窃取算法的优点："><a href="#工作窃取算法的优点：" class="headerlink" title="工作窃取算法的优点："></a>工作窃取算法的优点：</h4><p>充分利用线程进行并行计算，减少了线程间的竞争。</p><h4 id="工作窃取算法的缺点："><a href="#工作窃取算法的缺点：" class="headerlink" title="工作窃取算法的缺点："></a>工作窃取算法的缺点：</h4><p>在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p><h3 id="Fork-Join框架的设计思路"><a href="#Fork-Join框架的设计思路" class="headerlink" title="Fork/Join框架的设计思路"></a>Fork/Join框架的设计思路</h3><ol><li>首先需要一个Fork类去把大任务进行递归Fork拆分，直至拆分成不可再分的小任务。</li><li>拆分出来的子任务均匀地分配到n个双端队列中，启动n个线程分别从双端队列中获取任务执行。每个子任务执行完的结果统一放在一个结果队列中，启动一个线程从结果队列中取结果，然后Join合并成最终结果。</li></ol>]]></content>
    
    <summary type="html">
    
      第二部分：StreamAPI函数式数据处理
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://lilu.org.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java 8实战" scheme="https://lilu.org.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java-8%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Java8" scheme="https://lilu.org.cn/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>《Java 8实战》读书笔记系列——第一部分：基础知识</title>
    <link href="https://lilu.org.cn/2019/12/12/reading-notes/java8-in-action/Part-I-Basics/"/>
    <id>https://lilu.org.cn/2019/12/12/reading-notes/java8-in-action/Part-I-Basics/</id>
    <published>2019-12-12T13:38:35.272Z</published>
    <updated>2019-12-12T13:04:08.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章：为什么要关心Java-8"><a href="#第一章：为什么要关心Java-8" class="headerlink" title="第一章：为什么要关心Java 8"></a>第一章：为什么要关心Java 8</h2><p>第一章主要需要了解Java语言的发展历史。</p><h3 id="Java-8的前世今生"><a href="#Java-8的前世今生" class="headerlink" title="Java 8的前世今生"></a>Java 8的前世今生</h3><p>从第一个Java版本诞生到现在已经有23年的时间了。沧海桑田一瞬间，转眼24年过去了，如今JDK 8以上的版本也开始收费了，JDK 11成为目前长期支持的版本。版本不断变更的这几年，很多企业项目还是在用JDK 8或更低的版本进行维护。但是对于我们开发者来说，始终要不断地学习了解新特性和新技术，否则大浪淘沙，终有一日将成为沙滩上的一条咸鱼。</p><p>时间在变，但我们对技术的那份初心永不会变。作为一个Java开发工程师，很有必要来了解一下Java语言发展史。</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/cWvm6DXU2Yz1kqP.png"  alt="1-JavaTimeline.png"></p><p>1995年5月23日，从Oak（橡树）到Java，Java语言第一次提出了”Write Once, Run Anywhere”的口号。</p><p>1996年1月23日，Java语言的第一个正式版本的运行环境JDK 1.0发布。</p><p>1998年12月4日，JDK的第一个里程碑式的版本JDK 1.2发布，工程代号为Playground（竞技场）。sun公司在这个版本中把Java技术体系拆分为三个方向，分别是面向桌面应用开发的J2SE（Java 2 Platform，Standard Edition）、面向企业级开发的J2EE（Java 2 Platform，Enterprise Edition）和面向手机等移动终端开发的J2ME（Java 2 Platform，Micro Edition）。</p><p>2000年5月8日，工程代号为Kestrel（美洲红隼 [sǔn] ）的JDK 1.3发布，它还有一个修正版本JDK 1.3.1，工程代号为Ladybird（瓢虫），于2001年5月17日发布。从这个版本开始，Sun公司维持了一个习惯：大约每隔两年发布一个JDK的主版本，以动物命名，期间发布的各个修正版本则以昆虫作为工程名称。</p><p>2002年2月13日，工程代号为Merlin（灰背隼）的JDK 1.4发布。后续还有两个修正版本：2002年9月16日发布的工程代号为Grasshopper（蚱蜢）的JDK 1.4.1和2003年6月26日发布的工程代号为Mantis（螳螂）的JDK 1.4.2。</p><p>2004年9月30日，工程代号为Tiger（老虎）的JDK 1.5发布。这个版本的JDK在我看来是Java语言能发展到今天的基石。它提供了自动装箱、泛型、动态注解、枚举、可变长参数、foreach循环和java.util.concurrent并发包等新特性，这些新特性都是Java语言的生命之所在。官方从这个版本开始，在正式文档与宣传上都不再使用类似JDK 1.5的命名，而是使用JDK 5，JDK 6，JDK 7…。只有在程序员内部使用的开发版本号（例如java-version的输出）中才继续沿用1.5，1.6，1.7的版本号。</p><p>2006年12月11日，工程代号为Mustang（野马）的JDK 6发布。在这个版本中，Sun公司终结了从JDK 1.2开始已经有8年历史的J2EE、J2SE、J2ME的命名方式，启用Java SE、Java EE、Java ME的命名方式。同年11月13日的JavaOne大会上，Sun公司宣布将Java开源，并建立OpenJDK组织对开源代码进行管理。</p><p>2009年2月19日，工程代号为Dolphin（海豚）的JDK 7的第一个版本发布。JDK 7本应是一个包含许多重要改进的版本，JDK 8中的Lambda项目原本计划安排在JDK 7中发布，但由于各种商业原因，Sun公司无力进行JDK 7的研发工作。同年4月20日，Oracle公司收购Sun公司，将很多未实现的改进进行裁剪延期，以保证JDK 7的正式版能够在2011年7月28日准时发布。</p><p>2011年7月28日，Oracle公司发布工程代号为Dolphin（海豚）的JDK 7正式版。</p><p>2014年3月18日，Oracle公司发布工程代号为Spider（蜘蛛）的JDK 8。</p><p>2017年9月21日，Oracle公司发布JDK 9。</p><h3 id="Java-8的新特性列表"><a href="#Java-8的新特性列表" class="headerlink" title="Java 8的新特性列表"></a>Java 8的新特性列表</h3><ul><li>Lambda表达式和方法引用</li><li>流处理StreamAPI</li><li>默认方法</li><li>Optional类</li><li>CompletableFuture接口</li><li>新的日期时间API</li></ul><h2 id="第二章：通过行为参数化传递代码"><a href="#第二章：通过行为参数化传递代码" class="headerlink" title="第二章：通过行为参数化传递代码"></a>第二章：通过行为参数化传递代码</h2><ol><li>行为参数化，就是一个方法接受多个不同的行为作为参数，并在内部使用它们，完成不同行为的能力。</li><li>行为参数化可让代码更好地适应不断变化的要求，减轻未来的工作量。</li><li>传递代码，就是将新行为作为参数传递给方法。但在Java 8之前这实现起来很啰嗦。为接口声明许多只用一次的实体类而造成的啰嗦代码，在Java 8之前可以用匿名类来减少。</li><li>Java API包含很多可以用不同行为进行参数化的方法，包括排序、线程和GUI处理。</li></ol><h2 id="第三章：Lambda表达式"><a href="#第三章：Lambda表达式" class="headerlink" title="第三章：Lambda表达式"></a>第三章：Lambda表达式</h2><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口就是只定义一个抽象方法的接口。<br>接口现在还可以拥有默认方法（即在类没有对方法进行实现时，其主体为方法提供默认实现的方法）。<br>哪怕有很多默认方法，只要接口只定义了一个抽象方法，它就仍然是一个函数式接口。</p><p>函数式接口的抽象方法的签名称为函数描述符。</p><h3 id="Java8-内置四大核心函数式接口"><a href="#Java8-内置四大核心函数式接口" class="headerlink" title="Java8 内置四大核心函数式接口"></a>Java8 内置四大核心函数式接口</h3><p>java.util.function包下：</p><ol><li>消费型接口：<code>Consumer&lt;T&gt; {void accept(T t);}</code></li><li>供给型接口：<code>Supplier&lt;T&gt; {T get();}</code></li><li>函数型接口：<code>Function&lt;T,R&gt; {R apply(T t);}</code></li><li>断言型接口：<code>Predicate&lt;T&gt; {boolean test(T t);}</code></li></ol><h3 id="原始类型特化函数式接口"><a href="#原始类型特化函数式接口" class="headerlink" title="原始类型特化函数式接口"></a>原始类型特化函数式接口</h3><p>为了避免装箱操作，对<code>Predicate&lt;T&gt;</code>和<code>Function&lt;T, R&gt;</code>等通用函数式接口的原始类型特化：<code>IntPredicate</code>、<code>IntToLongFunction</code>等。 </p><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>如果一个Lambda代表的只是“直接调用这个方法”，那好还是用名称来调用它，而不是去描述如何调用它。</p><h4 id="如何构建方法引用"><a href="#如何构建方法引用" class="headerlink" title="如何构建方法引用"></a>如何构建方法引用</h4><p>方法引用主要有三类。 </p><p>(1) 指向静态方法的方法引用（例如Integer的parseInt方法，写作<code>Integer::parseInt</code>）。</p><p>(2) 指向任意类型实例方法的方法引用（例如String 的 length 方法，写作<code>String::length</code>）。</p><p>(3) 指向现有对象的实例方法的方法引用（假设你有一个局部变量<code>expensiveTransaction</code>用于存放<code>Transaction</code>类型的对象，它支持实例方法getValue，那么你就可以写<code>expensive- Transaction::getValue</code>）。</p><h4 id="将Lambda表达式重构为等价的方法引用"><a href="#将Lambda表达式重构为等价的方法引用" class="headerlink" title="将Lambda表达式重构为等价的方法引用"></a>将Lambda表达式重构为等价的方法引用</h4><p>(1) Lambda：<code>(args) -&gt; ClassName.staticMethod(args)</code></p><p>等价的方法引用为：<code>ClassName::staticMethod</code>。</p><p>(2) Lambda：<code>(arg0,test) -&gt; arg0.instanceMethod(test)</code></p><p>等价的方法引用为：<code>ClassName::instanceMethod</code>，其中arg0的类型是ClassName。</p><p>(3) Lambda：<code>(args) -&gt; expr.instanceMethod(args)</code></p><p>等价的方法引用为：<code>expr::instanceMethod</code>。</p>]]></content>
    
    <summary type="html">
    
      第一部分：Java 8基础知识
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://lilu.org.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java 8实战" scheme="https://lilu.org.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java-8%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Java8" scheme="https://lilu.org.cn/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>分库分表中间件之ShardingSphere-入门案例</title>
    <link href="https://lilu.org.cn/2019/12/12/middleware/sharding-sphere/sharding-jdbc-introduction/"/>
    <id>https://lilu.org.cn/2019/12/12/middleware/sharding-sphere/sharding-jdbc-introduction/</id>
    <published>2019-12-12T13:35:47.458Z</published>
    <updated>2019-12-12T13:08:37.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ShardingSphere的前尘往事"><a href="#ShardingSphere的前尘往事" class="headerlink" title="ShardingSphere的前尘往事"></a>ShardingSphere的前尘往事</h2><p>ShardingSphere的前身是Sharding-JDBC，起源于当当网内部应用框架，于2016年初开源。</p><p>2017年，Sharding-JDBC进入2.x阶段，核心功能是数据库治理。</p><p>2018年春节前夕，Sharding-JDBC团队于京东数科重新组建，并将其定位为面向云原生的数据库中间件，正式更名为ShardingSphere。Sharding-JDBC进入了3.x时代，功能重心转向了Sharding-proxy及分布式事务上。</p><p>美国时间2018年11月10日，分布式数据库中间件生态圈 ShardingSphere正式进入Apache基金会孵化器。</p><p>预祝ShardingSphere项目早日成功毕业。</p><h2 id="Apache-ShardingSphere简介"><a href="#Apache-ShardingSphere简介" class="headerlink" title="Apache ShardingSphere简介"></a>Apache ShardingSphere简介</h2><p>Apache ShardingSphere (Incubator) 是一套开源的分布式数据库中间件解决方案组成的生态圈，它由Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar（规划中）这3款相互独立，却又能够混合部署配合使用的产品组成。它们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如Java同构、异构语言、云原生等各种多样化的应用场景。</p><p>Apache官方发布从4.0.0版本开始。</p><p><a href="https://shardingsphere.apache.org/document/current/cn/overview/" target="_blank" rel="noopener">Apache ShardingSphere官方文档</a></p><h2 id="Sharding-JDBC简介"><a href="#Sharding-JDBC简介" class="headerlink" title="Sharding-JDBC简介"></a>Sharding-JDBC简介</h2><p>定位为轻量级Java框架，在Java的JDBC层提供的额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。</p><h2 id="Sharding-JDBC快速入门"><a href="#Sharding-JDBC快速入门" class="headerlink" title="Sharding-JDBC快速入门"></a>Sharding-JDBC快速入门</h2><p>我们以一库两表的案例来快速入门。</p><h3 id="建立数据表"><a href="#建立数据表" class="headerlink" title="建立数据表"></a>建立数据表</h3><p>这里我们以简单的订单表为例，作为入门学习使用。</p><p>首先建立一库两表的数据库结构。数据库名为sharding_jdbc_db，建立t_order_1和t_order_2两张表。</p><p>建表sql语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 分表结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> t_order_1;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> t_order_2;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`sharding_jdbc_db`</span>.<span class="string">`t_order_1`</span>  (</span><br><span class="line">  <span class="string">`order_id`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'主键：订单id'</span>,</span><br><span class="line">  <span class="string">`price`</span> <span class="built_in">decimal</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'订单金额'</span>,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户id'</span>,</span><br><span class="line">  <span class="string">`status`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'订单状态'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`order_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`sharding_jdbc_db`</span>.<span class="string">`t_order_2`</span>  (</span><br><span class="line">  <span class="string">`order_id`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'主键：订单id'</span>,</span><br><span class="line">  <span class="string">`price`</span> <span class="built_in">decimal</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'订单金额'</span>,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户id'</span>,</span><br><span class="line">  <span class="string">`status`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'订单状态'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`order_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8;</span><br></pre></td></tr></table></figure><h3 id="创建sharding-jdbc-simple项目"><a href="#创建sharding-jdbc-simple项目" class="headerlink" title="创建sharding-jdbc-simple项目"></a>创建sharding-jdbc-simple项目</h3><p>使用IDEA创建一个maven的空模板项目，项目名为sharding-jdbc-simple。</p><p>在pom.xml文件中需添加的sharding-jdbc-spring-boot-starter依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- apache sharding-jdbc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0-RC1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于我的项目使用了自己定义的统一依赖管理，所以没有指定各个jar包的版本号。</p><p>读者可以参考 <a href="https://github.com/sunchaser-lilu/plaid-umbrella/tree/master/sunchaser-boot-dependencies" target="_blank" rel="noopener">sunchaser-boot-dependencies</a> 进行实现，或者单独指定对应版本号。</p><p>完整的pom.xml内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>中间件<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sunchaser<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sunchaser.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sunchaser-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- sharding-jdbc依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- test依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- web依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- mybatis依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- druid连接池 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- mysql驱动 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- lombok --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h3><p>springboot项目可使用properties配置或yaml配置。二选一即可。</p><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>配置tomcat端口号、应用名和允许重复定义的bean进行覆盖。</p><p>properties配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">520</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">sharding-jdbc-simple-demo</span></span><br><span class="line"><span class="comment"># 重复的bean定义进行覆盖</span></span><br><span class="line"><span class="meta">spring.main.allow-bean-definition-overriding</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>yaml配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">520</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sharding-jdbc-simple-demo</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="comment"># 重复的bean会进行覆盖</span></span><br><span class="line">    <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="配置mybatis"><a href="#配置mybatis" class="headerlink" title="配置mybatis"></a>配置mybatis</h4><p>主要配置xml文件映射路径和下划线自动转驼峰。</p><p>properties配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########################################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     mybatis配置</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#########################################################################</span></span><br><span class="line"><span class="comment"># xml映射文件路径</span></span><br><span class="line"><span class="meta">mybatis.mapper-locations</span>=<span class="string">classpath:mapper/**/*.xml</span></span><br><span class="line"><span class="comment"># 下划线自动转驼峰</span></span><br><span class="line"><span class="meta">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>yaml配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="comment"># xml映射文件路径</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/**/*.xml</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment"># 自动转驼峰</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h4><p>此入门案例是一库两表，只有一个数据源需要配置。</p><p>properties配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########################################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     数据源配置</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#########################################################################</span></span><br><span class="line"><span class="comment"># 数据源名称，多数据源以逗号分隔</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.names</span>=<span class="string">ds1</span></span><br><span class="line"><span class="comment"># 数据源ds1详情配置</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/sharding_jdbc_db?useUnicode=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.password</span>=<span class="string">ll970722</span></span><br></pre></td></tr></table></figure><p>yaml配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 数据源配置</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="comment"># 数据源名称，多数据源以逗号分隔</span></span><br><span class="line">      <span class="attr">names:</span> <span class="string">ds1</span></span><br><span class="line">      <span class="comment"># 数据源ds1详情配置</span></span><br><span class="line">      <span class="attr">ds1:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/sharding_jdbc_db?useUnicode=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">ll970722</span></span><br></pre></td></tr></table></figure><h4 id="配置分片规则"><a href="#配置分片规则" class="headerlink" title="配置分片规则"></a>配置分片规则</h4><p>使用默认的inline表达式配置分片策略，分片策略包含分片键和分片算法，需符合groovy语法。</p><p>properties配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分片规则配置</span></span><br><span class="line"><span class="comment"># 真实数据节点，由数据源名 + 表名组成，以小数点分隔</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.actual-data-nodes</span>=<span class="string">ds1.t_order_$-&gt;&#123;1..2&#125;</span></span><br><span class="line"><span class="comment"># 主键列名称，缺省表示不使用自增主键生成器</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.key-generator.column</span>=<span class="string">order_id</span></span><br><span class="line"><span class="comment"># 自增列值生成器类型，缺省表示使用默认自增列值生成器。</span></span><br><span class="line"><span class="comment"># 可使用自定义的列值生成器或选择内置类型：SNOWFLAKE/UUID/LEAF_SEGMENT</span></span><br><span class="line"><span class="comment"># 这里使用SNOWFLAKE雪花算法</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.key-generator.type</span>=<span class="string">SNOWFLAKE</span></span><br><span class="line"><span class="comment"># 分片策略（分片键和分片算法）</span></span><br><span class="line"><span class="comment"># 分片键</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.table-strategy.inline.sharding-column</span>=<span class="string">order_id</span></span><br><span class="line"><span class="comment"># 分片算法 生成的ID为奇数，插入到t_order_2中，偶数则插入到t_order_1中</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.table-strategy.inline.algorithm-expression</span>=<span class="string">t_order_$-&gt;&#123;order_id % 2 + 1&#125;</span></span><br></pre></td></tr></table></figure><p>yaml配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="comment"># sharding-jdbc分片规则配置</span></span><br><span class="line">    <span class="attr">sharding:</span></span><br><span class="line">      <span class="attr">tables:</span></span><br><span class="line">        <span class="attr">t_order:</span></span><br><span class="line">          <span class="comment"># 数据节点</span></span><br><span class="line">          <span class="attr">actual-data-nodes:</span> <span class="string">ds1.t_order_$-&gt;&#123;1..2&#125;</span></span><br><span class="line">          <span class="comment"># 主键列和主键生成策略：雪花算法</span></span><br><span class="line">          <span class="attr">key-generator:</span></span><br><span class="line">            <span class="attr">column:</span> <span class="string">order_id</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">SNOWFLAKE</span></span><br><span class="line">          <span class="comment"># 分片策略</span></span><br><span class="line">          <span class="attr">table-strategy:</span></span><br><span class="line">            <span class="attr">inline:</span></span><br><span class="line">              <span class="comment"># 分片键</span></span><br><span class="line">              <span class="attr">sharding-column:</span> <span class="string">order_id</span></span><br><span class="line">              <span class="comment"># 分片算法：生成的ID为奇数，插入到t_order_2中，偶数则插入到t_order_1中</span></span><br><span class="line">              <span class="attr">algorithm-expression:</span> <span class="string">t_order_$-&gt;&#123;order_id</span> <span class="string">%</span> <span class="number">2</span> <span class="string">+</span> <span class="number">1</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="配置日志相关"><a href="#配置日志相关" class="headerlink" title="配置日志相关"></a>配置日志相关</h4><p>配置打印执行的真实sql与日志级别。</p><p>properties配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印sharding-jdbc的真实执行sql日志</span></span><br><span class="line"><span class="meta">spring.shardingsphere.props.sql.show</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 日志级别配置</span></span><br><span class="line"><span class="meta">logging.level.root</span>=<span class="string">info</span></span><br><span class="line"><span class="meta">logging.level.org.springframework.web</span>=<span class="string">info</span></span><br><span class="line"><span class="meta">logging.level.com.sunchaser.shardingjdbc</span>=<span class="string">debug</span></span><br><span class="line"><span class="meta">logging.level.druid.sql</span>=<span class="string">debug</span></span><br></pre></td></tr></table></figure><p>yaml配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">sql:</span></span><br><span class="line">        <span class="comment"># 打印sharding-jdbc的真实执行sql日志</span></span><br><span class="line">        <span class="attr">show:</span> <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 日志级别</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">info</span></span><br><span class="line">    <span class="attr">org:</span></span><br><span class="line">      <span class="attr">springframework:</span></span><br><span class="line">        <span class="attr">web:</span> <span class="string">info</span></span><br><span class="line">    <span class="attr">com:</span></span><br><span class="line">      <span class="attr">sunchaser:</span></span><br><span class="line">        <span class="attr">shardingjdbc:</span> <span class="string">debug</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">sql:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><p>至此，配置部分完成，开始编写后端代码。</p><h3 id="后端测试代码编写"><a href="#后端测试代码编写" class="headerlink" title="后端测试代码编写"></a>后端测试代码编写</h3><p>项目包结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">└─src</span><br><span class="line">    ├─main</span><br><span class="line">    │  ├─java</span><br><span class="line">    │  │  └─com</span><br><span class="line">    │  │      └─sunchaser</span><br><span class="line">    │  │          └─shardingjdbc  ------ 存放启动类</span><br><span class="line">    │  │              ├─entity  -------- 存放实体类</span><br><span class="line">    │  │              └─mapper  -------- 存放mapper接口</span><br><span class="line">    │  └─resources</span><br><span class="line">    │      ├─db  ----------------------- 存放建表语句</span><br><span class="line">    │      └─mapper  ------------------- 存放xml映射文件</span><br><span class="line">    └─test</span><br><span class="line">        └─java</span><br><span class="line">            └─com</span><br><span class="line">                └─sunchaser</span><br><span class="line">                    └─shardingjdbc</span><br><span class="line">                        └─mapper  ------ 存放单元测试类</span><br></pre></td></tr></table></figure><p>入门案例主要是使用Sharding-JDBC进行新增和查询，mybatis的mapper接口和xml映射文件编写方式保持不变。</p><h4 id="编写启动类"><a href="#编写启动类" class="headerlink" title="编写启动类"></a>编写启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.shardingjdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.WebApplicationType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/11/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingJdbcSimpleApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(ShardingJdbcSimpleApplication<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">web</span>(<span class="title">WebApplicationType</span>.<span class="title">SERVLET</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">run</span>(<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写订单实体类"><a href="#编写订单实体类" class="headerlink" title="编写订单实体类"></a>编写订单实体类</h4><p>使用lombok工具包的@Data和@Builder注解生成getter、setter和建造者模式代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.shardingjdbc.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/11/29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单id：雪花算法生成的分布式唯一ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long orderId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写mapper接口"><a href="#编写mapper接口" class="headerlink" title="编写mapper接口"></a>编写mapper接口</h4><ol><li>插入订单（注解实现）</li><li>根据订单ID的集合查询订单信息集合（注解实现）</li><li>根据订单ID的集合查询订单信息集合（XML实现）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.shardingjdbc.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sunchaser.shardingjdbc.entity.OrderEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/11/28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> orderEntity 订单实体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 影响记录行数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into t_order(price,user_id,status) values(#&#123;price&#125;,#&#123;userId&#125;,#&#123;status&#125;)"</span>)</span><br><span class="line">    <span class="function">Integer <span class="title">insert</span><span class="params">(OrderEntity orderEntity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解实现</span></span><br><span class="line"><span class="comment">     * 根据订单id集合查询订单集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> orderIds 订单ID集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 订单集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">" &lt;script&gt; "</span> +</span><br><span class="line">            <span class="string">" select * from t_order t where t.order_id in "</span> +</span><br><span class="line">            <span class="string">" &lt;foreach collection='orderIds' open='(' separator=',' close=')' item='orderId'&gt; "</span> +</span><br><span class="line">            <span class="string">" #&#123;orderId&#125; "</span> +</span><br><span class="line">            <span class="string">" &lt;/foreach&gt; "</span> +</span><br><span class="line">            <span class="string">" &lt;/script&gt; "</span>)</span><br><span class="line">    <span class="function">List&lt;OrderEntity&gt; <span class="title">selectByAnnotation</span><span class="params">(@Param(<span class="string">"orderIds"</span>)</span> List&lt;Long&gt; orderIds)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * xml 实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> orderIds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;OrderEntity&gt; <span class="title">selectByXml</span><span class="params">(@Param(<span class="string">"orderIds"</span>)</span> List&lt;Long&gt; orderIds)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OrderMapper的selectByXml方法对应的XML配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.sunchaser.shardingjdbc.mapper.OrderMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectByXml"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">resultType</span>=<span class="string">"com.sunchaser.shardingjdbc.entity.OrderEntity"</span>&gt;</span></span><br><span class="line">        select * from t_order where order_id in</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">'orderIds'</span> <span class="attr">item</span>=<span class="string">'orderId'</span> <span class="attr">open</span>=<span class="string">'('</span> <span class="attr">separator</span>=<span class="string">','</span> <span class="attr">close</span>=<span class="string">')'</span>&gt;</span></span><br><span class="line">            #&#123;orderId&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="编写单元测试代码"><a href="#编写单元测试代码" class="headerlink" title="编写单元测试代码"></a>编写单元测试代码</h4><p>首先循环调用OrderMapper的insert方法插入20条订单数据，然后分别选择同一个订单表的两个订单orderId和选择不同订单表的两个orderId进行<code>in</code>查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.shardingjdbc.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"><span class="keyword">import</span> com.sunchaser.shardingjdbc.entity.OrderEntity;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/11/28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">OrderMapperTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            OrderEntity orderEntity = OrderEntity.builder()</span><br><span class="line">                    .price(<span class="keyword">new</span> BigDecimal(<span class="string">"1.11"</span>))</span><br><span class="line">                    .userId(<span class="string">"2019xxxxxxxx"</span>)</span><br><span class="line">                    .status(<span class="string">"SUCCESS"</span>)</span><br><span class="line">                    .build();</span><br><span class="line">            Integer success = orderMapper.insert(orderEntity);</span><br><span class="line">            System.out.println(success);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectByAnnotation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Long&gt; orderIds = Lists.newArrayList(<span class="number">406907714078244865L</span>,<span class="number">407114454203891712L</span>);</span><br><span class="line">        List&lt;OrderEntity&gt; orderEntities = orderMapper.selectByAnnotation(orderIds);</span><br><span class="line">        System.out.println(orderEntities);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectByXml</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Long&gt; orderIds = Lists.newArrayList(<span class="number">406907714078244865L</span>,<span class="number">407114454203891712L</span>);</span><br><span class="line">        List&lt;OrderEntity&gt; orderEntities = orderMapper.selectByXml(orderIds);</span><br><span class="line">        System.out.println(orderEntities);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于前面配置了sql日志打印，我们可在控制台看到执行的逻辑SQL和真实SQL。</p><p>以查询方法selectByAnnotation为例，执行日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2019-12-12 11:05:36.399 DEBUG 17328 --- [           main] c.s.s.m.OrderMapper.selectByAnnotation   : &#x3D;&#x3D;&gt;  Preparing: select * from t_order t where t.order_id in ( ? , ? ) </span><br><span class="line">2019-12-12 11:05:36.459 DEBUG 17328 --- [           main] c.s.s.m.OrderMapper.selectByAnnotation   : &#x3D;&#x3D;&gt; Parameters: 406907714078244865(Long), 407114454203891712(Long)</span><br><span class="line">2019-12-12 11:05:37.778  INFO 17328 --- [           main] ShardingSphere-SQL                       : Rule Type: sharding</span><br><span class="line">2019-12-12 11:05:37.783  INFO 17328 --- [           main] ShardingSphere-SQL                       : Logic SQL: select * from t_order t where t.order_id in   (    ?   ,   ?   )</span><br><span class="line">2019-12-12 11:05:37.784  INFO 17328 --- [           main] ShardingSphere-SQL                       : SQLStatement: SelectStatement(super&#x3D;DQLStatement(super&#x3D;AbstractSQLStatement(type&#x3D;DQL, tables&#x3D;Tables(tables&#x3D;[Table(name&#x3D;t_order, alias&#x3D;Optional.of(t))]), routeConditions&#x3D;Conditions(orCondition&#x3D;OrCondition(andConditions&#x3D;[AndCondition(conditions&#x3D;[Condition(column&#x3D;Column(name&#x3D;order_id, tableName&#x3D;t_order), operator&#x3D;IN, compareOperator&#x3D;null, positionValueMap&#x3D;&#123;&#125;, positionIndexMap&#x3D;&#123;0&#x3D;0, 1&#x3D;1&#125;)])])), encryptConditions&#x3D;Conditions(orCondition&#x3D;OrCondition(andConditions&#x3D;[])), sqlTokens&#x3D;[TableToken(tableName&#x3D;t_order, quoteCharacter&#x3D;NONE, schemaNameLength&#x3D;0)], parametersIndex&#x3D;2, logicSQL&#x3D;select * from t_order t where t.order_id in   (    ?   ,   ?   ))), containStar&#x3D;true, firstSelectItemStartIndex&#x3D;7, selectListStopIndex&#x3D;7, groupByLastIndex&#x3D;0, items&#x3D;[StarSelectItem(owner&#x3D;Optional.absent())], groupByItems&#x3D;[], orderByItems&#x3D;[], limit&#x3D;null, subqueryStatement&#x3D;null, subqueryStatements&#x3D;[], subqueryConditions&#x3D;[])</span><br><span class="line">2019-12-12 11:05:37.786  INFO 17328 --- [           main] ShardingSphere-SQL                       : Actual SQL: ds1 ::: select * from t_order_1 t where t.order_id in   (    ?   ,   ?   ) ::: [406907714078244865, 407114454203891712]</span><br><span class="line">2019-12-12 11:05:37.786  INFO 17328 --- [           main] ShardingSphere-SQL                       : Actual SQL: ds1 ::: select * from t_order_2 t where t.order_id in   (    ?   ,   ?   ) ::: [406907714078244865, 407114454203891712]</span><br><span class="line">2019-12-12 11:05:38.062 DEBUG 17328 --- [           main] c.s.s.m.OrderMapper.selectByAnnotation   : &lt;&#x3D;&#x3D;      Total: 2</span><br><span class="line">[OrderEntity(orderId&#x3D;407114454203891712, price&#x3D;1.11, userId&#x3D;2019xxxxxxxx, status&#x3D;SUCCESS), OrderEntity(orderId&#x3D;406907714078244865, price&#x3D;1.11, userId&#x3D;2019xxxxxxxxxxxxxxx, status&#x3D;SUCCESS)]</span><br></pre></td></tr></table></figure><p>可看到执行的Logic SQL为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_order t <span class="keyword">where</span> t.order_id <span class="keyword">in</span> ( ? , ? )</span><br></pre></td></tr></table></figure><p>Sharding-JDBC的路由引擎根据解析上下文匹配数据库和表的分片策略，路由到具体的库和表。再经过改写引擎，将逻辑SQL改写为真正执行的SQL。</p><p>从日志中可看到改写后的Actual SQL为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_order_1 t <span class="keyword">where</span> t.order_id <span class="keyword">in</span>   (    ?   ,   ?   ) ::: [<span class="number">406907714078244865</span>, <span class="number">407114454203891712</span>]</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_order_2 t <span class="keyword">where</span> t.order_id <span class="keyword">in</span>   (    ?   ,   ?   ) ::: [<span class="number">406907714078244865</span>, <span class="number">407114454203891712</span>]</span><br></pre></td></tr></table></figure><p>结果归并，真实的SQL执行后会返回多个结果集，归并引擎从各个数据节点拿到结果集后组合成一个结果集并返回给客户端。</p><p>至此，入门案例就演示结束。源码地址：<a href="https://github.com/sunchaser-lilu/gold-road-to-Java/tree/master/%E4%B8%AD%E9%97%B4%E4%BB%B6/sharding-jdbc-simple" target="_blank" rel="noopener">传送门</a></p><p>下一篇文章将对Sharding-JDBC中的一些核心概念进行具体的解释。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这篇文章主要是对Apache ShardingSphere 4.x与Spring Boot 2.1.x进行整合，使用了内置的SNOWFLAKE雪花算法生成分布式全局唯一ID和使用默认的inline表达式配置分片策略，完成了最简单的一库两表的分库分表，并对新增和查询操作进行了测试。</p>]]></content>
    
    <summary type="html">
    
      分库分表中间件之ShardingSphere-入门案例
    
    </summary>
    
    
      <category term="中间件" scheme="https://lilu.org.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="分库分表" scheme="https://lilu.org.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
    
      <category term="Apache ShardingSphere" scheme="https://lilu.org.cn/tags/Apache-ShardingSphere/"/>
    
  </entry>
  
  <entry>
    <title>“煮熟的鸭子也会飞？”- 使用策略模式让你的“鸭子”飞起来</title>
    <link href="https://lilu.org.cn/2019/12/12/design-patterns/behavior/strategy/"/>
    <id>https://lilu.org.cn/2019/12/12/design-patterns/behavior/strategy/</id>
    <published>2019-12-12T12:49:55.830Z</published>
    <updated>2019-12-12T13:05:41.374Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模拟鸭子的问题"><a href="#模拟鸭子的问题" class="headerlink" title="模拟鸭子的问题"></a>模拟鸭子的问题</h2><p>问题描述：用代码模拟现实中的鸭子，鸭子有很多种类，会发出各种叫声，有的会游泳。</p><h2 id="传统设计方案"><a href="#传统设计方案" class="headerlink" title="传统设计方案"></a>传统设计方案</h2><p>传统方案：使用标准的面向对象设计。设计一个<code>Duck</code>超类，让不同种类的鸭子继承该超类。</p><p>传统方案的类图设计如下：<br><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/YgU95kXfjRz7OoM.png"  alt="traditionalDuckUML.png"></p><p>代码示例如下：</p><p><code>Duck</code>超类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy.traditional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 传统鸭子问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 其它鸭子都继承了Duck类，所以fly方法让所有的子类鸭子都会飞，但并不是所有鸭子都会飞。</span></span><br><span class="line"><span class="comment"> * 2. 实际上这是继承带来的问题，对父类的局部改动，会影响所有子类。称为溢出效应。</span></span><br><span class="line"><span class="comment"> * 3. 为了解决继承带来的问题，我们可以在子类中重写对应的方法来解决。</span></span><br><span class="line"><span class="comment"> * 4. 但是如果有一个玩具鸭类，它需要重写父类所有的方法，这样做的代价有点大。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示鸭子信息的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 鸭子叫的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鸭子嘎嘎叫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 鸭子游泳的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鸭子会游泳"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 鸭子飞翔的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鸭子会飞翔"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>野鸭<code>WildDuck</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy.traditional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 野鸭：嘎嘎叫、会游泳和飞翔</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一只野鸭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>北京鸭<code>PekingDuck</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy.traditional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 北京鸭：不会飞翔</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PekingDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一只北京鸭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"北京鸭不会飞翔"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>玩具鸭<code>ToyDuck</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy.traditional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 玩具鸭：不会嘎嘎叫、不会游泳和飞翔。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToyDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一只玩具鸭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"玩具鸭不能叫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"玩具鸭不会游泳"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"玩具鸭不会飞翔"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超类<code>Duck</code>中定义了3个实现方法，一个抽象方法。</p><p>子类野鸭WildDuck类会“嘎嘎叫”、“游泳”和“飞翔”。所以野鸭类只需实现抽象方法display即可。</p><p>子类北京鸭PekingDuck类不会飞翔，除了实现抽象方法之外还需重写父类的fly方法。</p><p>子类玩具鸭ToyDuck类不会叫、不会游泳也不会飞翔。所以玩具鸭类除了实现抽象方法，还要重写父类的三个方法。</p><p>这种继承的设计思路似乎没有任何问题。但事实上子类重写父类方法的代价是很高的，一旦出现一个新品种的鸭子，就要去继承<code>Duck</code>类，子类默认就有了父类定义好的行为，例如“嘎嘎叫”、“游泳”和“飞翔”。如果子类不满足这些行为就要去重写父类中对应的方法。同时，一旦对父类进行某些局部改动，所有子类都会受到影响。</p><p>我们知道Duck类内的fly()和quack()会随着鸭子的不同而改变。事实上每次继承都是在改动这两个方法。</p><p>不妨使用策略模式来改造<code>Duck</code>类。</p><blockquote><p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p></blockquote><p>策略模式中有以下三条设计原则：</p><ul><li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li><li>针对接口编程，而不是针对实现编程。</li><li>多用组合，少用继承。</li></ul><h2 id="分离行为-—-让“煮熟的鸭子”飞起来"><a href="#分离行为-—-让“煮熟的鸭子”飞起来" class="headerlink" title="分离行为 — 让“煮熟的鸭子”飞起来"></a>分离行为 — 让“煮熟的鸭子”飞起来</h2><p>是时候将行为从Duck类中分离出来了。将鸭子的行为封装到新的类中，该类专门提供某行为的实现。这样，Duck类就不再需要知道行为的具体实现。</p><p>那么如何设计实现“飞翔”和“嘎嘎叫”的行为的类呢？我们希望“煮熟的鸭子飞起来”，鸭子需要经历从生到熟这个过程，我们要做的是在Duck类中增加设定行为的方法，这样就能在“运行时期”动态改变鸭子的行为。</p><p>使用了策略模式的类图设计如下：<br><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/3hz8VipoP5ZYW9s.png"  alt="strategyDuckUML.png"></p><p>代码示例如下：</p><p>“飞翔”行为接口<code>FlyBehavior</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 飞翔行为接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 飞翔的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随风飞翔的行为<code>FlyWithWings</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.FlyBehavior;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 可以飞的行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWithWings</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fly with wings"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能飞的行为<code>FlyNoWay</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.FlyBehavior;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 不能飞的行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyNoWay</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"can't fly"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用火箭动力飞翔的行为<code>FlyRocketPowered</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.FlyBehavior;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 利用火箭动力的飞翔行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyRocketPowered</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fly with rocket"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“叫”的行为接口<code>QuackBehavior</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 鸭子叫行为接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QuackBehavior</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 鸭子叫的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嘎嘎叫的行为<code>Quack</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.QuackBehavior;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 嘎嘎叫的行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quack</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Quack 嘎嘎叫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>吱吱叫的行为<code>Squeak</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.QuackBehavior;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 吱吱叫的行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Squeak</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Squeak 吱吱叫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不会叫的行为<code>MuteQuack</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.QuackBehavior;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 不会叫的行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MuteQuack</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Silence 不会叫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分离行为后的<code>Duck</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 使用策略模式的鸭子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 飞翔的行为</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FlyBehavior flyBehavior;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 叫的行为</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    QuackBehavior quackBehavior;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置飞行行为</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flyBehavior 飞行行为</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlyBehavior</span><span class="params">(FlyBehavior flyBehavior)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flyBehavior = flyBehavior;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置叫的行为</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> quackBehavior 叫行为</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuackBehavior</span><span class="params">(QuackBehavior quackBehavior)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.quackBehavior = quackBehavior;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使鸭子飞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performFly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flyBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">            flyBehavior.fly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使鸭子叫</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performQuack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (quackBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">            quackBehavior.quack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 鸭子游泳的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鸭子会游泳"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示鸭子信息的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>野鸭<code>WildDuck</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.impl.FlyWithWings;</span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.impl.Quack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 野鸭：具有可以飞的行为和嘎嘎叫的行为。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WildDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 随风飞翔行为</span></span><br><span class="line">        flyBehavior = <span class="keyword">new</span> FlyWithWings();</span><br><span class="line">        <span class="comment">// 嘎嘎叫行为</span></span><br><span class="line">        quackBehavior = <span class="keyword">new</span> Quack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一只使用策略模式的野鸭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>北京鸭<code>PekingDuck</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.impl.FlyNoWay;</span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.impl.Squeak;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 北京鸭：不能飞翔，吱吱叫</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PekingDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PekingDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不能飞的行为</span></span><br><span class="line">        flyBehavior = <span class="keyword">new</span> FlyNoWay();</span><br><span class="line">        <span class="comment">// 吱吱叫的行为</span></span><br><span class="line">        quackBehavior = <span class="keyword">new</span> Squeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一只使用策略模式的北京鸭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>玩具鸭<code>ToyDuck</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.impl.FlyNoWay;</span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.impl.MuteQuack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 玩具鸭：不会飞也不会叫</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToyDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ToyDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不会飞的行为</span></span><br><span class="line">        flyBehavior = <span class="keyword">new</span> FlyNoWay();</span><br><span class="line">        <span class="comment">// 不会叫的行为</span></span><br><span class="line">        quackBehavior = <span class="keyword">new</span> MuteQuack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一只使用策略模式的玩具鸭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一切都准备就绪！让我们来见证“煮熟的鸭子”的飞翔吧！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.impl.FlyRocketPowered;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: for test</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生产一只北京鸭</span></span><br><span class="line">        Duck duck = <span class="keyword">new</span> PekingDuck();</span><br><span class="line">        <span class="comment">// 让鸭子飞</span></span><br><span class="line">        duck.performFly();</span><br><span class="line">        <span class="comment">// 让鸭子叫</span></span><br><span class="line">        duck.performQuack();</span><br><span class="line">        <span class="comment">// 生产一只玩具鸭</span></span><br><span class="line">        Duck toyDuck = <span class="keyword">new</span> ToyDuck();</span><br><span class="line">        <span class="comment">// 让鸭子飞：发现不能飞</span></span><br><span class="line">        toyDuck.performFly();</span><br><span class="line">        <span class="comment">// 动态改变行为：让“煮熟的鸭子”飞起来</span></span><br><span class="line">        toyDuck.setFlyBehavior(<span class="keyword">new</span> FlyRocketPowered());</span><br><span class="line">        toyDuck.performFly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">can&#39;t fly</span><br><span class="line">Squeak 吱吱叫</span><br><span class="line">can&#39;t fly</span><br><span class="line">fly with rocket</span><br></pre></td></tr></table></figure><p>不管怎样，我们的玩具鸭飞起来了，这里玩具鸭和“煮熟的鸭子”性质上是一样的。</p><p>现在我们的<code>Duck</code>类不再担心出现新的鸭子种类了。一旦有一个不同行为的新种类鸭，只需要写一个新的行为接口的实现。而不需要对<code>Duck</code>类进行修改。这体现了“对修改关闭，对扩展开放”原则，客户端增加行为不用修改原有代码，只要添加一种策略即可，避免了使用多重转移语句(if-else…if-else)。同时策略模式的缺点也由此暴露，每添加一个策略就会产生一个新的类，当策略过多时，类的数量会随之过多。但这至少比使用继承时重写父类方法要好的多。</p>]]></content>
    
    <summary type="html">
    
      行为型设计模式之策略模式
    
    </summary>
    
    
      <category term="设计模式" scheme="https://lilu.org.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型" scheme="https://lilu.org.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
    
      <category term="设计模式" scheme="https://lilu.org.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>GoF的23种设计模式</title>
    <link href="https://lilu.org.cn/2019/12/12/design-patterns/GoF&#39;s-23-design-patterns/"/>
    <id>https://lilu.org.cn/2019/12/12/design-patterns/GoF&#39;s-23-design-patterns/</id>
    <published>2019-12-12T12:49:24.643Z</published>
    <updated>2019-12-12T13:05:31.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GoF设计模式简介"><a href="#GoF设计模式简介" class="headerlink" title="GoF设计模式简介"></a>GoF设计模式简介</h2><p>GoF是设计模式的经典名著Design Patterns: Elements of Reusable Object-Oriented Software（中译本名为《设计模式——可复用面向对象软件的基础》）的四位作者，他们分为是：Elich Gamma、Richard Helm、Ralph Johnson、以及John Vlissides。这四个人常被称为Gang of Four， 即四人组，简称GoF。这本书中总结的23种设计模式称为GoF设计模式。</p><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p>设计模式有两种分类方法：根据模式的目的划分和根据模式的作用范围划分。</p><h3 id="根据目的划分"><a href="#根据目的划分" class="headerlink" title="根据目的划分"></a>根据目的划分</h3><p>根据模式是用来完成什么工作来划分，可分为创建型模式、结构型模式和行为型模式。</p><ul><li>创建型模式：用于描述“如何创建对象”，主要特点是“将对象的创建和使用分离”。GoF的创建型模式包括单例模式、原型模式、工厂方法模式、抽象工厂模式和建造者模式。</li><li>结构型模式：用于描述如何将类或对象按某种布局组成更大的结构。GoF的结构型模式包括代理模式、适配器模式、桥接模式、装饰器模式、外观模式、享元模式和组合模式。</li><li>行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF的行为型模式包括责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式和访问者模式。</li></ul><h3 id="根据作用范围划分"><a href="#根据作用范围划分" class="headerlink" title="根据作用范围划分"></a>根据作用范围划分</h3><p>根据模式是主要作用于类上还是主要作用于对象上来划分，可分为类模式和对象模式。</p><ul><li>类模式：用于处理类和子类之间的关系，这些关系通过继承来建立，是静态的，在编译时期就确定了。GoF的类模式包括工厂方法模式、适配器模式（类）、模板方法模式和解释器模式。</li><li>对象模式：用于处理对象之间的关系，这些关系可以通过组合和聚合来实现，在运行时期是可以动态改变的。GoF中除了类模式，其余都是对象模式。</li></ul><p>下表描述了设计模式的分类：</p><table><thead><tr><th>范围\目的</th><th>创建型</th><th>结构型</th><th>行为型</th></tr></thead><tbody><tr><td>类模式</td><td>工厂方法模式</td><td>适配器模式（类）</td><td>模板方法模式<br />解释器模式</td></tr><tr><td>对象模式</td><td>单例模式<br />原型模式<br />抽象工厂模式<br />建造者模式</td><td>代理模式<br />适配器模式（对象）<br />桥接模式<br />装饰器模式<br />外观模式<br />享元模式<br />组合模式</td><td>策略模式<br />命令模式<br />责任链模式<br />状态模式<br />观察者模式<br />中介者模式<br />迭代器模式<br />访问者模式<br />备忘录模式</td></tr></tbody></table><h2 id="GoF的23种设计模式"><a href="#GoF的23种设计模式" class="headerlink" title="GoF的23种设计模式"></a>GoF的23种设计模式</h2><ol><li>单例模式（Singleton）：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li><li>原型模式（Prototype）：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li><li>工厂方法模式（Factory Method）：定义一个用于创建产品的接口，由子类决定生产什么产品。</li><li>抽象工厂模式（AbstractFactory）：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li><li>建造者模式（Builder）：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li><li>代理模式（Proxy）：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li><li>适配器模式（Adapter）：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li><li>桥接模式（Bridge）：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</li><li>装饰模式（Decorator）：动态的给对象增加一些职责，即增加其额外的功能。</li><li>外观模式（Facade）：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li><li>享元模式（Flyweight）：运用共享技术来有效地支持大量细粒度对象的复用。</li><li>组合模式（Composite）：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li><li>模板方法模式（TemplateMethod）：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li><li>策略模式（Strategy）：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li><li>命令模式（Command）：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li><li>职责链模式（Chain of Responsibility）：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li><li>状态模式（State）：允许一个对象在其内部状态发生改变时改变其行为能力。</li><li>观察者模式（Observer）：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li><li>中介者模式（Mediator）：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li><li>迭代器模式（Iterator）：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li><li>访问者模式（Visitor）：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li><li>备忘录模式（Memento）<br>：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复。</li><li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li></ol><p>值得注意的是，这23种设计模式不是孤立存在的，很多模式之间存在一定的关联关系。</p>]]></content>
    
    <summary type="html">
    
      GoF的23种设计模式
    
    </summary>
    
    
      <category term="设计模式" scheme="https://lilu.org.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://lilu.org.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>软件设计模式的概念与意义</title>
    <link href="https://lilu.org.cn/2019/12/12/design-patterns/Design-pattern-overview/"/>
    <id>https://lilu.org.cn/2019/12/12/design-patterns/Design-pattern-overview/</id>
    <published>2019-12-12T12:49:24.640Z</published>
    <updated>2019-12-12T13:05:26.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件设计模式的概念与意义"><a href="#软件设计模式的概念与意义" class="headerlink" title="软件设计模式的概念与意义"></a>软件设计模式的概念与意义</h2><h3 id="设计模式的概念"><a href="#设计模式的概念" class="headerlink" title="设计模式的概念"></a>设计模式的概念</h3><p>设计模式，是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。在很多开源框架中都有设计模式思想的体现，尽管有些设计模式逐渐被编程语言的新语法特性给颠覆，但其设计思想依旧是值得我们学习的。</p><h3 id="设计模式的意义"><a href="#设计模式的意义" class="headerlink" title="设计模式的意义"></a>设计模式的意义</h3><p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。</p><p>学习设计模式有以下意义：</p><ul><li>可以提高思维能力、编程能力和设计能力。</li><li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li><li>有利于阅读一些开源框架源码。</li></ul>]]></content>
    
    <summary type="html">
    
      软件设计模式的概念与意义
    
    </summary>
    
    
      <category term="设计模式" scheme="https://lilu.org.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://lilu.org.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
