<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>《Java 8实战》读书笔记系列——第二部分：函数式数据处理 | 向日葵的自我修养</title><meta name="description" content="第二部分：StreamAPI函数式数据处理"><meta name="keywords" content="Java8"><meta name="author" content="SunChaser,admin@lilu.org.cn"><meta name="copyright" content="SunChaser"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/../assets/images/themes/butterfly/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="crossorigin"/><link rel="preconnect" href="https://hm.baidu.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="《Java 8实战》读书笔记系列——第二部分：函数式数据处理"><meta name="twitter:description" content="第二部分：StreamAPI函数式数据处理"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/lilu.org.cn/cover.png"><meta property="og:type" content="article"><meta property="og:title" content="《Java 8实战》读书笔记系列——第二部分：函数式数据处理"><meta property="og:url" content="https://lilu.org.cn/2019/12/12/reading-notes/java8-in-action/Part-II-Functional-Data-Processing/"><meta property="og:site_name" content="向日葵的自我修养"><meta property="og:description" content="第二部分：StreamAPI函数式数据处理"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/lilu.org.cn/cover.png"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://lilu.org.cn/2019/12/12/reading-notes/java8-in-action/Part-II-Functional-Data-Processing/"><link rel="prev" title="《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（一）：接口重构和新特性" href="https://lilu.org.cn/2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(1)/"><link rel="next" title="《Java 8实战》读书笔记系列——第一部分：基础知识" href="https://lilu.org.cn/2019/12/12/reading-notes/java8-in-action/Part-I-Basics/"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-4923931760030983',
  enable_page_level_ads: 'true'
});</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?20da65740ab8563511ef3339403e6464";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-158613531-1', 'auto');
ga('send', 'pageview');
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://www.lilu.org.cn","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"间"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: SunChaser","link":"链接: ","source":"来源: 向日葵的自我修养","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="向日葵的自我修养" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://i.loli.net/2020/02/15/9iqI5Ug8W2tJBTo.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">44</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#第四章：引入流"><span class="toc-number">1.</span> <span class="toc-text">第四章：引入流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#流的定义"><span class="toc-number">1.1.</span> <span class="toc-text">流的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元素序列"><span class="toc-number">1.2.</span> <span class="toc-text">元素序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源"><span class="toc-number">1.3.</span> <span class="toc-text">源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据处理操作"><span class="toc-number">1.4.</span> <span class="toc-text">数据处理操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#流操作的特点"><span class="toc-number">1.5.</span> <span class="toc-text">流操作的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-流水线"><span class="toc-number">1.5.1.</span> <span class="toc-text">1. 流水线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-内部迭代"><span class="toc-number">1.5.2.</span> <span class="toc-text">2. 内部迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-流只能被消费一次"><span class="toc-number">1.5.3.</span> <span class="toc-text">3. 流只能被消费一次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-对流的操作分为两类：中间操作和终止操作"><span class="toc-number">1.5.4.</span> <span class="toc-text">4. 对流的操作分为两类：中间操作和终止操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合与流的不同点："><span class="toc-number">1.6.</span> <span class="toc-text">集合与流的不同点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第五章：使用流"><span class="toc-number">2.</span> <span class="toc-text">第五章：使用流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-筛选和切片"><span class="toc-number">2.1.</span> <span class="toc-text">1.  筛选和切片</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-用谓词筛选"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 用谓词筛选</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-筛选各异的元素"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 筛选各异的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-截短流"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.3 截短流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-跳过元素"><span class="toc-number">2.1.4.</span> <span class="toc-text">1.4 跳过元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-映射"><span class="toc-number">2.2.</span> <span class="toc-text">2. 映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-对流中每一个元素应用函数"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 对流中每一个元素应用函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-流的扁平化"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2 流的扁平化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-查找和匹配"><span class="toc-number">2.3.</span> <span class="toc-text">3. 查找和匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-检查谓词是否至少匹配一个元素"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1 检查谓词是否至少匹配一个元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-检查谓词是否匹配所有元素"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2 检查谓词是否匹配所有元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-检查谓词是否不匹配所有元素"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.3 检查谓词是否不匹配所有元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-查找元素"><span class="toc-number">2.3.4.</span> <span class="toc-text">3.4 查找元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Optional简介"><span class="toc-number">2.4.</span> <span class="toc-text">Optional简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-查找第一个元素"><span class="toc-number">2.4.1.</span> <span class="toc-text">3.5 查找第一个元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-归约"><span class="toc-number">2.5.</span> <span class="toc-text">4. 归约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-数值流"><span class="toc-number">2.6.</span> <span class="toc-text">5. 数值流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-原始类型流特化"><span class="toc-number">2.6.1.</span> <span class="toc-text">5.1 原始类型流特化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-1-映射到数值流"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">5.1.1 映射到数值流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-2-转换回对象流"><span class="toc-number">2.6.1.2.</span> <span class="toc-text">5.1.2 转换回对象流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-3-默认值OptionalInt"><span class="toc-number">2.6.1.3.</span> <span class="toc-text">5.1.3 默认值OptionalInt</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-数值范围"><span class="toc-number">2.6.2.</span> <span class="toc-text">5.2 数值范围</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-构建流"><span class="toc-number">2.7.</span> <span class="toc-text">6. 构建流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-由值创建流"><span class="toc-number">2.7.1.</span> <span class="toc-text">6.1 由值创建流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-由数组创建流"><span class="toc-number">2.7.2.</span> <span class="toc-text">6.2 由数组创建流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3、由文件生成流"><span class="toc-number">2.7.3.</span> <span class="toc-text">6.3、由文件生成流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-由函数生成流：创建无限流"><span class="toc-number">2.7.4.</span> <span class="toc-text">6.4 由函数生成流：创建无限流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第六章：用流收集数据"><span class="toc-number">3.</span> <span class="toc-text">第六章：用流收集数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-汇总"><span class="toc-number">3.1.</span> <span class="toc-text">1. 汇总</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-连接字符串"><span class="toc-number">3.2.</span> <span class="toc-text">2. 连接字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-分组"><span class="toc-number">3.3.</span> <span class="toc-text">3. 分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-分区"><span class="toc-number">3.4.</span> <span class="toc-text">4. 分区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#分区的好处："><span class="toc-number">3.4.1.</span> <span class="toc-text">分区的好处：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第七章：并行数据处理与性能"><span class="toc-number">4.</span> <span class="toc-text">第七章：并行数据处理与性能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#并行处理数据一定比串行处理快吗？"><span class="toc-number">4.1.</span> <span class="toc-text">并行处理数据一定比串行处理快吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并行流有时候比串行流慢的原因"><span class="toc-number">4.2.</span> <span class="toc-text">并行流有时候比串行流慢的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fork-Join框架"><span class="toc-number">4.3.</span> <span class="toc-text">Fork&#x2F;Join框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工作窃取（work-stealing）算法"><span class="toc-number">4.4.</span> <span class="toc-text">工作窃取（work-stealing）算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#工作窃取算法的优点："><span class="toc-number">4.4.1.</span> <span class="toc-text">工作窃取算法的优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#工作窃取算法的缺点："><span class="toc-number">4.4.2.</span> <span class="toc-text">工作窃取算法的缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fork-Join框架的设计思路"><span class="toc-number">4.5.</span> <span class="toc-text">Fork&#x2F;Join框架的设计思路</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/lilu.org.cn/cover.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">向日葵的自我修养</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">《Java 8实战》读书笔记系列——第二部分：函数式数据处理</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2019-12-12 21:38:35"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-12-12</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2019-12-12 21:04:16"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-12-12</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java-8%E5%AE%9E%E6%88%98/">Java 8实战</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">5.7k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 19 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2019/12/12/reading-notes/java8-in-action/Part-II-Functional-Data-Processing/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2019/12/12/reading-notes/java8-in-action/Part-II-Functional-Data-Processing/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><span style="display: none;">版权所有，禁止爬虫。</span><div class="post-copyright__author" style="display: none;"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:admin@lilu.org.cn">SunChaser</a></span></div><div class="post-copyright__type" style="display: none;"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lilu.org.cn/2019/12/12/reading-notes/java8-in-action/Part-II-Functional-Data-Processing/">https://lilu.org.cn/2019/12/12/reading-notes/java8-in-action/Part-II-Functional-Data-Processing/</a></span></div><div class="post-copyright__notice" style="display: none;"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lilu.org.cn" target="_blank">向日葵的自我修养</a>！</span></div><div id="article-container"><h2 id="第四章：引入流"><a href="#第四章：引入流" class="headerlink" title="第四章：引入流"></a>第四章：引入流</h2><h3 id="流的定义"><a href="#流的定义" class="headerlink" title="流的定义"></a>流的定义</h3><p>从支持数据处理操作的源生成的元素序列。</p>
<h3 id="元素序列"><a href="#元素序列" class="headerlink" title="元素序列"></a>元素序列</h3><p>就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。</p>
<p>因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元素（如ArrayList 与 LinkedList）。</p>
<p>但流的目的在于表达计算，比如前面见到的filter、sorted和map。</p>
<p>集合讲的是数据，流讲的是计算。</p>
<h3 id="源"><a href="#源" class="headerlink" title="源"></a>源</h3><p>流会使用一个提供数据的源，如集合、数组或输入/输出资源。</p>
<p>请注意，从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。</p>
<h3 id="数据处理操作"><a href="#数据处理操作" class="headerlink" title="数据处理操作"></a>数据处理操作</h3><p>流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，</p>
<p>如filter、map、reduce、find、match、sort等。流操作可以顺序执行，也可并行执行。 </p>
<h3 id="流操作的特点"><a href="#流操作的特点" class="headerlink" title="流操作的特点"></a>流操作的特点</h3><h4 id="1-流水线"><a href="#1-流水线" class="headerlink" title="1. 流水线"></a>1. 流水线</h4><p>很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。</p>
<p>这让之后章节中的一些优化成为可能，如延迟和短路。</p>
<p>流水线的操作可以看作对数据源进行数据库式（链式）查询。</p>
<h4 id="2-内部迭代"><a href="#2-内部迭代" class="headerlink" title="2. 内部迭代"></a>2. 内部迭代</h4><p>与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的（内部迭代）。</p>
<h4 id="3-流只能被消费一次"><a href="#3-流只能被消费一次" class="headerlink" title="3. 流只能被消费一次"></a>3. 流只能被消费一次</h4><p>终止操作只能有一次，重复消费会抛出java.lang.IllegalStateException异常。</p>
<h4 id="4-对流的操作分为两类：中间操作和终止操作"><a href="#4-对流的操作分为两类：中间操作和终止操作" class="headerlink" title="4. 对流的操作分为两类：中间操作和终止操作"></a>4. 对流的操作分为两类：中间操作和终止操作</h4><ul>
<li>中间操作总是会惰性执行：执行一个中间操作不会在原流上做任何处理，而是创建一个标记了该操作的新流返回。</li>
<li>终止操作才会进行真实的计算：计算发生时会把所有中间操作积攒的操作以Pipeline的方式执行，这样可以减少迭代次数，计算完成后流即失效。</li>
</ul>
<h3 id="集合与流的不同点："><a href="#集合与流的不同点：" class="headerlink" title="集合与流的不同点："></a>集合与流的不同点：</h3><ul>
<li>无存储：Stream不是一种数据结构，它只是某种数据源的一个视图。数据源可以是一个数组、Java容器或I/O资源等。</li>
<li>为函数式编程而生：对Stream的任何修改都不会修改背后的数据源，比如对一个流执行filter过滤操作并不会删除被过滤的元素，而是会产生一个新的不包含被过滤元素的新流。</li>
<li>惰性执行：对流的中间操作并不会立即执行，只有等一个终止操作来临时才会一次性全部执行。</li>
<li>可消费性：一个流只能被消费一次，一旦产生终止操作，流即被消费。</li>
</ul>
<h2 id="第五章：使用流"><a href="#第五章：使用流" class="headerlink" title="第五章：使用流"></a>第五章：使用流</h2><h3 id="1-筛选和切片"><a href="#1-筛选和切片" class="headerlink" title="1.  筛选和切片"></a>1.  筛选和切片</h3><p>选择流中的元素：用谓词筛选，筛选出各不相同的元素，忽略流 中的头几个元素，或将流截短至指定长度。</p>
<h4 id="1-1-用谓词筛选"><a href="#1-1-用谓词筛选" class="headerlink" title="1.1 用谓词筛选"></a>1.1 用谓词筛选</h4><p>Streams接口支持<code>filter</code>方法。该操作会接受一个谓词（一个返回 boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流。</p>
<h4 id="1-2-筛选各异的元素"><a href="#1-2-筛选各异的元素" class="headerlink" title="1.2 筛选各异的元素"></a>1.2 筛选各异的元素</h4><p>流支持一个叫作<code>distinct</code>的方法，它会返回一个元素各异（根据流所生成元素的 hashCode和equals方法实现）的流。</p>
<h4 id="1-3-截短流"><a href="#1-3-截短流" class="headerlink" title="1.3 截短流"></a>1.3 截短流</h4><p>流支持<code>limit(n)</code>方法，该方法会返回一个不超过给定长度的流。</p>
<p>所需的长度作为参数传递给limit。如果流是有序的，则多会返回前n个元素。</p>
<h4 id="1-4-跳过元素"><a href="#1-4-跳过元素" class="headerlink" title="1.4 跳过元素"></a>1.4 跳过元素</h4><p>流还支持<code>skip(n)</code>方法，返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一个空流。</p>
<p>请注意，<code>limit(n)</code>和<code>skip(n)</code>是互补的。</p>
<h3 id="2-映射"><a href="#2-映射" class="headerlink" title="2. 映射"></a>2. 映射</h3><p>一个非常常见的数据处理套路就是从某些对象中选择信息。</p>
<p>比如在SQL里，你可以从表中选择一列。Stream API也通过<code>map</code>和<code>flatMap</code>方法提供了类似的工具。</p>
<h4 id="2-1-对流中每一个元素应用函数"><a href="#2-1-对流中每一个元素应用函数" class="headerlink" title="2.1 对流中每一个元素应用函数"></a>2.1 对流中每一个元素应用函数</h4><p>流支持<code>map</code>方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，</p>
<p>并将其映射成一个新的元素（使用映射一词，是因为它和转换类似，但其中的细微差别在于它是“创建一个新版本”而不是去“修改”）。</p>
<h4 id="2-2-流的扁平化"><a href="#2-2-流的扁平化" class="headerlink" title="2.2 流的扁平化"></a>2.2 流的扁平化</h4><p>流支持<code>flatMap</code>方法，将各个单独的流合并起来，扁平化成一个流。</p>
<p><code>flatMap</code>方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。</p>
<h3 id="3-查找和匹配"><a href="#3-查找和匹配" class="headerlink" title="3. 查找和匹配"></a>3. 查找和匹配</h3><p>另一个常见的数据处理套路是看看数据集中的某些元素是否匹配一个给定的属性。</p>
<p>Stream API通过<code>anyMatch</code>、<code>allMatch</code>、<code>noneMatch</code>、<code>findAny</code>和<code>findFirst</code>方法提供了这样的工具。</p>
<h4 id="3-1-检查谓词是否至少匹配一个元素"><a href="#3-1-检查谓词是否至少匹配一个元素" class="headerlink" title="3.1 检查谓词是否至少匹配一个元素"></a>3.1 检查谓词是否至少匹配一个元素</h4><p><code>anyMatch()</code>：流中是否有一个元素能匹配给定的谓词。</p>
<p>返回一个boolean，因此是一个终端操作。</p>
<h4 id="3-2-检查谓词是否匹配所有元素"><a href="#3-2-检查谓词是否匹配所有元素" class="headerlink" title="3.2 检查谓词是否匹配所有元素"></a>3.2 检查谓词是否匹配所有元素</h4><p><code>allMatch()</code>：流中的元素是否都能匹配给定的谓词。是一个终端操作。</p>
<h4 id="3-3-检查谓词是否不匹配所有元素"><a href="#3-3-检查谓词是否不匹配所有元素" class="headerlink" title="3.3 检查谓词是否不匹配所有元素"></a>3.3 检查谓词是否不匹配所有元素</h4><p><code>noneMatch()</code>：流中没有任何元素与给定的谓词匹配。</p>
<h4 id="3-4-查找元素"><a href="#3-4-查找元素" class="headerlink" title="3.4 查找元素"></a>3.4 查找元素</h4><p><code>findAny()</code>：将返回当前流中的任意元素。如果流中没有元素，返回值可能为空，于是Java 8引入了<code>Optional&lt;T&gt;</code>类。</p>
<h3 id="Optional简介"><a href="#Optional简介" class="headerlink" title="Optional简介"></a>Optional简介</h3><p><code>Optional&lt;T&gt;</code>类（<code>java.util.Optional</code>）是一个容器类，代表一个值存在或不存在。</p>
<p>方法简介：</p>
<p>1、<code>isPresent()</code>：将在Optional包含值的时候返回true, 否则返回false。</p>
<p>2、<code>ifPresent(Consumer&lt;T&gt; block)</code>：会在值存在的时候执行给定的代码块。</p>
<p>3、<code>T get()</code>：会在值存在时返回值，否则抛出一个<code>NoSuchElement</code>异常。</p>
<p>4、<code>T orElse(T other)</code>：会在值存在时返回值，否则返回一个默认值。 </p>
<h4 id="3-5-查找第一个元素"><a href="#3-5-查找第一个元素" class="headerlink" title="3.5 查找第一个元素"></a>3.5 查找第一个元素</h4><p><code>findFirst()</code>：返回流中的第一个元素。同样地，如果流中没有元素，返回值可能为空，返回类型为<code>Optional&lt;T&gt;</code>类。</p>
<p>有些流有一个出现顺序（encounter order）来指定流中项目出现的逻辑顺序（比如由List或排序好的数据列生成的流）。对于这种流，可能想要找到第一个元素。</p>
<h3 id="4-归约"><a href="#4-归约" class="headerlink" title="4. 归约"></a>4. 归约</h3><p><code>reduce()</code>：将流中所有元素反复结合起来，得到一个值。</p>
<p><code>reduce()</code>方法有两个重载的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param identity 归约的初始值</span><br><span class="line"> * @param accumulator 归约操作</span><br><span class="line"> *&#x2F;</span><br><span class="line">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param accumulator 归约操作</span><br><span class="line"> * @return Optional&lt;T&gt;对象，由于没有初始值，流中元素可能为空，故返回值会存在空的情况。</span><br><span class="line"> *&#x2F;</span><br><span class="line">Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);</span><br></pre></td></tr></table></figure>

<p>map和reduce的连接通常称为map-reduce模式，因Google用它来进行网络搜索而出名，因为它很容易并行化。</p>
<h3 id="5-数值流"><a href="#5-数值流" class="headerlink" title="5. 数值流"></a>5. 数值流</h3><p>流中的元素是数值型的，例如int，long，double。尽管可以把这些数值型元素放入流中，但实际上是暗含了装箱操作，将数值型元素转换成对应的包装类型，从而形成对象流。</p>
<p>Stream API提供了原始类型流特化，专门支持处理数值流的方法。减去装箱操作的损耗。</p>
<h4 id="5-1-原始类型流特化"><a href="#5-1-原始类型流特化" class="headerlink" title="5.1 原始类型流特化"></a>5.1 原始类型流特化</h4><p>Java 8引入了三个原始类型特化流接口：<code>IntStream</code>、<code>DoubleStream</code>和<code>LongStream</code>，分别将流中的元素特化为int、long和double，从而避免了暗含的装箱成本。</p>
<p>每个接口都带来了进行常用数值归约的新方法，比如对数值流求和的sum，找到大元素的max。此外还有在必要时再把它们转换回对象流的方法。</p>
<h5 id="5-1-1-映射到数值流"><a href="#5-1-1-映射到数值流" class="headerlink" title="5.1.1 映射到数值流"></a>5.1.1 映射到数值流</h5><p>将流转换为特化版本的常用方法是<code>mapToInt</code>、<code>mapToDouble</code>和<code>mapToLong</code>。这些方法map方法的工作方式一样，只是它们返回的是一个特化流，而不是<code>Stream&lt;T&gt;</code>。</p>
<h5 id="5-1-2-转换回对象流"><a href="#5-1-2-转换回对象流" class="headerlink" title="5.1.2 转换回对象流"></a>5.1.2 转换回对象流</h5><p>一旦有了数值流，可能需要将其转换回非特化流。</p>
<h5 id="5-1-3-默认值OptionalInt"><a href="#5-1-3-默认值OptionalInt" class="headerlink" title="5.1.3 默认值OptionalInt"></a>5.1.3 默认值OptionalInt</h5><p>对于原始类型特化流接口中的max，min，average等方法的返回值。如果流是空的，这些方法的返回值为空，但不能默认为0。因为可能真实计算的结果恰好为0。</p>
<p>可以使用Optional类来解决返回值为空的情况。但<code>Optional&lt;T&gt;</code>只能接收包装类型。传递原始类型会触发自动装箱操作，产生损耗。</p>
<p>Java 8同样引入了Optional原始类型特化版本：<code>OptionalInt</code>、<code>OptionalDouble</code>和<code>OptionalLong</code>，用这些Optional类来解决传递原始类型时自动装箱的问题。</p>
<h4 id="5-2-数值范围"><a href="#5-2-数值范围" class="headerlink" title="5.2 数值范围"></a>5.2 数值范围</h4><p>和数字打交道时，有一个常用的东西就是数值范围。比如生成1和100之间的所有数字。</p>
<p>Java 8引入了两个可以用于<code>IntStream</code>和<code>LongStream</code>的静态方法，帮助生成这种范围： <code>range</code>和<code>rangeClosed</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * range方法表示的范围为：[startInclusive,endExclusive)</span><br><span class="line"> * @param startInclusive 数值范围开始</span><br><span class="line"> * @param endExclusive 数值范围结束（不包含该值）</span><br><span class="line"> *&#x2F;</span><br><span class="line">IntStream range(int startInclusive, int endExclusive);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * rangeClosed方法表示的范围为：[startInclusive,endExclusive]</span><br><span class="line"> * @param startInclusive 数值范围开始</span><br><span class="line"> * @param endExclusive 数值范围结束（包含该值）</span><br><span class="line"> *&#x2F;</span><br><span class="line">IntStream rangeClosed(int startInclusive, int endInclusive);</span><br></pre></td></tr></table></figure>

<p>这两个方法都是第一个参数接受起始值，第二个参数接受结束值。但<code>range</code>是不包含结束值的，而<code>rangeClosed</code>则包含结束值。</p>
<h3 id="6-构建流"><a href="#6-构建流" class="headerlink" title="6. 构建流"></a>6. 构建流</h3><p>介绍如何从值序列、数组、文件来创建流，甚至由生成函数来创建无限流。</p>
<h4 id="6-1-由值创建流"><a href="#6-1-由值创建流" class="headerlink" title="6.1 由值创建流"></a>6.1 由值创建流</h4><p>使用静态方法<code>Stream.of(T...values)</code>，通过显式值创建一个流。它可以接受任意数量的参数。</p>
<p>使用静态方法<code>Stream.empty()</code>，创建一个空流。</p>
<h4 id="6-2-由数组创建流"><a href="#6-2-由数组创建流" class="headerlink" title="6.2 由数组创建流"></a>6.2 由数组创建流</h4><p>使用静态方法<code>Arrays.stream</code>从数组创建一个流。它接受一个数组作为参数。</p>
<h4 id="6-3、由文件生成流"><a href="#6-3、由文件生成流" class="headerlink" title="6.3、由文件生成流"></a>6.3、由文件生成流</h4><p>Java中用于处理文件等I/O操作的NIO API（非阻塞 I/O）已更新，以便利用Stream API。</p>
<p><code>java.nio.file.Files</code>中的很多静态方法都会返回一个流。</p>
<p>例如，<code>Files.lines</code>，它会返回一个由指定文件中的各行构成的字符串流。</p>
<h4 id="6-4-由函数生成流：创建无限流"><a href="#6-4-由函数生成流：创建无限流" class="headerlink" title="6.4 由函数生成流：创建无限流"></a>6.4 由函数生成流：创建无限流</h4><p>Stream API提供了两个静态方法来从函数生成流：<code>Stream.iterate</code>和<code>Stream.generate</code>。</p>
<p>这两个操作可以创建所谓的无限流：不像从固定集合创建的流那样有固定大小的流。</p>
<p>由<code>iterate</code>和<code>generate</code>产生的流会用给定的函数按需创建值，因此可以无穷无尽地计算下去！</p>
<p>一般来说，应该使用<code>limit(n)</code>来对这种流加以限制，以避免打印无穷多个值。</p>
<h2 id="第六章：用流收集数据"><a href="#第六章：用流收集数据" class="headerlink" title="第六章：用流收集数据"></a>第六章：用流收集数据</h2><h3 id="1-汇总"><a href="#1-汇总" class="headerlink" title="1. 汇总"></a>1. 汇总</h3><p><code>Collectors</code>类专门为汇总提供了一个工厂方法：<code>Collectors.summingInt</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? super T&gt; mapper);</span><br></pre></td></tr></table></figure>
<p>它可接受一个把对象映射为求和所需int的函数，并返回一个收集器，该收集器在传递给普通的collect方法后即执行我们需要的汇总操作。</p>
<p>类似的还有<code>Collectors.summingDouble</code>方法和<code>Collectors.summingLong</code>方法，汇总为double和long类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collector&lt;T, ?, Long&gt; summingLong(ToLongFunction&lt;? super T&gt; mapper);</span><br><span class="line">Collector&lt;T, ?, Double&gt; summingDouble(ToDoubleFunction&lt;? super T&gt; mapper);</span><br></pre></td></tr></table></figure>

<p>汇总不仅仅只有求和。</p>
<p>平均数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collector&lt;T, ?, Double&gt; averagingInt(ToIntFunction&lt;? super T&gt; mapper);</span><br><span class="line">Collector&lt;T, ?, Double&gt; averagingDouble(ToDoubleFunction&lt;? super T&gt; mapper);</span><br><span class="line">Collector&lt;T, ?, Double&gt; averagingLong(ToLongFunction&lt;? super T&gt; mapper);</span><br></pre></td></tr></table></figure>

<p>一次操作取得多个汇总结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collector&lt;T, ?, IntSummaryStatistics&gt; summarizingInt(ToIntFunction&lt;? super T&gt; mapper);</span><br><span class="line">Collector&lt;T, ?, LongSummaryStatistics&gt; summarizingLong(ToLongFunction&lt;? super T&gt; mapper);</span><br><span class="line">Collector&lt;T, ?, DoubleSummaryStatistics&gt; summarizingDouble(ToDoubleFunction&lt;? super T&gt; mapper);</span><br></pre></td></tr></table></figure>
<p>可以通过对用getter方法取得汇总结果。</p>
<h3 id="2-连接字符串"><a href="#2-连接字符串" class="headerlink" title="2. 连接字符串"></a>2. 连接字符串</h3><p><code>joining</code>工厂方法返回的收集器会把对流中每一个对象应用toString方法得到的所有字符串连接成一个字符串。</p>
<p><code>joining</code>方法有3个重载：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 内部使用StringBuilder拼接</span><br><span class="line"> *&#x2F;</span><br><span class="line">Collector&lt;CharSequence, ?, String&gt; joining();</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param delimiter 表示每个字符串连接时的分隔符</span><br><span class="line"> *&#x2F;</span><br><span class="line">Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param delimiter 分隔符</span><br><span class="line"> * @param prefix 字符串前缀</span><br><span class="line"> * @param suffix 字符串后缀</span><br><span class="line"> *&#x2F;</span><br><span class="line">Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,CharSequence prefix,CharSequence suffix);</span><br></pre></td></tr></table></figure>

<h3 id="3-分组"><a href="#3-分组" class="headerlink" title="3. 分组"></a>3. 分组</h3><p><code>groupingBy</code>：跟数据库中的group by分组操作一样。同时支持多级分组。</p>
<p><code>groupingBy</code>方法有多个重载：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 内部调用的是带两个参数的groupingBy方法，第二个参数传递的是Collectors.toList()。 </span><br><span class="line"> * @param classifier 一个Function函数型接口。</span><br><span class="line"> *&#x2F;</span><br><span class="line">groupingBy(Function&lt;? super T, ? extends K&gt; classifier);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 内部调用的是三个参数的groupingBy方法。</span><br><span class="line"> * @param classifier 一个Function函数型接口</span><br><span class="line"> * @param downstream 一个收集器对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">groupingBy(Function&lt;? super T, ? extends K&gt; classifier,Collector&lt;? super T, A, D&gt; downstream);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 有三个参数，groupingBy分组的具体实现。</span><br><span class="line"> *&#x2F;</span><br><span class="line">groupingBy(Function&lt;? super T, ? extends K&gt; classifier,Supplier&lt;M&gt; mapFactory,Collector&lt;? super T, A, D&gt; downstream);</span><br></pre></td></tr></table></figure>

<p>可以把第二个<code>groupingBy</code>收集器传递给外层收集器来实现多级分组。 但进一步说，传递给第一个<code>groupingBy</code>的第二个收集器可以是任何类型，而不一定是另一个<code>groupingBy</code>。</p>
<p>收集器返回的结果可能是Optional包装后的对象，对于多级分组来说，第二个收集器对象参数返回的Optional对象可能没什么用。第一层groupingBy已经把为空的情况给排除掉了。</p>
<p>Collectors收集器提供了<code>collectingAndThen</code>方法将收集器进行转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 返回转换后的另一个收集器</span><br><span class="line"> * @param downstream 需要转换的收集器</span><br><span class="line"> * @param finisher 转换函数</span><br><span class="line"> *&#x2F;</span><br><span class="line">Collector&lt;T,A,RR&gt; Collectors.collectingAndThen(Collector&lt;T,A,R&gt; downstream,Function&lt;R,RR&gt; finisher);</span><br></pre></td></tr></table></figure>

<p><code>groupingBy</code>可以联合其它收集器使用，经常使用的是mapping方法。它可以让接受特定类型元素的收集器适应不同类型的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param mapper 一个函数型接口,对流中的元素做映射</span><br><span class="line"> * @param downstream 一个收集器，将映射后的元素收集起来</span><br><span class="line"> *&#x2F;</span><br><span class="line">Collector&lt;T, ?, R&gt; mapping(Function&lt;? super T, ? extends U&gt; mapper,Collector&lt;? super U, A, R&gt; downstream);</span><br></pre></td></tr></table></figure>

<h3 id="4-分区"><a href="#4-分区" class="headerlink" title="4. 分区"></a>4. 分区</h3><p><code>partitioningBy</code>分区是分组的特殊情况：由一个谓词（返回一个布尔值的函数）作为分类函数，它称分区函数。</p>
<p>分区函数返回一个布尔值，这意味着得到的分组Map的键类型是Boolean，于是它多可以分为两组——true是一组，false是一组。</p>
<p><code>partitioningBy</code>收集器有两个重载的方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 内部调用了两个参数的重载方法，第二个参数传递的是一个Collectors.toList()收集器。</span><br><span class="line"> * @param predicate 断言型接口</span><br><span class="line"> *&#x2F;</span><br><span class="line">Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param predicate 断言型接口</span><br><span class="line"> * @param downstream 收集器</span><br><span class="line"> *&#x2F;</span><br><span class="line">Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate,Collector&lt;? super T, A, D&gt; downstream);</span><br></pre></td></tr></table></figure>
<p>分区也可用相同的谓词使用<code>filter</code>筛选来实现。</p>
<h4 id="分区的好处："><a href="#分区的好处：" class="headerlink" title="分区的好处："></a>分区的好处：</h4><ul>
<li>保留了分区函数返回true或false的两套流元素列表。</li>
<li>使用filter筛选需要操作两次，一次利用谓词，一次利用谓词的非。</li>
</ul>
<h2 id="第七章：并行数据处理与性能"><a href="#第七章：并行数据处理与性能" class="headerlink" title="第七章：并行数据处理与性能"></a>第七章：并行数据处理与性能</h2><h3 id="并行处理数据一定比串行处理快吗？"><a href="#并行处理数据一定比串行处理快吗？" class="headerlink" title="并行处理数据一定比串行处理快吗？"></a>并行处理数据一定比串行处理快吗？</h3><p>答案是不一定。</p>
<p>假设你现在要进行数字累加的操作，例如计算1至100万之间所有数字的和。</p>
<p>现在有三种方案可供选择。</p>
<p>方案一：原始迭代方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static long iterateSum(long n) &#123;</span><br><span class="line">    long result &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        result +&#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方案二：使用<code>Stream</code>串行流处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static long streamSum(long n) &#123;</span><br><span class="line">    Long result &#x3D; Stream.iterate(0L, i -&gt; i + 1)</span><br><span class="line">            .limit(n)</span><br><span class="line">            .reduce(0L, Long::sum);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方案三：使用<code>ParallelStream</code>并行流处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static long parallelSum(long n) &#123;</span><br><span class="line">    Long result &#x3D; Stream.iterate(0L, i -&gt; i + 1)</span><br><span class="line">            .limit(n)</span><br><span class="line">            .parallel()</span><br><span class="line">            .reduce(0L, Long::sum);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原始迭代方案中不需要对原始类型的数字进行装箱操作。</p>
<p>串行流方案中利用<code>Stream</code>接口的<code>iterate</code>方法生成0到n的自然数流，默认是串行流，然后归约求和。</p>
<p>并行流方案中利用<code>Stream</code>接口的<code>iterate</code>方法生成0到n的自然数流，使用<code>parallel</code>方法将流转换成并行流，然后归约求和。</p>
<p>测试方法：运行10次，取最短时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static long measureSumPerf(Function&lt;Long,Long&gt; adder,long n) &#123;</span><br><span class="line">    long fastest &#x3D; Integer.MAX_VALUE;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">        long start &#x3D; System.nanoTime();</span><br><span class="line">        long sum &#x3D; adder.apply(n);</span><br><span class="line">        long duration &#x3D; (System.nanoTime() - start) &#x2F; 1_100_100;</span><br><span class="line">        if (duration &lt; fastest) &#123;</span><br><span class="line">            fastest &#x3D; duration;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return fastest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; test</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F; 原始迭代方式更快，它不需要对原始类型进行装箱&#x2F;拆箱操作</span><br><span class="line">    System.out.println(&quot;iterate sum min time:&quot; + measureSumPerf(</span><br><span class="line">    				StreamPerformanceTest::iterateSum, 100000000));</span><br><span class="line">    &#x2F;&#x2F; iterate生成的是装箱的对象，必须拆箱成数字才能求和。</span><br><span class="line">    System.out.println(&quot;stream sum min time:&quot; + measureSumPerf(</span><br><span class="line">    				StreamPerformanceTest::streamSum, 100000000));</span><br><span class="line">    &#x2F;&#x2F; 整个数字在过程开始时并没有准备好，无法有效的把流划分为小块来并行处理。</span><br><span class="line">    System.out.println(&quot;parallel stream sum min time:&quot; + measureSumPerf(</span><br><span class="line">    				StreamPerformanceTest::parallelSum, 100000000));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>测试结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原始迭代方案最快：iterate sum min time:11</span><br><span class="line">串行流方案第二快：stream sum min time:198</span><br><span class="line">并行流方案最慢：parallel stream sum min time:267</span><br></pre></td></tr></table></figure>

<p>可见并行执行并不比串行执行快。但实际上这次试验的很大一部分时间消耗在对原始数据类型进行装箱的操作上。因为<code>Stream</code>接口的<code>iterate</code>方法生成的是包装对象，求和时需要拆箱成数字。同时使用<code>iterate</code>方法在程序开始时并没有把整个数字序列准备好，无法有效的把流划分为小块来并行处理。</p>
<p>接下来使用原始类型特化流来生成数字流。</p>
<p>原始类型特化流串行处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static long longStreamSum(long n) &#123;</span><br><span class="line">   long result &#x3D; LongStream.rangeClosed(1, n).reduce(0L, Long::sum);</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原始类型特化流并行处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static long longParallelSum(long n) &#123;</span><br><span class="line">    long result &#x3D; LongStream.rangeClosed(1, n).parallel().reduce(0L, Long::sum);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; LongStream.rangeClosed直接产生原始类型的long数字，没有装箱拆箱的开销。</span><br><span class="line">System.out.println(&quot;long stream sum min time:&quot; + measureSumPerf(</span><br><span class="line">    				StreamPerformanceTest::longStreamSum,100000000));</span><br><span class="line">&#x2F;&#x2F; LongStream.rangeClosed在过程开始时就会生成数字范围，很容易拆分为独立的小块进行并行处理。</span><br><span class="line">System.out.println(&quot;long parallel stream sum min time:&quot; + 			  measureSumPerf(StreamPerformanceTest::longParallelSum,100000000));</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原始类型特化流串行处理：long stream sum min time:7</span><br><span class="line">原始类型特化流并行处理：long parallel stream sum min time:1</span><br></pre></td></tr></table></figure>

<p><code>LongStream.rangeClosed</code>直接产生原始类型的long数字，没有装箱拆箱的开销。</p>
<p><code>LongStream.rangeClosed</code>在过程开始时就会生成数字范围，很容易拆分为独立的小块进行并行处理。</p>
<h3 id="并行流有时候比串行流慢的原因"><a href="#并行流有时候比串行流慢的原因" class="headerlink" title="并行流有时候比串行流慢的原因"></a>并行流有时候比串行流慢的原因</h3><p>并行流有时候比串行流慢的原因：</p>
<ol>
<li>没有使用合理的使用数据结构，导致时间浪费在其它非流处理的操作上。</li>
<li>并行流的底层实现是Fork/Join框架。它是基于多线程的，线程之间进行上下文切换需要耗时。同时线程是操作系统进行调度的。线程自己无法控制时间。</li>
</ol>
<h3 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h3><p>Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。体现了分治法的思想。Fork的意思是拆分，Join的意思是合并。比如计算1+2+…+10000，可以分割成10个子任务，每个子任务分别对1000个数进行求和， 最终汇总这10个子任务的结果。Fork/Join框架的运行流程图如下：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/02/15/4YvPn3qOA8BeKtw.jpg"  alt="Fork-Join.png"></p>
<p>Fork/Join的拆分重点在于任务什么时候足够小或不可分，不可再拆分的任务顺序执行，不同的任务之间并行执行。所有不可拆分的子任务分配到多个任务队列中等待线程去执行，每个队列都有一个单独的线程去执行任务。理想情况下，划分并行任务时，应该让每个任务都用相同的时间完成，让所有的CPU都同样繁忙，充分的利用CPU。但实际中，由于线程是由操作系统根据时间片进行调度的，每个子任务所花的时间可能天差地别。于是会出现一个任务队列的任务全部执行完了，另一个队列中还有很多任务的情况。这个时候CPU的利用率没有最大化。Java 8采用工作窃取算法来解决这一问题。</p>
<h3 id="工作窃取（work-stealing）算法"><a href="#工作窃取（work-stealing）算法" class="headerlink" title="工作窃取（work-stealing）算法"></a>工作窃取（work-stealing）算法</h3><p>工作窃取算法是指某个线程从其它队列中窃取任务来执行。某个线程，自己队列中的任务执行完了，就去别的还有任务的队列中窃取一个任务来执行。这个时候会存在线程竞争关系，窃取线程和被窃取线程之间同时访问同一个队列。通常使用双端队列来解决。被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>
<h4 id="工作窃取算法的优点："><a href="#工作窃取算法的优点：" class="headerlink" title="工作窃取算法的优点："></a>工作窃取算法的优点：</h4><p>充分利用线程进行并行计算，减少了线程间的竞争。</p>
<h4 id="工作窃取算法的缺点："><a href="#工作窃取算法的缺点：" class="headerlink" title="工作窃取算法的缺点："></a>工作窃取算法的缺点：</h4><p>在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p>
<h3 id="Fork-Join框架的设计思路"><a href="#Fork-Join框架的设计思路" class="headerlink" title="Fork/Join框架的设计思路"></a>Fork/Join框架的设计思路</h3><ol>
<li>首先需要一个Fork类去把大任务进行递归Fork拆分，直至拆分成不可再分的小任务。</li>
<li>拆分出来的子任务均匀地分配到n个双端队列中，启动n个线程分别从双端队列中获取任务执行。每个子任务执行完的结果统一放在一个结果队列中，启动一个线程从结果队列中取结果，然后Join合并成最终结果。</li>
</ol>
<div><div style="text-align:center;color: #ccc;font-size:14px;font-family: cursive;">-------------&#x7EB8;&#x77ED;&#x60C5;&#x957F;<i class="fa fa-umbrella" style="margin:0 7px;"></i>&#x4E0E;&#x4F60;&#x8BC9;&#x8BF4;-------------</div></div><div id="wechat_subscriber"><center><img id="wechat_subscriber_qcode" src="https://i.loli.net/2020/02/15/SDRF87I6ohlyVk1.jpg" onerror="onerror=null;src='/assets/images/wechat/wxgzh.jpg'" alt="向日葵的自我修养"></center><div>欢迎关注我的微信公众号~</div></div></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:admin@lilu.org.cn">SunChaser</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lilu.org.cn/2019/12/12/reading-notes/java8-in-action/Part-II-Functional-Data-Processing/">https://lilu.org.cn/2019/12/12/reading-notes/java8-in-action/Part-II-Functional-Data-Processing/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lilu.org.cn" target="_blank">向日葵的自我修养</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java8/">Java8</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/lilu.org.cn/cover.png" data-sites="twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://i.loli.net/2020/02/15/wBGoHtiL8PqMKWA.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://i.loli.net/2020/02/15/rYEfbjCAyuUGce5.png" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(1)/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/lilu.org.cn/cover.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（一）：接口重构和新特性</div></div></a></div><div class="next-post pull_right"><a href="/2019/12/12/reading-notes/java8-in-action/Part-I-Basics/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/lilu.org.cn/cover.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《Java 8实战》读书笔记系列——第一部分：基础知识</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(4)/" title="《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（四）：使用新的日期时间API"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/lilu.org.cn/cover.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-history fa-fw" aria-hidden="true"></i> 2019-12-12</div><div class="relatedPosts_title">《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（四）：使用新的日期时间API</div></div></a></div><div class="relatedPosts_item"><a href="/2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(3)/" title="《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（三）：从一个生产环境的事故到异步编程思想"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/lilu.org.cn/cover.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-history fa-fw" aria-hidden="true"></i> 2019-12-12</div><div class="relatedPosts_title">《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（三）：从一个生产环境的事故到异步编程思想</div></div></a></div><div class="relatedPosts_item"><a href="/2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(2)/" title="《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（二）：优雅的解决NPE问题"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/lilu.org.cn/cover.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-history fa-fw" aria-hidden="true"></i> 2019-12-12</div><div class="relatedPosts_title">《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（二）：优雅的解决NPE问题</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/gh/xaoxuu/volantis/js/volantis.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: false,
  verify: false,
  appId: 'qc8Hd8UPK33VUIOJ3zDjAn8W-gzGzoHsz',
  appKey: 'K2EAXbjfO9i6G4Myz0gHIIgr',
  placeholder: '记得留下你的昵称和邮箱...可以快速收到回复哦',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-cn',
  recordIP: false,
  serverURLs: ''
});</script></div></article></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/lilu.org.cn/cover.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By SunChaser</div><div class="footer_custom_text">没有行动的梦想都是妄想~</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="canvas_nest" color="255,0,0" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/search/local-search.js"></script></body></html>